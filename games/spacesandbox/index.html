<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Retro Space Sim 98 v1.4</title> <!-- Version Update -->
    <style>
        /* Reset (minimalist 90s style) */
        body, html {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #000000; /* Pure black */
            margin: 0;
            padding: 0;
            font-family: "Arial", sans-serif; /* Common 90s font */
            color: #00FF00; /* Classic green terminal text */
        }

        /* Canvas */
        #canvas {
            display: block;
            width: 100%;
            height: 100%;
            cursor: crosshair; /* Simple cursor */
            background-color: #000000; /* Ensure canvas bg is black */
        }

        /* Toolbar - Mimicking basic GUI toolbars */
        #toolbar {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            background: #C0C0C0; /* Classic grey */
            padding: 5px;
            border-bottom: 2px solid #808080;
            display: flex;
            flex-wrap: wrap; /* Allow wrapping */
            gap: 5px 10px; /* Row gap, Column gap */
            z-index: 1000;
            font-size: 12px;
            color: #000; /* Black text on grey */
        }
         /* Toolbar group styling */
         .toolbar-group {
            display: flex;
            flex-wrap: nowrap; /* Keep items in group together */
            align-items: center;
            padding: 2px 5px;
            border: 1px solid #A0A0A0;
            margin-right: 5px;
            background: #C0C0C0; /* Match toolbar bg */
         }

        #toolbar label {
            margin-right: 3px;
            font-weight: bold;
            line-height: 20px; /* Align labels with controls better */
            white-space: nowrap; /* Prevent labels breaking */
        }

        #toolbar button, #toolbar select, #toolbar input {
            padding: 2px 5px;
            border: 1px solid #808080;
            border-right-color: #000;
            border-bottom-color: #000;
            background: #C0C0C0;
            color: #000;
            font-size: 11px; /* Smaller font size for controls */
            cursor: pointer; /* Default cursor usually fine for 90s */
            margin: 0 2px; /* Consistent margin within/between controls */
            height: 22px; /* Consistent height */
            vertical-align: middle;
            box-sizing: border-box; /* Include padding/border in height */
        }
        #toolbar button.active { /* Style for active toggle buttons */
             border: 1px solid #000;
             border-right-color: #808080;
             border-bottom-color: #808080;
             background: #A0A0A0; /* Darker background */
             font-weight: bold;
        }
        #toolbar button:active:not(.active) { /* Standard press effect */
            border: 1px solid #000;
            border-right-color: #808080;
            border-bottom-color: #808080;
            background: #B0B0B0; /* Slightly darker on press */
        }
        #toolbar button:disabled {
            color: #808080; /* Grey out disabled button text */
            cursor: not-allowed;
            border-color: #A0A0A0;
            border-right-color: #606060;
            border-bottom-color: #606060;
        }
        #toolbar input[type="color"] {
             width: 30px; height: 20px; padding: 1px; border-width: 1px;
        }
         #toolbar input[type="number"] {
             width: 60px; height: 20px; padding-left: 3px; border-width: 1px;
         }
         #toolbar input[type="range"] {
             height: 18px; margin-top: 2px;
         }
        #toolbar .value-display {
            line-height: 20px; margin-left: -2px; margin-right: 5px; font-size: 11px;
            min-width: 30px; display: inline-block; text-align: right;
        }
        /* Smaller buttons for toggles */
        #toolbar .toggle-button {
             padding: 2px 3px;
             min-width: 60px; /* Ensure text fits */
             text-align: center;
        }


        /* Info Panels - Simple bordered boxes */
        .info-panel {
            position: absolute;
            background: rgba(0, 0, 0, 0.8); /* Slightly darker */
            border: 1px solid #00FF00; /* Green border */
            padding: 8px;
            font-size: 11px;
            line-height: 1.4;
            max-width: 250px; /* Wider */
            z-index: 900;
            box-shadow: 2px 2px 0px #008800; /* Subtle 3D effect */
        }
        #simInfo {
            top: 105px; /* Adjusted for more toolbar rows */
            right: 10px;
        }
        #selectedInfo {
            bottom: 10px;
            right: 10px;
            max-height: 280px; /* More height for orbital info + editing */
            overflow-y: auto; /* Add scroll if needed */
        }
        #instructions {
            top: 105px; /* Adjusted for more toolbar rows */
            left: 10px;
            width: 240px; /* Wider */
        }
         .info-panel h3 { margin-top: 0; margin-bottom: 5px; font-size: 12px; text-decoration: underline; color: #FFFF00; }
         .info-panel ul { list-style-type: square; padding-left: 15px; margin: 0; }
         .info-panel li { margin-bottom: 3px; }
         .info-panel::-webkit-scrollbar { width: 8px; }
         .info-panel::-webkit-scrollbar-track { background: #333; border: 1px solid #00FF00; }
         .info-panel::-webkit-scrollbar-thumb { background: #00FF00; border: 1px solid #FFFF00; }

        /* Input fields inside info panel */
        .info-panel .edit-label { display: inline-block; width: 35px; } /* Align labels */
        .info-panel input[type="number"] {
            width: 55px; /* Slightly wider */
            height: 16px;
            font-size: 10px;
            background: #333;
            color: #00FF00;
            border: 1px solid #008800;
            padding: 1px 3px;
            margin-left: 2px;
            vertical-align: middle;
        }

        /* Particle Styles - Simple squares/pixels */
        .particle { /* Particles drawn directly on canvas */ }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>

    <!-- Toolbar -->
    <div id="toolbar">
        <!-- Add/Edit Tools -->
        <div class="toolbar-group">
             <button id="addBody" title="Toggle Add Mode: Click canvas to place selected body">Add Mode</button>
             <button id="pushBody" title="Toggle Push Mode: Click/Drag on selected body to apply impulse" disabled>Push Mode</button> <!-- NEW -->
             <label for="bodyType">Type:</label>
             <select id="bodyType" title="Select Body Type"> <option value="planet">Planet</option> <option value="star">Star</option> <option value="asteroid">Rock</option> <option value="blackhole">Void</option> <option value="comet">Comet</option> </select>
             <label for="mass">Mass:</label>
             <input type="number" id="mass" value="100" min="1" title="Mass (for Add Mode)">
             <label for="color">Color:</label>
             <input type="color" id="color" value="#00FF00" title="Color (for Add Mode)">
        </div>

        <!-- Simulation Control -->
        <div class="toolbar-group">
            <button id="playPause" title="Pause/Resume simulation">Pause</button>
            <label for="speedControl">Speed:</label>
            <input type="range" id="speedControl" min="0.1" max="5" step="0.1" value="1" title="Simulation Speed">
            <span id="speedValue" class="value-display">1.0x</span>
            <label for="gravityControl">Gravity:</label>
            <input type="range" id="gravityControl" min="0" max="20" step="0.5" value="5" title="Gravitational Constant (G)">
            <span id="gravityValue" class="value-display">5.0</span>
         </div>

         <!-- View/Selection Control -->
         <div class="toolbar-group">
             <button id="resetView" title="Center view and reset zoom">Reset View</button>
             <button id="followBody" title="Follow Selected Body" disabled>Follow</button>
             <button id="deleteBody" title="Delete Selected Body" disabled>Delete</button>
             <button id="clearBodies" title="Remove all bodies">Clear All</button>
         </div>

        <!-- Visualization Toggles -->
        <div class="toolbar-group">
             <label>Show:</label>
             <button id="toggleTrails" class="toggle-button active" title="Show/Hide trails">Trails ON</button>
             <button id="toggleOrbit" class="toggle-button" title="Show/Hide predicted orbit" disabled>Orbit OFF</button>
             <button id="toggleLabels" class="toggle-button" title="Show/Hide body labels">Labels OFF</button> <!-- NEW -->
             <button id="toggleHZ" class="toggle-button active" title="Show/Hide Habitable Zones">HZ ON</button> <!-- NEW -->
             <button id="toggleGlows" class="toggle-button active" title="Show/Hide Star Glows">Glows ON</button> <!-- NEW -->
        </div>

        <!-- Presets & Generation -->
        <div class="toolbar-group">
              <label>Load:</label>
              <button id="regenSystem" title="Generate a new random system">New Random</button>
              <button id="loadSolarSystem" title="Load Simple Solar System Preset">Solar System</button>
              <button id="loadGalaxy" title="Load Simple Galaxy Preset">Galaxy</button> <!-- NEW -->
        </div>
    </div>

    <!-- Combined Sim Info Panel -->
    <div id="simInfo" class="info-panel">
        <h3>Simulation Stats</h3>
        <p id="bodyCount">Bodies: 0</p>
        <p id="kinetic">Kinetic E: 0.00</p>
        <p id="potential">Potential E: 0.00</p>
        <p id="total">Total E: 0.00</p>
        <p id="simTime">Sim Time: 0.0 s</p>
    </div>

    <!-- Selected Body Info Panel -->
    <div id="selectedInfo" class="info-panel">
        <h3>Selected Body</h3>
        <p id="selectedDetails">Click a body to select</p>
    </div>

    <!-- Instructions Panel -->
    <div id="instructions" class="info-panel">
        <h3>How To Use - v1.4</h3> <!-- Update version -->
        <ul>
            <li>Select type, mass, color for Add Mode.</li>
            <li>Click 'Add Mode', then click canvas (or drag).</li>
            <li>Click 'Push Mode', select body, then click/drag ON body to apply impulse.</li> <!-- NEW -->
            <li>Right-Click + Drag to Pan view.</li>
            <li>Mouse Wheel to Zoom.</li>
            <li>Click body for info & selection.</li>
            <li>'Follow' locks view on selected body.</li>
            <li>'Delete' removes selected body.</li>
            <li>Edit Mass/Velocity in Selected Body panel.</li> <!-- UPDATED -->
            <li>Use Show toggles for Trails, Orbit, Labels, HZ, Glows.</li> <!-- NEW -->
            <li>Adjust Speed and Gravity sliders.</li>
            <li>'Clear All' removes everything.</li>
            <li>Load 'Solar System', 'Galaxy', or 'New Random'.</li> <!-- UPDATED -->
        </ul>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            generateBackgroundStars(canvas.width, canvas.height);
        }
        window.addEventListener('resize', resizeCanvas);


        // --- Simulation Constants & State ---
        let G = 5;
        const SOFTENING = 50;
        let TIME_STEP = 1;
        let showTrails = true;
        let showOrbit = false;
        let showLabels = false; // NEW
        let showHZ = true; // NEW
        let showGlows = true; // NEW
        let isPaused = false;
        let addMode = false;
        let pushMode = false; // NEW: Impulse tool state
        let simulationTime = 0;

        // Viewport State
        let scale = 0.5;
        let offsetX = canvas.width / 2;
        let offsetY = canvas.height / 2;
        let isPanning = false;
        let panStart = { x: 0, y: 0 };
        let isFollowing = false;
        let followedBody = null;

        // Interaction State
        let isCreatingBody = false;
        let creationStartPos = null;
        let tempBody = null;
        let isPushingBody = false; // NEW
        let pushStartPos = null; // NEW
        let pushBody = null; // NEW: Body being pushed
        let currentMousePos = { x: 0, y: 0 };

        // Body Data
        let bodies = [];
        let selectedBody = null;
        let selectedBodyAttractor = null;
        let selectedBodyOrbitalParams = null;
        const MAX_TRAIL_LENGTH = 50;

        // Particle System
        const particles = [];
        const MAX_PARTICLES = 300;

        // Background Stars
        let backgroundStars = [];
        const NUM_BACKGROUND_STARS = 300;

        // Cache for textures
        const textureCache = new Map();

        // --- Procedural Generation Data ---
        // (Unchanged from previous)
        const PLANET_SUBTYPES = { ROCKY: { name: 'Rocky', colorHueRange: [0, 45], saturation: 0.3, lightnessRange: [0.3, 0.6], texture: 'noise', hzMultiplier: [0.8, 1.5] }, ICY: { name: 'Icy', colorHueRange: [180, 240], saturation: 0.5, lightnessRange: [0.6, 0.9], texture: 'smooth', hzMultiplier: [0.8, 1.5] }, GAS_GIANT_H: { name: 'Gas Giant (H)', colorHueRange: [30, 60], saturation: 0.6, lightnessRange: [0.6, 0.8], texture: 'banded', hzMultiplier: [0.8, 1.5] }, GAS_GIANT_M: { name: 'Gas Giant (M)', colorHueRange: [200, 260], saturation: 0.7, lightnessRange: [0.4, 0.6], texture: 'swirly', hzMultiplier: [0.8, 1.5] }, BARREN: { name: 'Barren', colorHueRange: [20, 50], saturation: 0.1, lightnessRange: [0.4, 0.7], texture: 'noise', hzMultiplier: [0.8, 1.5] }, VOLCANIC: { name: 'Volcanic', colorHueRange: [-15, 20], saturation: 0.8, lightnessRange: [0.3, 0.5], texture: 'noise_heavy', hzMultiplier: [0.8, 1.5] } };
        const STAR_TYPES = { YELLOW_DWARF: { name: 'Yellow Dwarf', color: '#FFFF99', massRange: [15000, 30000], radiusFactor: 1.0, hzBaseDist: 150 }, RED_DWARF: { name: 'Red Dwarf', color: '#FF6633', massRange: [5000, 15000], radiusFactor: 0.7, hzBaseDist: 50 }, BLUE_GIANT: { name: 'Blue Giant', color: '#99CCFF', massRange: [50000, 100000], radiusFactor: 1.5, hzBaseDist: 1000 }, RED_GIANT: { name: 'Red Giant', color: '#FF9966', massRange: [30000, 60000], radiusFactor: 2.0, hzBaseDist: 800 } };
        const BODY_TYPE_DEFAULTS = { 'planet': { baseRadius: 3, density: 1.0, color: '#00FF00' }, 'star': { baseRadius: 8, density: 0.5, color: '#FFFF99' }, 'asteroid': { baseRadius: 1.5, density: 1.2, textureType: 'noise', color: '#AAAAAA' }, 'blackhole': { baseRadius: 5, density: 100.0, textureType: 'hole', color: '#444444' }, 'comet': { baseRadius: 1.0, density: 0.3, textureType: 'smooth', color: '#EEEEFF' } };

        // --- Utility Functions ---
        function screenToWorld(x, y) { return { x: (x - offsetX) / scale, y: (y - offsetY) / scale }; }
        function worldToScreen(x, y) { return { x: x * scale + offsetX, y: y * scale + offsetY }; }
        function hslColor(h, s, l) { return `hsl(${h}, ${s * 100}%, ${l * 100}%)`; }
        function randomRange(min, max) { return min + Math.random() * (max - min); }
        function generateSubtypeColor(subtype) { const hue = randomRange(subtype.colorHueRange[0], subtype.colorHueRange[1]); const lightness = randomRange(subtype.lightnessRange[0], subtype.lightnessRange[1]); const saturation = subtype.saturation; let r, g, b; const l = lightness; const s = saturation; const h = ((hue % 360) + 360) % 360 / 360; if (s === 0) { r = g = b = l; } else { const hue2rgb = (p, q, t) => { if (t < 0) t += 1; if (t > 1) t -= 1; if (t < 1/6) return p + (q - p) * 6 * t; if (t < 1/2) return q; if (t < 2/3) return p + (q - p) * (2/3 - t) * 6; return p; }; const q = l < 0.5 ? l * (1 + s) : l + s - l * s; const p = 2 * l - q; r = hue2rgb(p, q, h + 1/3); g = hue2rgb(p, q, h); b = hue2rgb(p, q, h - 1/3); } const toHex = x => { const hex = Math.round(x * 255).toString(16); return hex.length === 1 ? '0' + hex : hex; }; return `#${toHex(r)}${toHex(g)}${toHex(b)}`; }
        function generateTexture(radius, type, subtypeData, color) { const cacheKey = `${radius.toFixed(2)}-${type}-${color}-${subtypeData?.name || ''}`; if (textureCache.has(cacheKey)) return textureCache.get(cacheKey); const texCanvas = document.createElement('canvas'); const worldDiameter = Math.max(1, Math.ceil(radius * 2)); texCanvas.width = worldDiameter; texCanvas.height = worldDiameter; const texCtx = texCanvas.getContext('2d'); if (!texCtx) return null; const center = worldDiameter / 2; const r = center; try { texCtx.fillStyle = color; texCtx.beginPath(); texCtx.arc(center, center, r, 0, Math.PI * 2); texCtx.fill(); } catch(e) { console.error(`Error filling texture with color ${color}:`, e); texCtx.fillStyle = '#FF00FF'; texCtx.beginPath(); texCtx.arc(center, center, r, 0, Math.PI * 2); texCtx.fill(); } let textureStyle = BODY_TYPE_DEFAULTS[type]?.textureType; if (type === 'planet' && subtypeData?.texture) { textureStyle = subtypeData.texture; } else if (type === 'star') { textureStyle = 'solid'; } texCtx.globalAlpha = 0.3; const safeRadius = Math.max(1, r); const safeDiameter = Math.max(1, worldDiameter); switch (textureStyle) { case 'banded': texCtx.lineWidth = Math.max(1, Math.floor(safeRadius / 5)); for (let i = 0; i < 5; i++) { texCtx.strokeStyle = Math.random() > 0.5 ? 'rgba(255, 255, 255, 0.5)' : 'rgba(0, 0, 0, 0.3)'; texCtx.beginPath(); texCtx.moveTo(0, safeRadius * (0.2 + i * 0.3 + (Math.random()-0.5)*0.1)); texCtx.lineTo(safeDiameter, safeRadius * (0.2 + i * 0.3 + (Math.random()-0.5)*0.1)); texCtx.stroke(); } break; case 'swirly': for (let i = 0; i < safeDiameter * 2; i++) { texCtx.fillStyle = Math.random() > 0.5 ? 'rgba(255, 255, 255, 0.3)' : 'rgba(0, 0, 0, 0.2)'; texCtx.fillRect(Math.random() * safeDiameter, Math.random() * safeDiameter, 2, 2); } break; case 'noise': for (let i = 0; i < safeDiameter * 1.5; i++) { texCtx.fillStyle = 'rgba(0, 0, 0, 0.4)'; texCtx.fillRect(Math.random() * safeDiameter, Math.random() * safeDiameter, 1, 1); texCtx.fillStyle = 'rgba(255, 255, 255, 0.1)'; texCtx.fillRect(Math.random() * safeDiameter, Math.random() * safeDiameter, 1, 1); } break; case 'noise_heavy': for (let i = 0; i < safeDiameter * 3; i++) { texCtx.fillStyle = 'rgba(0, 0, 0, 0.6)'; texCtx.fillRect(Math.random() * safeDiameter, Math.random() * safeDiameter, Math.random() > 0.8 ? 2 : 1, Math.random() > 0.8 ? 2 : 1); } texCtx.fillStyle = 'rgba(255, 50, 0, 0.2)'; for(let i=0; i<5; i++) { texCtx.beginPath(); texCtx.arc(Math.random()*safeDiameter, Math.random()*safeDiameter, Math.random()*safeRadius*0.1 + 1, 0, Math.PI*2); texCtx.fill(); } break; case 'smooth': const gradient = texCtx.createRadialGradient(center*0.7, center*0.7, safeRadius*0.1, center, center, safeRadius); gradient.addColorStop(0, 'rgba(255, 255, 255, 0.2)'); gradient.addColorStop(1, 'rgba(255, 255, 255, 0)'); texCtx.fillStyle = gradient; texCtx.fillRect(0, 0, safeDiameter, safeDiameter); break; case 'hole': texCtx.globalAlpha = 1.0; texCtx.fillStyle = '#000000'; texCtx.beginPath(); texCtx.arc(center, center, Math.max(1, safeRadius * 0.85), 0, Math.PI * 2); texCtx.fill(); texCtx.strokeStyle = 'rgba(150, 150, 150, 0.5)'; texCtx.lineWidth = 1; texCtx.beginPath(); texCtx.arc(center, center, Math.max(1, safeRadius * 0.9), 0, Math.PI * 2); texCtx.stroke(); break; } texCtx.globalAlpha = 1.0; textureCache.set(cacheKey, texCanvas); return texCanvas; }
        function blendColors(color1, color2, ratio) { try { const hex1 = color1.startsWith('#') ? color1 : '#FFFFFF'; const hex2 = color2.startsWith('#') ? color2 : '#FFFFFF'; const c1 = parseInt(hex1.slice(1), 16); const c2 = parseInt(hex2.slice(1), 16); const r1 = (c1 >> 16) & 255, g1 = (c1 >> 8) & 255, b1 = c1 & 255; const r2 = (c2 >> 16) & 255, g2 = (c2 >> 8) & 255, b2 = c2 & 255; const r = Math.round(r1 * ratio + r2 * (1 - ratio)); const g = Math.round(g1 * ratio + g2 * (1 - ratio)); const b = Math.round(b1 * ratio + b2 * (1 - ratio)); return `#${(1 << 24 | r << 16 | g << 8 | b).toString(16).slice(1).padStart(6, '0')}`; } catch (e) { return Math.random() < ratio ? color1 : color2; } }
        function generateBackgroundStars(width, height) { backgroundStars = []; const worldWidth = width / scale; const worldHeight = height / scale; for (let i = 0; i < NUM_BACKGROUND_STARS; i++) { const x = (Math.random() - 0.5) * worldWidth * 5; const y = (Math.random() - 0.5) * worldHeight * 5; const brightness = Math.random() * 0.6 + 0.2; backgroundStars.push({ x, y, brightness }); } }
        function drawBackgroundStars(ctx) { ctx.fillStyle = '#FFFFFF'; const minSize = 0.5; const maxSize = 1.5; for (const star of backgroundStars) { const screenPos = worldToScreen(star.x, star.y); if (screenPos.x < 0 || screenPos.x > canvas.width || screenPos.y < 0 || screenPos.y > canvas.height) continue; const size = minSize + (maxSize - minSize) * star.brightness; ctx.globalAlpha = star.brightness; ctx.fillRect(Math.floor(screenPos.x), Math.floor(screenPos.y), Math.max(1, Math.floor(size)), Math.max(1, Math.floor(size))); } ctx.globalAlpha = 1.0; }

        // --- Celestial Body Class ---
        class CelestialBody {
            constructor(x, y, mass, options = {}) { /* ... (constructor unchanged) ... */ this.x = x; this.y = y; this.vx = options.vx || 0; this.vy = options.vy || 0; this.type = options.type || 'planet'; this.defaults = BODY_TYPE_DEFAULTS[this.type]; if (!this.defaults) { console.error(`Invalid body type: ${this.type}. Defaulting to planet.`); this.type = 'planet'; this.defaults = BODY_TYPE_DEFAULTS['planet']; } this.subTypeData = options.subTypeData || null; this.subTypeName = this.subTypeData?.name || null; this.baseRadiusFactor = this.defaults.baseRadius; this.density = this.defaults.density; this.radius = 0; this.updateMass(Math.max(1, mass), false); if (this.subTypeData) { if (this.type === 'planet') { this.color = generateSubtypeColor(this.subTypeData); } else if (this.type === 'star' && this.subTypeData.color) { this.color = this.subTypeData.color; } else { this.color = options.color || this.defaults.color || '#FFFFFF'; } } else { this.color = options.color || this.defaults.color || '#FFFFFF'; } this.trail = []; this.texture = generateTexture(this.radius, this.type, this.subTypeData, this.color); if (!this.texture) { this.texture = document.createElement('canvas'); this.texture.width=1; this.texture.height=1; const errCtx=this.texture.getContext('2d'); if(errCtx){errCtx.fillStyle='#FF00FF'; errCtx.fillRect(0,0,1,1);} console.error("Texture generation failed initially for:", this); } this.id = Math.random(); this.isComet = this.type === 'comet'; this.lastParticleEmitTime = 0; if (this.type === 'star' && this.subTypeData?.hzBaseDist) { const base = this.subTypeData.hzBaseDist; this.hzInner = base * 0.8; this.hzOuter = base * 1.5; } else { this.hzInner = 0; this.hzOuter = 0; } }
            updateMass(newMass, regenerateTexture = true) { /* ... (unchanged) ... */ this.mass = Math.max(1, newMass); const oldRadius = this.radius; this.radius = Math.max(0.5, Math.cbrt(this.mass / this.density) * this.baseRadiusFactor); if (regenerateTexture && Math.abs(this.radius - oldRadius) > 0.1) { this.texture = generateTexture(this.radius, this.type, this.subTypeData, this.color); if (!this.texture) { this.texture = document.createElement('canvas'); this.texture.width=1; this.texture.height=1; const errCtx=this.texture.getContext('2d'); if(errCtx){errCtx.fillStyle='#FF00FF'; errCtx.fillRect(0,0,1,1);} console.error("Texture regeneration failed for:", this); } } }
            applyForce(bodies) { /* ... (unchanged) ... */ let fx = 0; let fy = 0; for (const other of bodies) { if (other === this) continue; const dx = other.x - this.x; const dy = other.y - this.y; const distSq = dx * dx + dy * dy + SOFTENING; const dist = Math.sqrt(distSq); if (dist === 0) continue; const forceMag = (G * this.mass * other.mass) / distSq; fx += (forceMag * dx) / dist; fy += (forceMag * dy) / dist; if (other.type === 'star' && this.type !== 'star' && this.type !== 'blackhole') { const pressureForceMag = (other.mass / distSq) * 0.1; fx -= (pressureForceMag * dx) / dist; fy -= (pressureForceMag * dy) / dist; } } this.vx += (fx / this.mass) * TIME_STEP; this.vy += (fy / this.mass) * TIME_STEP; }
            updatePosition(timestamp) { /* ... (unchanged) ... */ this.x += this.vx * TIME_STEP; this.y += this.vy * TIME_STEP; if (showTrails) { this.trail.push({ x: this.x, y: this.y }); if (this.trail.length > MAX_TRAIL_LENGTH) this.trail.shift(); } else { this.trail = []; } if (this.isComet && !isPaused && timestamp - this.lastParticleEmitTime > 100) { this.emitCometParticles(); this.lastParticleEmitTime = timestamp; } }
            emitCometParticles() { /* ... (unchanged) ... */ if (particles.length >= MAX_PARTICLES) return; const speed = Math.sqrt(this.vx*this.vx + this.vy*this.vy); if (speed < 0.1) return; const numParticles = 1 + Math.floor(Math.random()*2); const baseAngle = Math.atan2(this.vy, this.vx); for (let i=0; i<numParticles; i++) { const spreadAngle = (Math.random() - 0.5) * Math.PI * 0.5; const particleAngle = baseAngle + Math.PI + spreadAngle; const particleSpeed = speed * 0.1 * (Math.random() * 0.5 + 0.5); const particleVx = Math.cos(particleAngle) * particleSpeed; const particleVy = Math.sin(particleAngle) * particleSpeed; const life = 50 + Math.random() * 50; const trailColor = generateSubtypeColor({ colorHueRange: [180, 240], saturation: 0.1, lightnessRange: [0.8, 1.0] }); if (particles.length < MAX_PARTICLES) { particles.push(new Particle(this.x, this.y, particleVx, particleVy, trailColor, life)); } } }

            // Draw method: Added Label drawing, conditional HZ/Glow
            draw(ctx) {
                 const screenPos = worldToScreen(this.x, this.y);
                 let screenRadius = this.radius * scale;
                 if (this.type === 'blackhole') screenRadius = Math.max(3, screenRadius);
                 if (isNaN(screenRadius) || screenRadius <= 0) { screenRadius = 1; }
                 const cullBuffer = Math.max(50, screenRadius * 2);
                 if (screenPos.x + cullBuffer < 0 || screenPos.x - cullBuffer > canvas.width || screenPos.y + cullBuffer < 0 || screenPos.y - cullBuffer > canvas.height) { return; }

                // --- Draw Star Glow & Habitable Zone (Conditional - NEW) ---
                if (this.type === 'star') {
                     // Draw Habitable Zone (if toggled on)
                     if (showHZ && this.hzOuter > 0) {
                         const hzInnerScreen = this.hzInner * scale;
                         const hzOuterScreen = this.hzOuter * scale;
                         if (hzOuterScreen > 2 && hzOuterScreen > hzInnerScreen) {
                              ctx.save(); ctx.beginPath(); ctx.arc(screenPos.x, screenPos.y, hzOuterScreen, 0, Math.PI * 2, false); ctx.arc(screenPos.x, screenPos.y, Math.max(0, hzInnerScreen), 0, Math.PI * 2, true); ctx.closePath(); ctx.fillStyle = 'rgba(0, 255, 0, 0.08)'; ctx.fill(); ctx.restore();
                         }
                     }
                     // Draw Glow (if toggled on)
                     if (showGlows) {
                         const glowRadius = Math.max(2, screenRadius * 1.8);
                         if (glowRadius > screenRadius) {
                              const gradient = ctx.createRadialGradient(screenPos.x, screenPos.y, screenRadius * 0.5, screenPos.x, screenPos.y, glowRadius); const baseColor = this.color || '#FFFFFF'; let r = 255, g = 255, b = 255; if (baseColor.length === 7) { try { r = parseInt(baseColor.substring(1, 3), 16); g = parseInt(baseColor.substring(3, 5), 16); b = parseInt(baseColor.substring(5, 7), 16); } catch (e) {} } gradient.addColorStop(0, `rgba(${r},${g},${b},0.5)`); gradient.addColorStop(0.7, `rgba(${r},${g},${b},0.2)`); gradient.addColorStop(1, `rgba(${r},${g},${b},0)`); ctx.fillStyle = gradient; ctx.beginPath(); ctx.arc(screenPos.x, screenPos.y, glowRadius, 0, Math.PI * 2); ctx.fill();
                         }
                     }
                }
                // --- End Star Effects ---

                // Draw trail (unchanged)
                 if (showTrails && this.trail.length > 1) { /* ... trail drawing ... */ ctx.beginPath(); const start = worldToScreen(this.trail[0].x, this.trail[0].y); ctx.moveTo(start.x, start.y); let lastScreenX = start.x, lastScreenY = start.y; for (let i = 1; i < this.trail.length; i++) { const wp = worldToScreen(this.trail[i].x, this.trail[i].y); const dxScr = wp.x - lastScreenX; const dyScr = wp.y - lastScreenY; if(dxScr*dxScr + dyScr*dyScr > 1) { ctx.lineTo(wp.x, wp.y); lastScreenX = wp.x; lastScreenY = wp.y; } } ctx.strokeStyle = (typeof this.color === 'string' && this.color.startsWith('#')) ? this.color : '#FFFFFF'; ctx.lineWidth = 1; ctx.stroke(); }

                // Draw body texture (unchanged)
                 const drawRadius = Math.max(1, screenRadius); if (this.texture && this.texture.width > 0 && this.texture.height > 0) { /* ... texture drawing ... */ try { const drawX = Math.round(screenPos.x - drawRadius); const drawY = Math.round(screenPos.y - drawRadius); const drawSize = Math.round(drawRadius * 2); if (drawSize > 0) { ctx.drawImage(this.texture, drawX, drawY, drawSize, drawSize); } else { ctx.fillStyle = this.color; ctx.fillRect(Math.floor(screenPos.x), Math.floor(screenPos.y), 1, 1); } } catch (e) { ctx.fillStyle = this.color || '#FF00FF'; ctx.beginPath(); ctx.arc(screenPos.x, screenPos.y, drawRadius, 0, Math.PI * 2); ctx.fill(); } } else { ctx.fillStyle = this.color || '#FF00FF'; if (drawRadius >= 1) { ctx.beginPath(); ctx.arc(screenPos.x, screenPos.y, drawRadius, 0, Math.PI * 2); ctx.fill(); } else { ctx.fillRect(Math.floor(screenPos.x), Math.floor(screenPos.y), 1, 1); } }

                 // Draw Label (NEW)
                 if (showLabels && drawRadius > 3) { // Only draw if large enough and toggled
                     ctx.fillStyle = '#FFFFFF';
                     ctx.font = '10px Arial';
                     ctx.textAlign = 'center';
                     ctx.textBaseline = 'top';
                     ctx.fillText(this.type, screenPos.x, screenPos.y + drawRadius + 3);
                 }

                 // Draw selection indicator AND velocity vector (unchanged)
                 if (this === selectedBody) { /* ... selection & velocity vector drawing ... */ ctx.strokeStyle = '#FFFFFF'; ctx.lineWidth = 1; const selX = Math.round(screenPos.x - drawRadius - 2); const selY = Math.round(screenPos.y - drawRadius - 2); const selSize = Math.round(drawRadius * 2 + 4); ctx.strokeRect(selX, selY, selSize, selSize); const vecScale = 5 * scale; const vxEnd = this.x + this.vx * vecScale / scale; const vyEnd = this.y + this.vy * vecScale / scale; const screenEnd = worldToScreen(vxEnd, vyEnd); ctx.beginPath(); ctx.moveTo(screenPos.x, screenPos.y); ctx.lineTo(screenEnd.x, screenEnd.y); ctx.strokeStyle = '#FFFF00'; ctx.lineWidth = 1; ctx.stroke(); const angle = Math.atan2(screenEnd.y - screenPos.y, screenEnd.x - screenPos.x); const arrowSize = 5; ctx.beginPath(); ctx.moveTo(screenEnd.x, screenEnd.y); ctx.lineTo(screenEnd.x - arrowSize * Math.cos(angle - Math.PI / 6), screenEnd.y - arrowSize * Math.sin(angle - Math.PI / 6)); ctx.moveTo(screenEnd.x, screenEnd.y); ctx.lineTo(screenEnd.x - arrowSize * Math.cos(angle + Math.PI / 6), screenEnd.y - arrowSize * Math.sin(angle + Math.PI / 6)); ctx.stroke(); }
            }
        }

        // --- Particle Class --- (unchanged)
        class Particle { constructor(x, y, vx, vy, color, lifespan) { this.x = x; this.y = y; this.vx = vx; this.vy = vy; this.color = color || '#FFFFFF'; this.life = lifespan; this.initialLife = lifespan; } update() { this.x += this.vx; this.y += this.vy; this.life--; } draw(ctx) { if (this.life > 0) { const screenPos = worldToScreen(this.x, this.y); if (screenPos.x < 0 || screenPos.x > canvas.width || screenPos.y < 0 || screenPos.y > canvas.height) { this.life = 0; return; } const alpha = Math.max(0, Math.min(1, this.life / (this.initialLife * 0.5))); ctx.globalAlpha = alpha; ctx.fillStyle = this.color; ctx.fillRect(Math.floor(screenPos.x), Math.floor(screenPos.y), 1, 1); ctx.globalAlpha = 1.0; } } isDead() { return this.life <= 0; } }
        function createExplosion(x, y, color, massRatio = 1) { const count = Math.min(80, Math.ceil(30 * Math.log10(massRatio * 10 + 1))); const baseSpeed = 2 + 3 * Math.log10(massRatio + 1); if (particles.length > MAX_PARTICLES - count) return; const validColor = (typeof color === 'string' && color.startsWith('#')) ? color : '#FFFFFF'; for (let i = 0; i < count; i++) { const angle = Math.random() * Math.PI * 2; const speed = baseSpeed * (Math.random() * 0.7 + 0.6); const vx = Math.cos(angle) * speed; const vy = Math.sin(angle) * speed; const life = 40 + Math.random() * 50; if (particles.length < MAX_PARTICLES) { particles.push(new Particle(x, y, vx, vy, validColor, life)); } else break; } }

        // --- Collision Detection & Handling --- (unchanged)
        function handleCollisions() { let merged = false; const bodiesToRemove = new Set(); const bodiesToAdd = []; for (let i = 0; i < bodies.length; i++) { const p1 = bodies[i]; if (bodiesToRemove.has(p1.id)) continue; for (let j = i + 1; j < bodies.length; j++) { const p2 = bodies[j]; if (bodiesToRemove.has(p2.id)) continue; const dx = p2.x - p1.x; const dy = p2.y - p1.y; const distSq = dx * dx + dy * dy; const combinedRadius = p1.radius + p2.radius; if (distSq < combinedRadius * combinedRadius * 0.9) { let mergedBody; let lighter; let heavier; if (p1.type === 'blackhole' || p2.type === 'blackhole') { heavier = p1.type === 'blackhole' ? p1 : p2; lighter = p1.type === 'blackhole' ? p2 : p1; const totalMass = heavier.mass + lighter.mass; const newVx = (heavier.vx * heavier.mass + lighter.vx * lighter.mass) / totalMass; const newVy = (heavier.vy * heavier.mass + lighter.vy * lighter.mass) / totalMass; const newX = (heavier.x * heavier.mass + lighter.x * lighter.mass) / totalMass; const newY = (heavier.y * heavier.mass + lighter.y * lighter.mass) / totalMass; mergedBody = new CelestialBody(newX, newY, totalMass, { type: 'blackhole', vx: newVx, vy: newVy, color: BODY_TYPE_DEFAULTS['blackhole'].color }); createExplosion(newX, newY, '#AAAAFF', lighter.mass / heavier.mass); } else { heavier = p1.mass >= p2.mass ? p1 : p2; lighter = p1.mass < p2.mass ? p1 : p2; const totalMass = p1.mass + p2.mass; const newVx = (p1.vx * p1.mass + p2.vx * p2.mass) / totalMass; const newVy = (p1.vy * p1.mass + p2.vy * p2.mass) / totalMass; const newX = (p1.x * p1.mass + p2.x * p2.mass) / totalMass; const newY = (p1.y * p1.mass + p2.y * p2.mass) / totalMass; const newType = heavier.type; const newSubTypeData = heavier.subTypeData; const newColor = blendColors(p1.color, p2.color, p1.mass / totalMass); mergedBody = new CelestialBody(newX, newY, totalMass, { type: newType, vx: newVx, vy: newVy, subTypeData: newSubTypeData, color: newColor }); createExplosion(newX, newY, mergedBody.color, lighter.mass / heavier.mass); } bodiesToAdd.push(mergedBody); bodiesToRemove.add(p1.id); bodiesToRemove.add(p2.id); if (selectedBody === p1 || selectedBody === p2) { selectedBody = mergedBody; } merged = true; } } } if (merged) { bodies = bodies.filter(b => !bodiesToRemove.has(b.id)); bodies.push(...bodiesToAdd); if (selectedBody && bodiesToRemove.has(selectedBody.id)) { selectedBody = bodiesToAdd.length > 0 ? bodiesToAdd[0] : null; selectedBodyAttractor = null; selectedBodyOrbitalParams = null; updateSelectedInfo(); } } }

        // --- Energy Calculation --- (unchanged)
        function calculateEnergy() { let kinetic = 0; let potential = 0; for (let i = 0; i < bodies.length; i++) { const p1 = bodies[i]; kinetic += 0.5 * p1.mass * (p1.vx * p1.vx + p1.vy * p1.vy); for (let j = i + 1; j < bodies.length; j++) { const p2 = bodies[j]; const dx = p2.x - p1.x; const dy = p2.y - p1.y; const dist = Math.sqrt(dx * dx + dy * dy + SOFTENING); if(dist > 0) { potential -= (G * p1.mass * p2.mass) / dist; } } } kinetic = isFinite(kinetic) ? kinetic : 0; potential = isFinite(potential) ? potential : 0; return { kinetic, potential, total: kinetic + potential }; }

        // --- Find Attractor Function --- (unchanged)
        function findPrimaryAttractor(body) { if (!body || !bodies || bodies.length < 2) return null; let attractor = null; let maxInfluence = -1; for (const potentialAttractor of bodies) { if (potentialAttractor === body) continue; if (potentialAttractor.mass < body.mass && bodies.length > 2 && potentialAttractor.type !== 'star' && potentialAttractor.type !== 'blackhole') continue; const dx = potentialAttractor.x - body.x; const dy = potentialAttractor.y - body.y; const distSq = dx * dx + dy * dy; let influence = potentialAttractor.mass / (distSq + SOFTENING); if (influence > maxInfluence) { maxInfluence = influence; attractor = potentialAttractor; } } return attractor; }

        // --- Orbital Parameter Calculation --- (unchanged)
        function calculateOrbitalParameters(body) { selectedBodyAttractor = findPrimaryAttractor(body); const attractor = selectedBodyAttractor; if (!body || !attractor || body.type === 'star' || body.type === 'blackhole') { selectedBodyOrbitalParams = null; return null; } const r_vec = { x: body.x - attractor.x, y: body.y - attractor.y }; const v_vec = { x: body.vx - attractor.vx, y: body.vy - attractor.vy }; const r = Math.sqrt(r_vec.x * r_vec.x + r_vec.y * r_vec.y); const v = Math.sqrt(v_vec.x * v_vec.x + v_vec.y * v_vec.y); if (r === 0) { selectedBodyOrbitalParams = null; return { attractorName: attractor.type, status: "Inside attractor?" }; } const mu = G * (attractor.mass + body.mass); if (mu === 0 || !isFinite(mu)) { selectedBodyOrbitalParams = null; return { attractorName: attractor.type, status: "No gravity (G=0)", periapsis: "N/A", apoapsis: "N/A", energy: "N/A", eccentricity: "N/A" }; } const E = (v * v / 2) - (mu / r); const h_vec = { x: 0, y: 0, z: r_vec.x * v_vec.y - r_vec.y * v_vec.x }; const h = Math.abs(h_vec.z); if (h < 1e-6 * mu) { selectedBodyOrbitalParams = null; return { attractorName: attractor.type, status: "Radial trajectory?", periapsis: "N/A", apoapsis: "N/A", energy: E.toExponential(2), eccentricity: "N/A" }; } const vxh = { x: -v_vec.y * h_vec.z, y: v_vec.x * h_vec.z }; const e_vec = { x: vxh.x / mu - r_vec.x / r, y: vxh.y / mu - r_vec.y / r }; const e = Math.sqrt(e_vec.x * e_vec.x + e_vec.y * e_vec.y); let status = "Orbiting"; let periapsis = NaN, apoapsis = NaN, semiMajorAxis = NaN, argumentOfPeriapsis = NaN; if (e >= 1 - 1e-9) { status = (Math.abs(e - 1) < 1e-6) ? "Parabolic" : "Hyperbolic / Escape"; periapsis = (h * h / mu) / (1 + e); } else { semiMajorAxis = (h * h / mu) / (1 - e * e); periapsis = semiMajorAxis * (1 - e); apoapsis = semiMajorAxis * (1 + e); status = (e < 0.01) ? "Near Circular" : "Elliptical"; argumentOfPeriapsis = Math.atan2(e_vec.y, e_vec.x); } selectedBodyOrbitalParams = { attractor: attractor, semiMajorAxis: semiMajorAxis, eccentricity: e, argOfPeriapsis: argumentOfPeriapsis, isBound: e < 1 }; return { attractorName: `${attractor.type} (${attractor.mass.toFixed(0)})`, status: status, periapsis: isFinite(periapsis) ? periapsis.toFixed(0) : "N/A", apoapsis: isFinite(apoapsis) ? apoapsis.toFixed(0) : "N/A", energy: E.toExponential(2), eccentricity: e.toFixed(3) }; }

        // --- Draw Predicted Orbit & COM Marker --- (Draws COM marker on top now)
        function drawPredictedOrbit(ctx) {
             if (!selectedBody || !selectedBodyAttractor || !selectedBodyOrbitalParams) { return; } // Check if params exist

             // Draw Orbit Line (if toggled and bound)
             if (showOrbit && selectedBodyOrbitalParams.isBound) {
                 const params = selectedBodyOrbitalParams; const attractor = params.attractor; const a = params.semiMajorAxis; const e = params.eccentricity; const omega = params.argOfPeriapsis;
                 if (!isFinite(a) || !isFinite(e) || !isFinite(omega) || a <= 0) return;
                 const b = a * Math.sqrt(1 - e * e); const focusOffset = a * e;
                 const centerOffsetX = -focusOffset * Math.cos(omega); const centerOffsetY = -focusOffset * Math.sin(omega);
                 const ellipseCenterX = attractor.x + centerOffsetX; const ellipseCenterY = attractor.y + centerOffsetY;
                 const screenCenter = worldToScreen(ellipseCenterX, ellipseCenterY);
                 ctx.beginPath(); ctx.ellipse( screenCenter.x, screenCenter.y, a * scale, b * scale, omega, 0, 2 * Math.PI ); ctx.strokeStyle = 'rgba(100, 100, 255, 0.6)'; ctx.lineWidth = 1; ctx.stroke();
             }

             // Draw COM Marker (if orbit is shown)
             if (showOrbit) { // Only show COM if orbit is shown? Or always if selected? Let's tie to orbit.
                 const attractor = selectedBodyAttractor;
                 const totalMass = selectedBody.mass + attractor.mass;
                 if (totalMass > 0) {
                     const comX = (selectedBody.x * selectedBody.mass + attractor.x * attractor.mass) / totalMass;
                     const comY = (selectedBody.y * selectedBody.mass + attractor.y * attractor.mass) / totalMass;
                     const screenCOM = worldToScreen(comX, comY);
                     ctx.beginPath(); ctx.moveTo(screenCOM.x - 3, screenCOM.y - 3); ctx.lineTo(screenCOM.x + 3, screenCOM.y + 3); ctx.moveTo(screenCOM.x + 3, screenCOM.y - 3); ctx.lineTo(screenCOM.x - 3, screenCOM.y + 3); ctx.strokeStyle = 'rgba(255, 0, 255, 0.8)'; ctx.lineWidth = 1; ctx.stroke();
                 }
             }
        }


        // --- Update UI ---
        let infoUpdateCounter = 0;
        const INFO_UPDATE_INTERVAL = 10;
        function updateSimInfo() { /* ... (unchanged) ... */ const energy = calculateEnergy(); document.getElementById('bodyCount').innerText = `Bodies: ${bodies.length}`; document.getElementById('kinetic').innerText = `Kinetic E: ${energy.kinetic.toExponential(2)}`; document.getElementById('potential').innerText = `Potential E: ${energy.potential.toExponential(2)}`; document.getElementById('total').innerText = `Total E: ${energy.total.toExponential(2)}`; document.getElementById('simTime').innerText = `Sim Time: ${simulationTime.toFixed(1)} s`; }

        // --- UPDATED Selected Info Panel (Includes Edit Velocity) ---
        function updateSelectedInfo() {
            const detailsDiv = document.getElementById('selectedDetails');
            const followBtn = document.getElementById('followBody');
            const deleteBtn = document.getElementById('deleteBody');
            const orbitBtn = document.getElementById('toggleOrbit');
            const pushBtn = document.getElementById('pushBody'); // Get push button

            // Remove previous edit listeners
            const oldInputs = detailsDiv.querySelectorAll('input[type="number"]');
            oldInputs.forEach(input => {
                input.removeEventListener('change', handleValueEdit);
                input.removeEventListener('keydown', handleValueEditEnter);
            });

            if (selectedBody) {
                 followBtn.disabled = false; deleteBtn.disabled = false; orbitBtn.disabled = false; pushBtn.disabled = false; // Enable push button

                 const type = selectedBody.type || 'N/A'; const subtypeName = selectedBody.subTypeName || (selectedBody.type === 'star' && selectedBody.subTypeData ? selectedBody.subTypeData.name : null); const subtypeInfo = subtypeName ? `Subtype: ${subtypeName}<br>` : ''; const id = selectedBody.id?.toFixed(5) || 'N/A'; const mass = selectedBody.mass?.toFixed(1) || 'N/A'; const radius = selectedBody.radius?.toFixed(1) || 'N/A'; const vx = selectedBody.vx?.toFixed(2) || 'N/A'; const vy = selectedBody.vy?.toFixed(2) || 'N/A'; const x = selectedBody.x?.toFixed(0) || 'N/A'; const y = selectedBody.y?.toFixed(0) || 'N/A';

                 // Edit Fields (NEW: Added vx, vy)
                 const massEditHtml = `<label class="edit-label">Mass:</label> <input type="number" data-prop="mass" id="selectedMassInput" value="${mass}" min="1" step="any" title="Edit Mass (Enter to apply)"><br>`;
                 const vxEditHtml = `<label class="edit-label">Vel X:</label> <input type="number" data-prop="vx" id="selectedVxInput" value="${vx}" step="any" title="Edit Vx (Enter to apply)"><br>`;
                 const vyEditHtml = `<label class="edit-label">Vel Y:</label> <input type="number" data-prop="vy" id="selectedVyInput" value="${vy}" step="any" title="Edit Vy (Enter to apply)"><br>`;

                 // Orbital Info (unchanged logic)
                 let orbitalInfoHtml = ""; const orbitalParams = calculateOrbitalParameters(selectedBody); if (orbitalParams) { orbitalInfoHtml = `<br>--- Orbit Info ---<br>Attractor: ${orbitalParams.attractorName}<br>Status: ${orbitalParams.status}<br>Periapsis: ${orbitalParams.periapsis}<br>Apoapsis: ${orbitalParams.apoapsis}<br>Ecc: ${orbitalParams.eccentricity}<br>Energy: ${orbitalParams.energy}`; } else { selectedBodyAttractor = null; selectedBodyOrbitalParams = null; }

                 detailsDiv.innerHTML = `ID: ${id}<br>Type: ${type}<br>${subtypeInfo}${massEditHtml}${vxEditHtml}${vyEditHtml}Radius: ${radius}<br>Pos X: ${x}<br>Pos Y: ${y}${orbitalInfoHtml}`;

                 // Add listeners for new edit fields
                 detailsDiv.querySelectorAll('input[type="number"]').forEach(input => {
                     input.addEventListener('change', handleValueEdit);
                     input.addEventListener('keydown', handleValueEditEnter);
                 });

            } else { // No body selected
                detailsDiv.innerText = 'Click a body to select';
                followBtn.disabled = true; deleteBtn.disabled = true; orbitBtn.disabled = true; pushBtn.disabled = true; // Disable push button
                selectedBodyAttractor = null; selectedBodyOrbitalParams = null;
                if (isFollowing) { isFollowing = false; followedBody = null; }
                if (pushMode) { pushMode = false; document.getElementById('pushBody').classList.remove('active'); document.getElementById('pushBody').textContent = 'Push Mode'; } // Turn off push mode if body deselected
            }
             // Update button states
             followBtn.textContent = (isFollowing && selectedBody === followedBody) ? 'Unfollow' : 'Follow';
             followBtn.classList.toggle('active', isFollowing && selectedBody === followedBody);
             orbitBtn.textContent = showOrbit ? 'Orbit ON' : 'Orbit OFF';
             orbitBtn.classList.toggle('active', showOrbit);
             orbitBtn.disabled = !selectedBody;
             // Update push button state separately
             pushBtn.disabled = !selectedBody;
             pushBtn.classList.toggle('active', pushMode);
             pushBtn.textContent = pushMode ? 'Push Mode ON' : 'Push Mode';
        }

        // --- Handlers for Value Edit (Mass, Vx, Vy) --- (NEW Generic Handlers)
        function handleValueEdit(event) {
             if (selectedBody) {
                 const property = event.target.dataset.prop; // Get property name (mass, vx, vy)
                 const value = parseFloat(event.target.value);
                 const isMass = property === 'mass';

                 if (!isNaN(value) && (!isMass || value > 0)) { // Mass must be > 0
                     if (isMass) {
                          selectedBody.updateMass(value); // Use dedicated method for mass
                     } else {
                          selectedBody[property] = value; // Directly set vx or vy
                     }
                     // Recalculate orbital params if velocity changed
                     if (property === 'vx' || property === 'vy') {
                         calculateOrbitalParameters(selectedBody); // Recalculate
                     }
                     updateSelectedInfo(); // Update the display immediately
                 } else {
                     // Reset input to current value if invalid
                     event.target.value = isMass ? selectedBody.mass.toFixed(1) : selectedBody[property].toFixed(2);
                 }
             }
        }
        function handleValueEditEnter(event) {
             if (event.key === 'Enter') {
                 handleValueEdit(event);
                 event.target.blur(); // Remove focus after Enter
             }
        }


        // --- Simulation Loop ---
        let lastTimestamp = 0;
        function animate(timestamp) {
            const frameDuration = (timestamp - lastTimestamp) || (1000 / 60); lastTimestamp = timestamp;
            if (canvas.width <= 0 || canvas.height <= 0) { requestAnimationFrame(animate); return; }
            // Follow Logic (unchanged)
            if (isFollowing && followedBody) { if (!bodies.includes(followedBody)) { isFollowing = false; followedBody = null; updateSelectedInfo(); } else { const targetScreenX = canvas.width / 2; const targetScreenY = canvas.height / 2; const currentScreenPos = worldToScreen(followedBody.x, followedBody.y); const dxOffset = targetScreenX - currentScreenPos.x; const dyOffset = targetScreenY - currentScreenPos.y; offsetX += dxOffset; offsetY += dyOffset; } }
            // Physics Update
            if (!isPaused) {
                simulationTime += (frameDuration / 1000) * TIME_STEP;
                for (const body of bodies) { body.applyForce(bodies); }
                for (const body of bodies) { body.updatePosition(timestamp); }
                handleCollisions();
                for (let i = particles.length - 1; i >= 0; i--) { particles[i].update(); if (particles[i].isDead()) particles.splice(i, 1); }
            }
            // --- Drawing ---
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawBackgroundStars(ctx);
            for (const particle of particles) { particle.draw(ctx); }
            drawPredictedOrbit(ctx); // Draw orbit & COM before bodies
            for (const body of bodies) { body.draw(ctx); } // Includes labels now

            // Draw velocity indicator line for adding body (unchanged)
             if (isCreatingBody && creationStartPos && tempBody) { ctx.beginPath(); const screenStart = worldToScreen(tempBody.x, tempBody.y); ctx.moveTo(screenStart.x, screenStart.y); const screenEnd = {x: currentMousePos.x, y: currentMousePos.y }; ctx.lineTo(screenEnd.x, screenEnd.y); ctx.strokeStyle = '#FFFF00'; ctx.lineWidth = 1; ctx.stroke(); if (tempBody.texture && tempBody.texture.width > 0) { tempBody.draw(ctx); } }

            // Draw Impulse line for Push mode (NEW)
            if (isPushingBody && pushBody && pushStartPos) {
                 const screenStart = worldToScreen(pushBody.x, pushBody.y);
                 ctx.beginPath();
                 ctx.moveTo(screenStart.x, screenStart.y);
                 ctx.lineTo(currentMousePos.x, currentMousePos.y);
                 ctx.strokeStyle = '#FF00FF'; // Magenta impulse line
                 ctx.lineWidth = 2;
                 ctx.setLineDash([5, 5]); // Dashed line
                 ctx.stroke();
                 ctx.setLineDash([]); // Reset line dash
            }

            // Update Info Panels
            infoUpdateCounter++;
            if (infoUpdateCounter >= INFO_UPDATE_INTERVAL) { if (!isPaused) updateSimInfo(); updateSelectedInfo(); infoUpdateCounter = 0; }

            requestAnimationFrame(animate);
        }

        // --- Event Listeners ---
        // (Get existing elements)
        const playPauseBtn = document.getElementById('playPause'); const speedControl = document.getElementById('speedControl'); const speedValueSpan = document.getElementById('speedValue'); const gravityControl = document.getElementById('gravityControl'); const gravityValueSpan = document.getElementById('gravityValue'); const toggleTrailsBtn = document.getElementById('toggleTrails'); const toggleOrbitBtn = document.getElementById('toggleOrbit'); const resetViewBtn = document.getElementById('resetView'); const addBodyBtn = document.getElementById('addBody'); const clearBodiesBtn = document.getElementById('clearBodies'); const bodyTypeSelect = document.getElementById('bodyType'); const massInput = document.getElementById('mass'); const colorInput = document.getElementById('color'); const regenSystemBtn = document.getElementById('regenSystem'); const followBodyBtn = document.getElementById('followBody'); const deleteBodyBtn = document.getElementById('deleteBody'); const loadSolarSystemBtn = document.getElementById('loadSolarSystem');
        // NEW Elements
        const pushBodyBtn = document.getElementById('pushBody');
        const toggleLabelsBtn = document.getElementById('toggleLabels');
        const toggleHZBtn = document.getElementById('toggleHZ');
        const toggleGlowsBtn = document.getElementById('toggleGlows');
        const loadGalaxyBtn = document.getElementById('loadGalaxy');

        // --- Toolbar Controls ---
        playPauseBtn.addEventListener('click', () => { isPaused = !isPaused; playPauseBtn.textContent = isPaused ? 'Resume' : 'Pause'; if (!isPaused) { lastTimestamp = performance.now(); updateSimInfo(); } });
        speedControl.addEventListener('input', () => { TIME_STEP = parseFloat(speedControl.value); speedValueSpan.textContent = `${TIME_STEP.toFixed(1)}x`; });
        gravityControl.addEventListener('input', () => { G = parseFloat(gravityControl.value); gravityValueSpan.textContent = `${G.toFixed(1)}`; selectedBodyOrbitalParams = null; updateSelectedInfo(); });
        // Toggle Button Handlers
        function setupToggleButton(buttonId, stateVariable, onText, offText, callback) {
            const button = document.getElementById(buttonId);
            button.addEventListener('click', () => {
                 window[stateVariable] = !window[stateVariable]; // Use window scope for global state vars
                 button.textContent = window[stateVariable] ? onText : offText;
                 button.classList.toggle('active', window[stateVariable]);
                 if (callback) callback(window[stateVariable]); // Optional callback
            });
             // Initial state
             button.textContent = window[stateVariable] ? onText : offText;
             button.classList.toggle('active', window[stateVariable]);
        }
        setupToggleButton('toggleTrails', 'showTrails', 'Trails ON', 'Trails OFF', (state) => { if (!state) bodies.forEach(b => b.trail = []); });
        setupToggleButton('toggleOrbit', 'showOrbit', 'Orbit ON', 'Orbit OFF');
        setupToggleButton('toggleLabels', 'showLabels', 'Labels ON', 'Labels OFF'); // NEW
        setupToggleButton('toggleHZ', 'showHZ', 'HZ ON', 'HZ OFF'); // NEW
        setupToggleButton('toggleGlows', 'showGlows', 'Glows ON', 'Glows OFF'); // NEW

        resetViewBtn.addEventListener('click', () => { scale = 0.5; offsetX = canvas.width / 2; offsetY = canvas.height / 2; isFollowing = false; followedBody = null; updateSelectedInfo(); });

        // Mode Toggles (Add, Push)
        addBodyBtn.addEventListener('click', () => {
             addMode = !addMode;
             pushMode = false; // Turn off other modes
             addBodyBtn.classList.toggle('active', addMode);
             pushBodyBtn.classList.remove('active');
             canvas.style.cursor = addMode ? 'copy' : 'crosshair';
             isCreatingBody = false; tempBody = null;
             updateSelectedInfo(); // Update push button state etc.
        });
        pushBodyBtn.addEventListener('click', () => {
             if (!selectedBody) return; // Can only enter push mode if a body is selected
             pushMode = !pushMode;
             addMode = false; // Turn off other modes
             pushBodyBtn.classList.toggle('active', pushMode);
             addBodyBtn.classList.remove('active');
             canvas.style.cursor = pushMode ? 'pointer' : 'crosshair'; // Use pointer for push
             isPushingBody = false; pushStartPos = null; pushBody = null;
             updateSelectedInfo(); // Update add button state etc.
        });

        // --- Simulation Management Buttons ---
        function clearSimulation() { bodies = []; particles.length = 0; selectedBody = null; selectedBodyAttractor = null; selectedBodyOrbitalParams = null; simulationTime = 0; isFollowing = false; followedBody = null; pushMode = false; addMode = false; textureCache.clear(); updateSimInfo(); updateSelectedInfo(); }
        clearBodiesBtn.addEventListener('click', clearSimulation);
        function setupAndRun(generationFunc) { isPaused = true; playPauseBtn.textContent = 'Resume'; clearSimulation(); requestAnimationFrame(() => { generationFunc(); offsetX = canvas.width / 2; offsetY = canvas.height / 2; scale = 0.5; isPaused = false; playPauseBtn.textContent = 'Pause'; updateSimInfo(); updateSelectedInfo(); }); }
        regenSystemBtn.addEventListener('click', () => setupAndRun(generateInitialSystem));
        loadSolarSystemBtn.addEventListener('click', () => setupAndRun(loadSolarSystemPreset));
        loadGalaxyBtn.addEventListener('click', () => setupAndRun(generateGalaxyPreset)); // NEW

        // --- Button Listeners (Follow, Delete - unchanged) ---
        followBodyBtn.addEventListener('click', () => { if (selectedBody) { if (isFollowing && followedBody === selectedBody) { isFollowing = false; followedBody = null; } else { isFollowing = true; followedBody = selectedBody; isPanning = false; canvas.style.cursor = 'crosshair'; } updateSelectedInfo(); } });
        deleteBodyBtn.addEventListener('click', () => { if (selectedBody) { const index = bodies.indexOf(selectedBody); if (index > -1) { bodies.splice(index, 1); if (isFollowing && followedBody === selectedBody) { isFollowing = false; followedBody = null; } selectedBody = null; selectedBodyAttractor = null; selectedBodyOrbitalParams = null; updateSimInfo(); updateSelectedInfo(); } } });

        // --- Mouse Interaction (UPDATED for Push Mode) ---
        canvas.addEventListener('mousedown', (e) => {
            currentMousePos = {x: e.clientX, y: e.clientY};
            const worldPos = screenToWorld(e.clientX, e.clientY);

            if (e.button === 0) { // Left Click
                 if (addMode) { // --- Add Mode ---
                     isCreatingBody = true; creationStartPos = { x: e.clientX, y: e.clientY }; const type = bodyTypeSelect.value; const mass = parseFloat(massInput.value) || 100; const color = colorInput.value; tempBody = new CelestialBody(worldPos.x, worldPos.y, mass, { type: type, color: color });
                 } else if (pushMode && selectedBody) { // --- Push Mode ---
                     // Check if click is ON the selected body
                     const bodyScreenPos = worldToScreen(selectedBody.x, selectedBody.y);
                     const screenRadius = selectedBody.radius * scale;
                     const dxClick = e.clientX - bodyScreenPos.x;
                     const dyClick = e.clientY - bodyScreenPos.y;
                     if (dxClick * dxClick + dyClick * dyClick <= screenRadius * screenRadius) {
                         isPushingBody = true;
                         pushBody = selectedBody;
                         pushStartPos = { x: e.clientX, y: e.clientY };
                         canvas.style.cursor = 'grabbing';
                     } else {
                         // Clicked elsewhere, maybe deselect or select another? For now, just do nothing if not on body.
                     }
                 } else { // --- Select Mode ---
                     if (isFollowing) { isFollowing = false; followedBody = null; } // Stop following on click
                     let clickedBody = null; let minDistSq = Infinity;
                     for (const body of bodies) { const dxBody = body.x - worldPos.x; const dyBody = body.y - worldPos.y; const distSqBody = dxBody * dxBody + dyBody * dyBody; const clickableRadiusSq = Math.max(body.radius * body.radius, (5 / scale) * (5/scale)); if (distSqBody < clickableRadiusSq && distSqBody < minDistSq) { clickedBody = body; minDistSq = distSqBody; } }
                     selectedBody = clickedBody;
                     // If switching out of push mode because selection changed, update button state
                     if (pushMode && selectedBody !== pushBody) {
                         pushMode = false;
                         isPushingBody = false;
                         pushBody = null;
                         pushStartPos = null;
                     }
                     updateSelectedInfo(); // Update immediately on click
                 }
            } else if (e.button === 2) { // Right Click Panning
                if (!isFollowing) { isPanning = true; panStart = { x: e.clientX, y: e.clientY }; canvas.style.cursor = 'grabbing'; e.preventDefault(); } else { e.preventDefault(); }
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            currentMousePos = {x: e.clientX, y: e.clientY};
            if (isPanning) { const dx = e.clientX - panStart.x; const dy = e.clientY - panStart.y; offsetX += dx; offsetY += dy; panStart = { x: e.clientX, y: e.clientY }; }
            else if (isPushingBody) {
                 // Just track mouse for drawing the line in animate()
            }
        });

        canvas.addEventListener('mouseup', (e) => {
             if (e.button === 0) { // Left Click up
                 if (isCreatingBody && tempBody) { // Finish Adding Body
                     const endPos = { x: e.clientX, y: e.clientY }; const dxPixels = endPos.x - creationStartPos.x; const dyPixels = endPos.y - creationStartPos.y; if (dxPixels * dxPixels + dyPixels * dyPixels > 5 * 5) { const velocityScale = 0.03 / scale; tempBody.vx = dxPixels * velocityScale; tempBody.vy = dyPixels * velocityScale; } else { tempBody.vx = 0; tempBody.vy = 0; } bodies.push(tempBody); updateSimInfo(); isCreatingBody = false; tempBody = null; creationStartPos = null; canvas.style.cursor = 'copy'; // Keep Add Mode active
                 } else if (isPushingBody && pushBody) { // Finish Pushing Body
                      const endPos = { x: e.clientX, y: e.clientY };
                      const dxPixels = endPos.x - pushStartPos.x;
                      const dyPixels = endPos.y - pushStartPos.y;
                      const impulseScale = 0.005; // Adjust sensitivity of push
                      const deltaVx = dxPixels * impulseScale / scale;
                      const deltaVy = dyPixels * impulseScale / scale;

                      pushBody.vx += deltaVx;
                      pushBody.vy += deltaVy;

                      console.log(`Applied impulse: dVx=${deltaVx.toFixed(2)}, dVy=${deltaVy.toFixed(2)} to body ${pushBody.type}`);
                      calculateOrbitalParameters(pushBody); // Recalculate orbit after push
                      updateSelectedInfo(); // Update velocity display

                      isPushingBody = false; pushStartPos = null; pushBody = null;
                      canvas.style.cursor = pushMode ? 'pointer' : 'crosshair'; // Reset cursor for push mode
                 }
             } else if (e.button === 2) { // Right Click up
                if (isPanning) { isPanning = false; canvas.style.cursor = addMode ? 'copy' : (pushMode ? 'pointer' : 'crosshair'); }
             }
             // Reset push state if mouseup occurs even if not pushing (safety)
             if (isPushingBody) { isPushingBody = false; pushStartPos = null; pushBody = null; canvas.style.cursor = pushMode ? 'pointer' : 'crosshair'; }
        });

        canvas.addEventListener('wheel', (e) => { e.preventDefault(); const zoomIntensity = 0.1; const wheel = e.deltaY < 0 ? 1 : -1; const zoom = Math.exp(wheel * zoomIntensity); const mouseWorldPos = screenToWorld(e.clientX, e.clientY); const newScale = scale * zoom; scale = Math.max(0.001, Math.min(newScale, 50)); offsetX = e.clientX - mouseWorldPos.x * scale; offsetY = e.clientY - mouseWorldPos.y * scale; });
        canvas.addEventListener('mouseleave', () => { if (isPanning) { isPanning = false; canvas.style.cursor = addMode ? 'copy' : (pushMode ? 'pointer' : 'crosshair'); } if (isCreatingBody) { isCreatingBody = false; tempBody = null; creationStartPos = null; canvas.style.cursor = addMode ? 'copy' : 'crosshair'; } if (isPushingBody) { isPushingBody = false; pushStartPos = null; pushBody = null; canvas.style.cursor = pushMode ? 'pointer' : 'crosshair'; } });
        canvas.addEventListener('contextmenu', (e) => e.preventDefault());

        // --- Procedural System Generation --- (Unchanged)
        function generateInitialSystem() { console.log("Generating random system..."); bodies = []; const numStars = Math.random() < 0.1 ? 2 : 1; const centralObjects = []; let totalCentralMass = 0; for (let i = 0; i < numStars; i++) { const starTypeKeys = Object.keys(STAR_TYPES); const randomStarKey = starTypeKeys[Math.floor(Math.random() * starTypeKeys.length)]; const starData = STAR_TYPES[randomStarKey]; const mass = randomRange(starData.massRange[0], starData.massRange[1]); totalCentralMass += mass; let starX = 0, starY = 0, starVx = 0, starVy = 0; if (numStars === 2) { const separation = 800 + Math.random() * 800; const angle = i * Math.PI; starX = separation / 2 * Math.cos(angle); starY = separation / 2 * Math.sin(angle); } const star = new CelestialBody(starX, starY, mass, { type: 'star', vx: starVx, vy: starVy, subTypeData: starData }); bodies.push(star); centralObjects.push(star); } if (numStars === 2 && centralObjects.length === 2 && totalCentralMass > 0) { const star1 = centralObjects[0]; const star2 = centralObjects[1]; const dx = star2.x - star1.x; const dy = star2.y - star1.y; const dist = Math.sqrt(dx*dx + dy*dy); if (dist > 0) { const vOrbit = Math.sqrt(G * totalCentralMass / dist); const v1 = vOrbit * (star2.mass / totalCentralMass); const v2 = vOrbit * (star1.mass / totalCentralMass); star1.vx = v1 * (dy / dist); star1.vy = -v1 * (dx / dist); star2.vx = -v2 * (dy / dist); star2.vy = v2 * (dx / dist); } } const primaryStar = centralObjects[0]; const numPlanets = 5 + Math.floor(Math.random() * 6); let lastDist = (primaryStar.radius * 2) + 400 + Math.random() * 300; let comX = 0, comY = 0; if(numStars > 1 && totalCentralMass > 0){ comX = centralObjects.reduce((sum, obj) => sum + obj.x * obj.mass, 0) / totalCentralMass; comY = centralObjects.reduce((sum, obj) => sum + obj.y * obj.mass, 0) / totalCentralMass; } else { comX = primaryStar.x; comY = primaryStar.y; } const avgVx = centralObjects.reduce((sum, obj) => sum + obj.vx, 0) / numStars; const avgVy = centralObjects.reduce((sum, obj) => sum + obj.vy, 0) / numStars; const massCenter = { x: comX, y: comY }; for (let i = 0; i < numPlanets; i++) { const dist = lastDist + (300 + Math.random() * 500) * (1 + i*0.1); lastDist = dist; const angle = Math.random() * Math.PI * 2; const x = massCenter.x + dist * Math.cos(angle); const y = massCenter.y + dist * Math.sin(angle); const planetSubtypeKeys = Object.keys(PLANET_SUBTYPES); const randomPlanetKey = planetSubtypeKeys[Math.floor(Math.random() * planetSubtypeKeys.length)]; const planetData = PLANET_SUBTYPES[randomPlanetKey]; let mass = randomRange(20, 100); if (planetData.name.includes('Gas Giant')) mass = randomRange(100, 500); else if (planetData.name === 'Icy') mass = randomRange(10, 50); const planetOptions = { type: 'planet', subTypeData: planetData }; const planet = new CelestialBody(x, y, mass, planetOptions); const dx_orb = x - massCenter.x; const dy_orb = y - massCenter.y; const dist_orb_sq = dx_orb*dx_orb + dy_orb*dy_orb; if (dist_orb_sq > 100) { const dist_orb = Math.sqrt(dist_orb_sq); const orbitalSpeed = Math.sqrt((G * totalCentralMass) / dist_orb); const eccentricityFactor = 1.0 + (Math.random() - 0.4) * 0.2; planet.vx = avgVx - orbitalSpeed * (dy_orb / dist_orb) * eccentricityFactor; planet.vy = avgVy + orbitalSpeed * (dx_orb / dist_orb) * eccentricityFactor; } else { planet.vx = avgVx; planet.vy = avgVy; } bodies.push(planet); if (planet.mass > 50 && Math.random() < 0.3) { const numMoons = 1 + Math.floor(Math.random() * 2); for (let m = 0; m < numMoons; m++) { const moonDist = planet.radius * (3 + Math.random() * 5); const moonAngle = Math.random() * Math.PI * 2; const moonX = planet.x + moonDist * Math.cos(moonAngle); const moonY = planet.y + moonDist * Math.sin(moonAngle); const moonMass = Math.max(0.1, planet.mass * randomRange(0.001, 0.01)); const moonSubtypeKey = Math.random() < 0.6 ? 'ROCKY' : 'ICY'; const moonData = PLANET_SUBTYPES[moonSubtypeKey]; const moonOptions = { type: 'planet', subTypeData: moonData }; const moon = new CelestialBody(moonX, moonY, moonMass, moonOptions); if (moonDist > 0) { const moonOrbitalSpeed = Math.sqrt((G * planet.mass) / moonDist); moon.vx = planet.vx - moonOrbitalSpeed * Math.sin(moonAngle); moon.vy = planet.vy + moonOrbitalSpeed * Math.cos(moonAngle); } else { moon.vx = planet.vx; moon.vy = planet.vy; } bodies.push(moon); } } } if (Math.random() < 0.7) { const beltDistStart = lastDist + randomRange(300, 600); const beltWidth = randomRange(400, 1000); const numAsteroids = 30 + Math.floor(Math.random() * 50); for (let i=0; i < numAsteroids; i++) { const dist = beltDistStart + Math.random() * beltWidth; const angle = Math.random() * Math.PI * 2; const x = massCenter.x + dist * Math.cos(angle); const y = massCenter.y + dist * Math.sin(angle); const mass = randomRange(0.1, 5); const rock = new CelestialBody(x, y, mass, { type: 'asteroid' }); const dx_orb = x - massCenter.x; const dy_orb = y - massCenter.y; const dist_orb_sq = dx_orb*dx_orb + dy_orb*dy_orb; if (dist_orb_sq > 100) { const dist_orb = Math.sqrt(dist_orb_sq); const orbitalSpeed = Math.sqrt((G * totalCentralMass) / dist_orb); rock.vx = avgVx - orbitalSpeed * (dy_orb / dist_orb) * (0.9 + Math.random()*0.2); rock.vy = avgVy + orbitalSpeed * (dx_orb / dist_orb) * (0.9 + Math.random()*0.2); } else { rock.vx = avgVx; rock.vy = avgVy; } bodies.push(rock); } } if (Math.random() < 0.4) { const dist = lastDist * randomRange(1.5, 3.0); const angle = Math.random() * Math.PI * 2; const x = massCenter.x + dist * Math.cos(angle); const y = massCenter.y + dist * Math.sin(angle); const mass = randomRange(5, 20); const comet = new CelestialBody(x, y, mass, {type: 'comet'}); const aimOffsetX = (Math.random() - 0.5) * primaryStar.radius * 50; const aimOffsetY = (Math.random() - 0.5) * primaryStar.radius * 50; const dx_aim = (massCenter.x + aimOffsetX) - x; const dy_aim = (massCenter.y + aimOffsetY) - y; const dist_aim_sq = dx_aim*dx_aim + dy_aim*dy_aim; if (dist_aim_sq > 100) { const dist_aim = Math.sqrt(dist_aim_sq); const speedFactor = Math.sqrt((G * totalCentralMass) / dist) * randomRange(1.0, 1.4); comet.vx = avgVx - speedFactor * (dy_aim / dist_aim) * 0.95; comet.vy = avgVy + speedFactor * (dx_aim / dist_aim) * 0.95; comet.vx += speedFactor * (dx_aim / dist_aim) * 0.15; comet.vy += speedFactor * (dy_aim / dist_aim) * 0.15; } else { comet.vx = avgVx; comet.vy = avgVy; } bodies.push(comet); } console.log(`Generated ${bodies.length} bodies.`); }

        // --- Solar System Preset --- (unchanged)
        function loadSolarSystemPreset() { console.log("Loading Solar System Preset..."); bodies = []; const massScale = 20; const distScale = 2.5; const velScale = 1.0; const sunMass = 333000 / massScale; const sun = new CelestialBody(0, 0, sunMass, { type: 'star', subTypeData: STAR_TYPES.YELLOW_DWARF, vx: 0, vy: 0 }); bodies.push(sun); const addPlanet = (name, typeKey, color, mass, dist, vel) => { const angle = Math.random() * Math.PI * 2; const x = dist * distScale * Math.cos(angle); const y = dist * distScale * Math.sin(angle); const orbitalSpeed = Math.sqrt(G * sun.mass / (dist * distScale)) * velScale; const vx = -orbitalSpeed * Math.sin(angle); const vy = orbitalSpeed * Math.cos(angle); const planet = new CelestialBody(x, y, mass / massScale, { type: 'planet', subTypeData: PLANET_SUBTYPES[typeKey], color: color, vx: vx, vy: vy }); bodies.push(planet); }; addPlanet('Mercury', 'ROCKY', '#A0A0A0', 0.055, 39, 1.24); addPlanet('Venus', 'VOLCANIC', '#D4AC6E', 0.815, 72, 1.0); addPlanet('Earth', 'ROCKY', '#6699FF', 1.0, 100, 1.0); addPlanet('Mars', 'BARREN', '#FF5733', 0.107, 152, 0.81); console.log(`Loaded ${bodies.length} bodies for Solar System.`); scale = 0.2; }

        // --- Galaxy Preset --- (NEW)
        function generateGalaxyPreset() {
             console.log("Loading Galaxy Preset...");
             bodies = [];

             const centerMass = 100000 + Math.random() * 50000; // Large central mass
             const centralBody = new CelestialBody(0, 0, centerMass, {
                 type: Math.random() < 0.3 ? 'blackhole' : 'star', // 30% chance of BH center
                 vx: 0, vy: 0
             });
              // Ensure star type is set if it's a star
             if (centralBody.type === 'star') {
                 centralBody.subTypeData = STAR_TYPES.YELLOW_DWARF; // Default to yellow dwarf for center
                 centralBody.color = centralBody.subTypeData.color;
                 centralBody.texture = generateTexture(centralBody.radius, centralBody.type, centralBody.subTypeData, centralBody.color);
             }
             bodies.push(centralBody);

             const numArms = 2 + Math.floor(Math.random() * 3); // 2-4 arms
             const armSpread = 0.5 + Math.random() * 0.5; // How tightly wound
             const numStarsPerArm = 100 + Math.floor(Math.random() * 100);
             const maxDist = 5000;
             const armOffsetAngle = Math.PI * 2 / numArms;

             for (let arm = 0; arm < numArms; arm++) {
                 const baseAngle = arm * armOffsetAngle;
                 for (let i = 0; i < numStarsPerArm; i++) {
                     // Distance from center, weighted towards middle distances
                     const dist = Math.pow(Math.random(), 1.5) * maxDist;
                     // Angle along the spiral arm + noise
                     const angle = baseAngle + dist / maxDist * armSpread * Math.PI * 2 + (Math.random() - 0.5) * 0.4;
                     // Random offset perpendicular to arm direction
                     const perpOffset = (Math.random() - 0.5) * dist * 0.1;

                     const x = dist * Math.cos(angle) + perpOffset * Math.sin(angle);
                     const y = dist * Math.sin(angle) - perpOffset * Math.cos(angle);

                     // Star properties
                     const starTypeKeys = Object.keys(STAR_TYPES);
                     const randomStarKey = starTypeKeys[Math.floor(Math.random() * starTypeKeys.length)];
                     const starData = STAR_TYPES[randomStarKey];
                     const mass = randomRange(starData.massRange[0] * 0.1, starData.massRange[1] * 0.5); // Smaller stars generally

                     // Orbital velocity (circular approximation + noise)
                     const orbitalSpeed = Math.sqrt(G * centerMass / dist) * (0.8 + Math.random() * 0.4); // Add variation
                     const vx = -orbitalSpeed * Math.sin(angle);
                     const vy = orbitalSpeed * Math.cos(angle);

                     const star = new CelestialBody(x, y, mass, {
                         type: 'star',
                         vx: vx, vy: vy,
                         subTypeData: starData
                     });
                     bodies.push(star);
                 }
             }

             console.log(`Generated ${bodies.length} bodies for Galaxy.`);
             scale = 0.05; // Zoom out significantly for galaxy view
        }


        // --- Start ---
        try {
             resizeCanvas();
             generateInitialSystem(); // Start with a random system initially
             updateSimInfo();
             updateSelectedInfo(); // Ensure buttons reflect initial state
             animate(0);
        } catch (error) {
            console.error("Error during initial setup or first animation frame:", error); const errDiv = document.createElement('div'); errDiv.style.position = 'absolute'; errDiv.style.top = '50%'; errDiv.style.left = '50%'; errDiv.style.transform = 'translate(-50%, -50%)'; errDiv.style.color = 'red'; errDiv.style.backgroundColor = 'black'; errDiv.style.border = '1px solid red'; errDiv.style.padding = '20px'; errDiv.style.fontFamily = 'Arial, sans-serif'; errDiv.innerHTML = `<h2>Simulation Error</h2><p>An error occurred. Check the console (F12) for details.</p><pre>${error.message}\n${error.stack}</pre>`; document.body.appendChild(errDiv);
        }

    </script>
</body>
</html>