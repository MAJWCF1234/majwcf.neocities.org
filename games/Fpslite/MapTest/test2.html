<!DOCTYPE html><html lang="en"><head><meta charset="utf-8" /><title>FPSLite</title><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><link rel="preconnect" href="https://fonts.googleapis.com"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet"><style>
html, body { margin: 0; padding: 0; height: 100%; overflow: hidden; background: #000; color: #fff; font-family: 'Courier New', Courier, monospace; }
#gameCanvas { display: block; width: 100vw; height: 100vh; background: #111; cursor: none; }
.info { position: absolute; top: 10px; left: 10px; padding: 10px 15px; background: rgba(0, 0, 0, 0.7); border-radius: 8px; z-index: 1000; line-height: 1.6; font-size: 14px; pointer-events: none; }
.info strong { display: block; margin-bottom: 5px; font-size: 16px; } .info div { margin-bottom: 5px; }
#loadingOverlay { position: absolute; top: 0; left: 0; right: 0; bottom: 0; background: #000; color: #fff; display: flex; align-items: center; justify-content: center; flex-direction: column; z-index: 2000; font-family: 'Press Start 2P', 'Courier New', Courier, monospace; text-align: center; }
#loadingOverlay.hide { display: none; } #loadingSpinner { width: 80px; height: 80px; margin: 20px 0; image-rendering: pixelated; }
#gameOverOverlay { position: absolute; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0, 0, 0, 0.9); color: #f00; display: none; flex-direction: column; align-items: center; justify-content: center; z-index: 3000; font-family: 'Press Start 2P', 'Courier New', Courier, monospace; text-align: center; cursor: default; padding: 20px; box-sizing: border-box; }
#gameOverOverlay h1 { font-size: calc(24px + 4vw); line-height: 1.2; margin-bottom: 25px; color: #f00; text-shadow: 4px 4px #000; font-weight: normal; text-transform: uppercase; letter-spacing: 3px; word-spacing: 10px; }
#gameOverOverlay p { font-size: calc(14px + 1vw); color: #fff; margin-bottom: 40px; font-weight: normal; text-shadow: 2px 2px #333; line-height: 1.5; }
#restartButton { padding: 15px 30px; font-size: calc(12px + 0.8vw); color: #fff; background-color: #555; border: 4px outset #aaa; cursor: pointer; font-family: 'Press Start 2P', 'Courier New', Courier, monospace; font-weight: normal; text-transform: uppercase; transition: none; box-shadow: 3px 3px 0 0 #222; letter-spacing: 1px; }
#restartButton:hover { background-color: #666; border-color: #bbb; border-style: outset; box-shadow: 4px 4px 0 0 #111; transform: translate(-1px, -1px); color: #ff0; }
#restartButton:active { background-color: #444; border-style: inset; border-color: #888; box-shadow: none; transform: translate(3px, 3px); color: #fff; }
.joystick-container { position: absolute; bottom: 20px; width: 120px; height: 120px; border-radius: 50%; background: rgba(255, 255, 255, 0.15); touch-action: none; user-select: none; z-index: 1001; display: none; box-shadow: 0 0 10px rgba(0,0,0,0.4); }
#movementJoystick { left: 30px; } .joystick-knob { position: absolute; width: 60px; height: 60px; left: 30px; top: 30px; border-radius: 50%; background: rgba(255, 255, 255, 0.4); transform: translate(0, 0); pointer-events: none; transition: transform 0.1s ease; }
body.mobile #movementJoystick { display: block; }
#fireButton, #jumpButton { position: absolute; right: 30px; width: 90px; height: 50px; border-radius: 8px; color: #fff; font-size: 16px; font-weight: bold; display: none; align-items: center; justify-content: center; cursor: pointer; user-select: none; -webkit-user-select: none; touch-action: manipulation; z-index: 1001; box-shadow: 0 0 8px rgba(0,0,0,0.4); padding: 5px; box-sizing: border-box; }
#fireButton { bottom: 100px; background: rgba(255, 50, 50, 0.35); border: 2px solid rgba(255, 50, 50, 0.6); }
#jumpButton { bottom: 40px; background: rgba(255, 255, 255, 0.25); border: 2px solid rgba(255, 255, 255, 0.4); }
body.mobile #jumpButton, body.mobile #fireButton { display: flex; } #jumpButton:active { background: rgba(255, 255, 255, 0.4); } #fireButton:active { background: rgba(255, 50, 50, 0.6); }
#hud { position: absolute; top: 10px; right: 10px; background: rgba(0, 0, 0, 0.5); padding: 8px 12px; border-radius: 5px; color: white; font-size: 14px; text-align: right; z-index: 1000; display: none; pointer-events:none; font-family: 'Courier New', Courier, monospace; }
#hud-hp-label { display: flex; justify-content: flex-end; align-items: center; margin-bottom: 2px; } #hud-hp-value { margin-left: 5px; min-width: 30px; text-align: left; }
#hud-hp-bar-bg { width: 100px; height: 12px; background-color: #555; border: 1px solid #888; margin-bottom: 4px; } #hud-hp-bar { height: 100%; background-color: #0f0; width: 100%; transition: width 0.2s ease-out, background-color 0.2s ease-out; }
#hud-ammo { display: flex; justify-content: flex-end; align-items: center; margin-top: 4px; height: 16px; } #hud-ammo-value { margin-right: 5px; min-width: 30px; text-align: left;} #hud-ammo-icons { display: flex; align-items: center; }
#hud-ammo-icons img { width: 10px; height: 16px; margin-left: 2px; image-rendering: pixelated; object-fit: contain; transition: opacity 0.2s ease-out; } #hud-ammo-icons img.empty { opacity: 0.3; } #hud-score { margin-top: 4px; }
.info .mobile-controls { display: none; } .info .desktop-controls { display: block; } body.mobile .info .mobile-controls { display: block; } body.mobile .info .desktop-controls { display: none; }
@media (max-width: 600px) {
#gameOverOverlay h1 { font-size: calc(20px + 5vw); letter-spacing: 2px; word-spacing: 5px; text-shadow: 3px 3px #000; }
#gameOverOverlay p { font-size: calc(12px + 1.5vw); } #restartButton { font-size: calc(10px + 1vw); padding: 12px 25px; border-width: 3px;}
.info { font-size: 12px; padding: 8px 10px; } .info strong { font-size: 14px;} }
</style></head><body><canvas id="gameCanvas"></canvas><div class="info"><div class="desktop-controls"> <div><strong>Controls (Desktop):</strong></div> <div>Move: W/A/S/D</div> <div>Jump: Space</div> <div>Shoot: L Click</div> <div>Look: Mouse (Lock)</div> </div><div class="mobile-controls"> <div><strong>Controls (Mobile):</strong></div> <div>Move: L Joy</div> <div>Shoot: Top R Btn</div> <div>Jump: Btm R Btn</div> <div>Look: Drag</div> </div></div><div id="loadingOverlay"><h1>Loading...</h1><p id="loadingText"></p></div><div id="gameOverOverlay"><h1>GAME OVER</h1><p>Final Score: <span id="finalScore">0</span></p><button id="restartButton">RESTART</button></div><div id="movementJoystick" class="joystick-container"><div class="joystick-knob" id="movementKnob"></div></div><button id="fireButton">FIRE</button><button id="jumpButton">JUMP</button><div id="hud"><div id="hud-hp-label">HP:<span id="hud-hp-value">100</span></div><div id="hud-hp-bar-bg"><div id="hud-hp-bar"></div></div><div id="hud-ammo"><span id="hud-ammo-value">50</span><div id="hud-ammo-icons"></div></div><div id="hud-score">Score: 0</div></div><script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script><script src="https://unpkg.com/three@0.128.0/examples/js/controls/PointerLockControls.js"></script><script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script><script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script><script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script><script src="https://unpkg.com/three@0.128.0/examples/js/shaders/CopyShader.js"></script><script>
'use strict'; const RENDER_WIDTH = 320; const RENDER_HEIGHT = 200; const USE_POSTPROCESSING = true; const MAP_WIDTH = 24; const MAP_HEIGHT = 24; const CELL_SIZE = 1.0; const WALL_HEIGHT = 1.0; const MOVE_SPEED = 3.0;
const MOUSE_SENSITIVITY = 0.002; const TOUCH_SENSITIVITY = 0.006; const PLAYER_EYE_HEIGHT = 0.0; const PLAYER_RADIUS = 0.25; const GRAVITY = 9.8; const JUMP_FORCE = 4.0; const DOOR_MARKER = 99; const DOOR_SPEED = 1.5; const DOOR_TRIGGER_DISTANCE = 2.0; const DOOR_FULLY_OPEN_OFFSET = WALL_HEIGHT * 0.98;
const PLAYER_MAX_HP = 100; const PLAYER_DAMAGE = 25; const PLAYER_MAX_AMMO = 50; const AMMO_PACK_VALUE = 20; const BULLETS_PER_INDICATOR = 10; const MAX_AMMO_INDICATORS = 5;
const PISTOL_FIRE_RATE = 4; const PISTOL_FIRE_FRAMES = 19; const PISTOL_FIRE_FRAME_WIDTH = 350; const PISTOL_FIRE_FRAME_HEIGHT = 200; const PISTOL_FIRE_FRAME_DURATION = 0.05; const PISTOL_FIRING_ANIMATION_DURATION = PISTOL_FIRE_FRAME_DURATION * PISTOL_FIRE_FRAMES;
const BIGGUN_FIRE_RATE = 5; const BIGGUN_FIRE_FRAMES = 14; const BIGGUN_FIRE_FRAME_WIDTH = 350; const BIGGUN_FIRE_FRAME_HEIGHT = 200; const BIGGUN_FIRE_FRAME_DURATION = 0.045; const BIGGUN_FIRING_ANIMATION_DURATION = BIGGUN_FIRE_FRAME_DURATION * BIGGUN_FIRE_FRAMES; const BIGGUN_DAMAGE = 35;
const HEALTH_PACK_VALUE = 50; const SCORE_PER_KILL = 100; const ITEM_PICKUP_RADIUS_SQ = 0.3 * 0.3; const BULLETHOLE_LIFETIME = 30.0; const BULLETHOLE_SIZE = 0.08; const ITEM_SCALE_DEFAULT = 0.6; const ITEM_SCALE_AMMO = 0.35; const ITEM_SCALE_BIGGUN = 1.5; const BLOOD_SPLATTER_LIFETIME = 25.0; const BLOOD_SPLATTER_SIZE = 0.7;
const ENEMY_HEALTH = 250; const ENEMY_DAMAGE = 10; const ENEMY_ATTACK_RANGE_SQ = 2.0 * 2.0; const ENEMY_SIGHT_RANGE_SQ = 12.0 * 12.0; const ENEMY_ATTACK_COOLDOWN = 1.5; const ENEMY_MOVE_SPEED = 1.5; const ENEMY_RADIUS = 0.3; const ENEMY_IDLE_FRAMES = 5; const ENEMY_IDLE_FRAME_DURATION = (0.625 / ENEMY_IDLE_FRAMES); const ENEMY_ATTACK_FRAMES = 10; const ENEMY_ATTACK_FRAME_DURATION = (1.25 / ENEMY_ATTACK_FRAMES); const ENEMY_ATTACK_DAMAGE_FRAME = 5; const ENEMY_DEATH_DURATION = 0.5; const ENEMY_SCALE = 0.9;
const MAX_CRATE_STACK_HEIGHT = 3; const CRATE_SIZE = CELL_SIZE * 0.8;
const manualCratePositions = [{ gridX: 8, gridY: 5, stackHeight: 1 },{ gridX: 11, gridY: 3, stackHeight: 1 },{ gridX: 15, gridY: 2, stackHeight: 2 },{ gridX: 11, gridY: 13, stackHeight: 1 },{ gridX: 15, gridY: 16, stackHeight: 1 }];
const assetManifest = {'wall_brick1': 'images/BRICK_1A.png','wall_tech1': 'images/TECH_1C.PNG','wall_metal1': 'images/STEEL_1A.PNG','wall_wood1': 'images/WOOD_1C.png','wall_brick3b': 'images/BRICK_3B.png','wall_bigdoor': 'images/bigdoor23.png','wall_trim': 'images/trim2.png','floor_metal': 'images/FLOOR_4A.png','ceiling_grid': 'images/GRID_1A.png','door_vertical': 'images/vdoor.png','item_health': 'images/health_pack.png','item_ammo': 'images/ammo.png','enemy_idle': 'images/enemy_idle.png','enemy_attack': 'images/enemy_attack.png','bullethole': 'images/bullethole.png','hud_bullet': 'images/bullet.png','blood': 'images/blood.png','blood1': 'images/blood1.png','pistol_idle': 'images/gun.gif','pistol_fire': 'images/fire.png','biggun_idle': 'images/biggun1.png','biggun_fire': 'images/biggun.png','item_biggun': 'images/biggunitem.png','crate1': 'images/crate1.png','crate2': 'images/crate2.png','crate3': 'images/crate3.png','crate4': 'images/crate4.png','keycard_reader': 'images/keycardreader.png'};
const wallTextureKeys = {1: 'wall_brick1', 2: 'wall_tech1', 3: 'wall_metal1', 4: 'wall_wood1', 5: 'wall_brick3b', 6: 'wall_bigdoor'};
const floorTextureKey = 'floor_metal'; const ceilingTextureKey = 'ceiling_grid'; const doorTextureKey = 'door_vertical'; const crateTextureKeys = ['crate1', 'crate2', 'crate3', 'crate4'];
const weapons = {'pistol': { idleAssetKey: 'pistol_idle', fireAssetKey: 'pistol_fire', fireFrames: PISTOL_FIRE_FRAMES, frameWidth: PISTOL_FIRE_FRAME_WIDTH, frameHeight: PISTOL_FIRE_FRAME_HEIGHT, frameDuration: PISTOL_FIRE_FRAME_DURATION, animationDuration: PISTOL_FIRING_ANIMATION_DURATION, fireRate: PISTOL_FIRE_RATE, damage: PLAYER_DAMAGE, idleMaterial: null, firingMaterial: null, geometry: null },'biggun': { idleAssetKey: 'biggun_idle', fireAssetKey: 'biggun_fire', fireFrames: BIGGUN_FIRE_FRAMES, frameWidth: BIGGUN_FIRE_FRAME_WIDTH, frameHeight: BIGGUN_FIRE_FRAME_HEIGHT, frameDuration: BIGGUN_FIRE_FRAME_DURATION, animationDuration: BIGGUN_FIRING_ANIMATION_DURATION, fireRate: BIGGUN_FIRE_RATE, damage: BIGGUN_DAMAGE, idleMaterial: null, firingMaterial: null, geometry: null }};
let mapData = [], doorData = [], doorMeshes = [], doorMap = [], assets = {}, wallMaterials = {}, floorMaterial, ceilingMaterial, doorMaterial, scene, camera, renderer, controls, clock, composer, renderTarget, moveForward = false, moveBackward = false, strafeLeft = false, strafeRight = false, jumpRequested = false, shootRequested = false, isPointerLocked = false, movementJoystick = null, lookTouchId = null, lastLookX = 0, playerVelocityY = 0.0, isGrounded = true, loadingManager, textureLoader, loadingOverlay, loadingText, jumpButtonElement, fireButtonElement, playerHP = PLAYER_MAX_HP, playerAmmo = PLAYER_MAX_AMMO, score = 0, sprites = [], spriteObjects = {}, enemies = [], isFiringAnimationPlaying = false, firingAnimationTimer = 0, fireCurrentFrame = 0, fireFrameTimer = 0, timeSinceLastShot = 1 / weapons['pistol'].fireRate, hudElement, hudHpLabelElement, hudHpValueElement, hudHpBarElement, hudScoreElement, hudAmmoElement, hudAmmoValueElement, hudAmmoIconsElement, gunMesh, crosshairGroup, raycaster, bulletHoleTexture, activeBulletHoles = [], activeBloodSplatters = [], gameRunning = false, gameOverOverlayElement, finalScoreElement, restartButtonElement, currentWeaponKey = 'pistol', playerHasBigGun = false, playerSpawnGridX, playerSpawnGridY, crateMaterials = [], crateGeometry, cratesGroup, cratePositions = [], doorFrameMaterial, doorFrameMeshes = [], keycardReaderMaterial, staticDetailMeshes = [];
const isMobileDevice = ('ontouchstart' in window || navigator.maxTouchPoints > 0);
const direction = new THREE.Vector3(); const tempVec3 = new THREE.Vector3(); const enemyMoveVec = new THREE.Vector3(); const splatterBasePos = new THREE.Vector3();
let initialSceneData = [{ mapX: 2.5, mapZ: 2.5, textureKey: 'item_health', type: 'item_health', value: HEALTH_PACK_VALUE },{ mapX: 5.5, mapZ: 5.5, textureKey: 'item_health', type: 'item_health', value: HEALTH_PACK_VALUE },{ mapX: 13.5, mapZ: 9.5, textureKey: 'item_health', type: 'item_health', value: HEALTH_PACK_VALUE },{ mapX: 12.5, mapZ: 2.5, textureKey: 'item_ammo', type: 'item_ammo', value: AMMO_PACK_VALUE },{ mapX: 15.5, mapZ: 4.5, textureKey: 'item_biggun', type: 'item_biggun', value: AMMO_PACK_VALUE },{ mapX: 11.5, mapZ: 15.5, textureKey: 'item_ammo', type: 'item_ammo', value: AMMO_PACK_VALUE },{ mapX: 4.5, mapZ: 4.5, type: 'enemy', health: ENEMY_HEALTH },{ mapX: 10.5, mapZ: 6.5, type: 'enemy', health: ENEMY_HEALTH },{ mapX: 14.5, mapZ: 14.5, type: 'enemy', health: ENEMY_HEALTH }];
let mapOffsetX = MAP_WIDTH * CELL_SIZE / 2; let mapOffsetZ = MAP_HEIGHT * CELL_SIZE / 2;
initialSceneData.forEach(sp => { sp.worldX = sp.mapX * CELL_SIZE - mapOffsetX; sp.worldZ = sp.mapZ * CELL_SIZE - mapOffsetZ; sp.id = `${sp.type}_${sp.mapX}_${sp.mapZ}`; });
function initGame() { loadingOverlay=document.getElementById("loadingOverlay"); loadingText=document.getElementById("loadingText"); jumpButtonElement=document.getElementById('jumpButton'); fireButtonElement=document.getElementById('fireButton'); hudElement=document.getElementById('hud'); hudHpLabelElement=document.getElementById('hud-hp-label'); hudHpValueElement=document.getElementById('hud-hp-value'); hudHpBarElement=document.getElementById('hud-hp-bar'); hudScoreElement=document.getElementById('hud-score'); hudAmmoElement=document.getElementById('hud-ammo'); hudAmmoValueElement=document.getElementById('hud-ammo-value'); hudAmmoIconsElement=document.getElementById('hud-ammo-icons'); gameOverOverlayElement=document.getElementById('gameOverOverlay'); finalScoreElement=document.getElementById('finalScore'); restartButtonElement=document.getElementById('restartButton'); loadingText.textContent = "Initializing..."; clock = new THREE.Clock(); initThree(); initLoaders(); generateMap(); loadAssets().then(() => { console.log("Assets Loaded."); createMaterials(); createWeaponMaterialsAndGeometry(); createMapGeometry(); addDoorFrame(); addKeycardReader(); createCrateGeometry(); cratesGroup = new THREE.Group(); scene.add(cratesGroup); setupPlayerSpawn(); addManualCrates(); spawnSceneObjects(); setupViewmodel(); updateHUD(); if (hudElement) hudElement.style.display = 'block'; setupInputListeners(); restartButtonElement.addEventListener('click', restartGame); console.log("Init Complete."); if (loadingOverlay) loadingOverlay.classList.add("hide"); gameRunning = true; animate(); }).catch(e => { console.error("Load/Setup failed:", e); loadingText.textContent = "Error loading assets. Check console."; }); }
function initThree() { scene = new THREE.Scene(); scene.background = new THREE.Color(0x111111); camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100); camera.position.y = PLAYER_EYE_HEIGHT; renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('gameCanvas') }); renderer.setPixelRatio(window.devicePixelRatio); renderer.setSize(window.innerWidth, window.innerHeight); if (USE_POSTPROCESSING) { renderTarget = new THREE.WebGLRenderTarget(RENDER_WIDTH, RENDER_HEIGHT, { minFilter: THREE.NearestFilter, magFilter: THREE.NearestFilter, format: THREE.RGBFormat, stencilBuffer: false }); composer = new THREE.EffectComposer(renderer, renderTarget); const renderPass = new THREE.RenderPass(scene, camera); composer.addPass(renderPass); const copyPass = new THREE.ShaderPass(THREE.CopyShader); composer.addPass(copyPass); } controls = new THREE.PointerLockControls(camera, renderer.domElement); controls.pointerSpeed = MOUSE_SENSITIVITY / 0.002; controls.addEventListener('lock', () => { if(gameRunning) { isPointerLocked = true; document.body.style.cursor = 'none'; } else { controls.unlock(); } }); controls.addEventListener('unlock', () => { isPointerLocked = false; document.body.style.cursor = 'default'; }); scene.add(controls.getObject()); window.addEventListener('resize', onWindowResize, false); raycaster = new THREE.Raycaster(); }
function initLoaders() { loadingManager = new THREE.LoadingManager(() => console.log("Loading Manager: All assets loaded callback."), (url, loaded, total) => loadingText.textContent = `Loading: ${url} (${loaded}/${total})`, (url) => console.error('Error loading asset:', url)); textureLoader = new THREE.TextureLoader(loadingManager); }
function loadAssets() { const p = []; for (const k in assetManifest) { p.push(new Promise((res, rej) => { textureLoader.load(assetManifest[k], (t) => { t.magFilter = THREE.NearestFilter; t.minFilter = THREE.NearestFilter; t.generateMipmaps = false; assets[k] = t; console.log(`Loaded: ${k}`); res(); }, null, (e) => {console.error(`Failed to load ${k} from ${assetManifest[k]}:`, e); loadingText.textContent = `Error loading ${k}. Check path/console.`; rej(e);}); })); } return Promise.all(p); }
function generateMap() { mapData = Array.from({ length: MAP_HEIGHT }, () => Array(MAP_WIDTH).fill(0)); doorData = []; doorMap = Array.from({ length: MAP_HEIGHT }, () => Array(MAP_WIDTH).fill(null)); function dR(x, y, w, h, wi) { for (let i = x; i < x + w; i++) { if (i >= 0 && i < MAP_WIDTH) { if (y >= 0 && y < MAP_HEIGHT) mapData[y][i] = wi; if (y + h - 1 >= 0 && y + h - 1 < MAP_HEIGHT) mapData[y + h - 1][i] = wi; } } for (let j = y + 1; j < y + h - 1; j++) { if (j >= 0 && j < MAP_HEIGHT) { if (x >= 0 && x < MAP_WIDTH) mapData[j][x] = wi; if (x + w - 1 >= 0 && x + w - 1 < MAP_WIDTH) mapData[j][x + w - 1] = wi; } } } function fI(x, y, w, h, fi = 0) { for (let j = y + 1; j < y + h - 1; j++) { for (let i = x + 1; i < x + w - 1; i++) { if (i >= 0 && i < MAP_WIDTH && j >= 0 && j < MAP_HEIGHT) mapData[j][i] = fi; } } } function pD(x, y) { if (x >= 0 && x < MAP_WIDTH && y >= 0 && y < MAP_HEIGHT) { mapData[y][x] = DOOR_MARKER; const oX = MAP_WIDTH*CELL_SIZE/2; const oZ = MAP_HEIGHT*CELL_SIZE/2; const nD = {x, y, worldX:(x+0.5)*CELL_SIZE-oX, worldZ:(y+0.5)*CELL_SIZE-oZ, state:'closed', offset:0.0, meshIndex:-1}; doorData.push(nD); doorMap[y][x] = nD; } } dR(1, 1, 6, 6, 1); fI(1, 1, 6, 6, 0); dR(6, 3, 5, 3, 3); fI(6, 3, 5, 3, 0); dR(10, 1, 7, 7, 2); fI(10, 1, 7, 7, 0); dR(12, 7, 3, 6, 3); fI(12, 7, 3, 6, 0); dR(10, 12, 7, 7, 4); fI(10, 12, 7, 7, 0); const bDX = 1, bDY = 4, sBI = 5, bDI = 6; if (bDX>=0 && bDX<MAP_WIDTH) { if (bDY>=0 && bDY<MAP_HEIGHT) mapData[bDY][bDX]=bDI; if (bDY-1>=0 && bDY-1<MAP_HEIGHT) mapData[bDY-1][bDX]=sBI; if (bDY+1>=0 && bDY+1<MAP_HEIGHT) mapData[bDY+1][bDX]=sBI; } pD(6, 4); pD(10, 4); pD(13, 7); pD(13, 12); for (let i=0; i<MAP_WIDTH; i++) { if (mapData[0][i]===0) mapData[0][i]=3; if (mapData[MAP_HEIGHT-1][i]===0) mapData[MAP_HEIGHT-1][i]=3; } for (let j=0; j<MAP_HEIGHT; j++) { if (mapData[j][0]===0) mapData[j][0]=3; if (mapData[j][MAP_WIDTH-1]===0) mapData[j][MAP_WIDTH-1]=3; } }
function createMaterials() { const c = { side: THREE.FrontSide }; wallMaterials = {}; for (const t in wallTextureKeys) { const k = wallTextureKeys[t]; wallMaterials[t] = assets[k]? new THREE.MeshBasicMaterial({ map: assets[k], ...c }) : new THREE.MeshBasicMaterial({ color: 0xcccccc, ...c }); } if (assets[floorTextureKey]) { const t = assets[floorTextureKey]; t.wrapS = t.wrapT = THREE.RepeatWrapping; t.repeat.set(MAP_WIDTH, MAP_HEIGHT); floorMaterial = new THREE.MeshBasicMaterial({ map: t, ...c }); } else { floorMaterial = new THREE.MeshBasicMaterial({ color: 0x444444, ...c }); } if (assets[ceilingTextureKey]) { const t = assets[ceilingTextureKey]; t.wrapS = t.wrapT = THREE.RepeatWrapping; t.repeat.set(MAP_WIDTH, MAP_HEIGHT); ceilingMaterial = new THREE.MeshBasicMaterial({ map: t, ...c }); } else { ceilingMaterial = new THREE.MeshBasicMaterial({ color: 0x666666, ...c }); } doorMaterial = assets[doorTextureKey] ? new THREE.MeshBasicMaterial({ map: assets[doorTextureKey], ...c }) : new THREE.MeshBasicMaterial({ color: 0x888888, ...c }); bulletHoleTexture = assets['bullethole']; if (!bulletHoleTexture) console.warn("Bullethole texture not found!"); crateMaterials = []; for (const key of crateTextureKeys) { if (assets[key]) { crateMaterials.push(new THREE.MeshBasicMaterial({ map: assets[key], ...c })); } else { console.warn(`Crate texture not found: ${key}. Using default.`); const colors = [0x8B4513, 0xA0522D, 0xCD853F, 0xD2691E]; crateMaterials.push(new THREE.MeshBasicMaterial({ color: colors[crateMaterials.length % colors.length], ...c })); } } if (crateMaterials.length === 0) { console.error("No crate textures loaded or defined!"); crateMaterials.push(new THREE.MeshBasicMaterial({ color: 0x966F33, ...c })); } if (assets['wall_trim']) { doorFrameMaterial = new THREE.MeshBasicMaterial({ map: assets['wall_trim'], side: THREE.FrontSide }); } else { console.warn("Door frame texture 'trim2.png' not found! Using fallback color."); doorFrameMaterial = new THREE.MeshBasicMaterial({ color: 0x555555, side: THREE.FrontSide }); } if (assets['keycard_reader']) { keycardReaderMaterial = new THREE.MeshBasicMaterial({ map: assets['keycard_reader'], side: THREE.FrontSide }); } else { console.warn("Keycard reader texture 'keycardreader.png' not found! Using fallback color."); keycardReaderMaterial = new THREE.MeshBasicMaterial({ color: 0xCCCCCC, side: THREE.FrontSide }); } }
function createCrateGeometry() { if (crateGeometry) crateGeometry.dispose(); crateGeometry = new THREE.BoxGeometry(CRATE_SIZE, CRATE_SIZE, CRATE_SIZE); }
function createWeaponMaterialsAndGeometry() { for (const key in weapons) { const w = weapons[key]; const iT = assets[w.idleAssetKey]; const fT = assets[w.fireAssetKey]; if (!iT || !fT) { console.error(`Assets not loaded for weapon: ${key}`); continue; } w.idleMaterial = new THREE.MeshBasicMaterial({ map: iT.clone(), transparent: true, depthTest: false, side: THREE.DoubleSide }); w.idleMaterial.map.needsUpdate = true; const fTC = fT.clone(); fTC.needsUpdate = true; fTC.repeat.set(1 / w.fireFrames, 1); w.firingMaterial = new THREE.MeshBasicMaterial({ map: fTC, transparent: true, depthTest: false, side: THREE.DoubleSide }); const gA = w.frameWidth / w.frameHeight; const gVH = 0.42; const gVW = gVH * gA; w.geometry = new THREE.PlaneGeometry(gVW, gVH); } }
function createMapGeometry() { const wg = new THREE.BoxGeometry(CELL_SIZE, WALL_HEIGHT, CELL_SIZE); const oX = MAP_WIDTH*CELL_SIZE/2; const oZ = MAP_HEIGHT*CELL_SIZE/2; for (let y = 0; y < MAP_HEIGHT; y++) { for (let x = 0; x < MAP_WIDTH; x++) { const ct = mapData[y]?.[x]; if (ct > 0 && ct !== DOOR_MARKER) { const m = wallMaterials[ct] || wallMaterials[1]; const wM = new THREE.Mesh(wg, m); wM.position.set((x+0.5)*CELL_SIZE-oX, 0, (y+0.5)*CELL_SIZE-oZ); scene.add(wM); } } } const fg = new THREE.PlaneGeometry(MAP_WIDTH*CELL_SIZE, MAP_HEIGHT*CELL_SIZE); const fm = new THREE.Mesh(fg, floorMaterial); fm.rotation.x = -Math.PI/2; fm.position.y = -WALL_HEIGHT/2; scene.add(fm); const cg = new THREE.PlaneGeometry(MAP_WIDTH*CELL_SIZE, MAP_HEIGHT*CELL_SIZE); const cm = new THREE.Mesh(cg, ceilingMaterial); cm.rotation.x = Math.PI/2; cm.position.y = WALL_HEIGHT/2; scene.add(cm); const dt = CELL_SIZE*0.1; const gEW = new THREE.BoxGeometry(CELL_SIZE, WALL_HEIGHT, dt); const gNS = new THREE.BoxGeometry(dt, WALL_HEIGHT, CELL_SIZE); doorMeshes = []; for (let i=0; i<doorData.length; i++) { const ds=doorData[i]; let dm; const x=ds.x; const y=ds.y; let isNS=false; const lC=(x>0 && mapData[y]!==undefined)?mapData[y][x-1]:0; const rC=(x<MAP_WIDTH-1 && mapData[y]!==undefined)?mapData[y][x+1]:0; if ((lC>0 && lC!==DOOR_MARKER) || (rC>0 && rC!==DOOR_MARKER)) {isNS=true;} dm = new THREE.Mesh(isNS?gEW:gNS, doorMaterial); dm.position.set(ds.worldX, 0, ds.worldZ); scene.add(dm); doorMeshes.push(dm); ds.meshIndex = doorMeshes.length-1; } }
function addDoorFrame() { if (!doorFrameMaterial) { console.error("Cannot add door frame: Material not ready."); return; } const bigDoorGridX = 1; const bigDoorGridY = 4; const trimW = CELL_SIZE * 0.125; const trimD = 0.02; const wallCX = (bigDoorGridX + 0.5) * CELL_SIZE - mapOffsetX; const wallCZ = (bigDoorGridY + 0.5) * CELL_SIZE - mapOffsetZ; const wallFaceX = wallCX + CELL_SIZE / 2; const topGeom = new THREE.BoxGeometry(trimD, trimW, CELL_SIZE); const topMesh = new THREE.Mesh(topGeom, doorFrameMaterial); topMesh.position.set(wallFaceX + trimD / 2, WALL_HEIGHT / 2 - trimW / 2, wallCZ); scene.add(topMesh); doorFrameMeshes.push(topMesh); const sideGeom = new THREE.BoxGeometry(trimD, WALL_HEIGHT, trimW); const uvs = sideGeom.attributes.uv; uvs.setXY(0, 1, 0); uvs.setXY(1, 1, 1); uvs.setXY(2, 0, 0); uvs.setXY(3, 0, 1); uvs.needsUpdate = true; const leftMesh = new THREE.Mesh(sideGeom.clone(), doorFrameMaterial); leftMesh.position.set(wallFaceX + trimD / 2, 0, wallCZ - CELL_SIZE / 2 + trimW / 2); scene.add(leftMesh); doorFrameMeshes.push(leftMesh); const rightMesh = new THREE.Mesh(sideGeom, doorFrameMaterial); rightMesh.position.set(wallFaceX + trimD / 2, 0, wallCZ + CELL_SIZE / 2 - trimW / 2); scene.add(rightMesh); doorFrameMeshes.push(rightMesh); console.log(`Added door frame trim (${doorFrameMeshes.length} pieces).`); }
function addKeycardReader() { if (!keycardReaderMaterial) { console.error("Cannot add keycard reader: Material not ready."); return; } const readerWidth = 0.1; const readerHeight = 0.15; const readerDepth = 0.02; const keycardReaderGeometry = new THREE.BoxGeometry(readerWidth, readerHeight, readerDepth); const readerMesh = new THREE.Mesh(keycardReaderGeometry, keycardReaderMaterial); const targetGridX = 1; const targetGridY = 5; const wallCX = (targetGridX + 0.5) * CELL_SIZE - mapOffsetX; const wallCZ = (targetGridY + 0.5) * CELL_SIZE - mapOffsetZ; const wallFaceX = wallCX + CELL_SIZE / 2; const readerZOffset = -CELL_SIZE * 0.40; const readerYOffset = 0.0; readerMesh.position.set(wallFaceX + readerDepth / 2, readerYOffset, wallCZ + readerZOffset); readerMesh.rotation.y = Math.PI / 2; scene.add(readerMesh); staticDetailMeshes.push(readerMesh); console.log("Added keycard reader mesh to adjacent wall block (1, 5), moved down slightly."); }
function getCellType(x, y) { if (x < 0 || x >= MAP_WIDTH || y < 0 || y >= MAP_HEIGHT) return -1; return mapData[y]?.[x] ?? -1; }
function addManualCrates() { if (!crateGeometry || crateMaterials.length === 0 || !cratesGroup) { console.error("Cannot add crates: Geometry, materials, or group not ready."); return; } const groundY = -WALL_HEIGHT / 2; const crateBaseOffsetY = CRATE_SIZE / 2; for (const cD of manualCratePositions) { const gX = cD.gridX; const gY = cD.gridY; const sH = Math.max(1, Math.min(MAX_CRATE_STACK_HEIGHT, cD.stackHeight || 1)); if (getCellType(gX, gY)!==0) { console.warn(`Skipping manual crate @ (${gX},${gY}): Cell not empty.`); continue; } if (cratePositions.some(p => p.gridX === gX && p.gridY === gY)) { console.warn(`Skipping manual crate @ (${gX},${gY}): Crate already exists.`); continue; } const wX=(gX+0.5)*CELL_SIZE-mapOffsetX; const wZ=(gY+0.5)*CELL_SIZE-mapOffsetZ; const sTY=groundY+crateBaseOffsetY+(sH-1)*CRATE_SIZE; if (sTY >= (WALL_HEIGHT/2 - CRATE_SIZE/2)) { console.warn(`Skipping/reducing manual crate @ (${gX},${gY}): Stack too tall.`); continue; } cratePositions.push({ gridX: gX, gridY: gY }); for (let h=0; h<sH; h++) { const cY = groundY+crateBaseOffsetY+h*CRATE_SIZE; const rM = crateMaterials[Math.floor(Math.random()*crateMaterials.length)]; const cM=new THREE.Mesh(crateGeometry,rM); cM.position.set(wX, cY, wZ); cM.rotation.y=Math.random()*Math.PI*0.1-Math.PI*0.05; cratesGroup.add(cM); } } }
function setupPlayerSpawn() { let sX=3.5,sZ=3.5; playerSpawnGridX = Math.floor(sX); playerSpawnGridY = Math.floor(sZ); const wX=sX*CELL_SIZE-mapOffsetX; const wZ=sZ*CELL_SIZE-mapOffsetZ; controls.getObject().position.set(wX,PLAYER_EYE_HEIGHT,wZ); controls.getObject().rotation.set(0, 0, 0); camera.rotation.set(0, 0, 0); isGrounded=true; playerVelocityY=0; playerHP = PLAYER_MAX_HP; playerAmmo = PLAYER_MAX_AMMO; score = 0; playerHasBigGun = false; switchWeapon('pistol'); gameRunning = true; if (!isMobileDevice) { document.body.style.cursor = 'default'; if(isPointerLocked) { document.exitPointerLock(); isPointerLocked = false; } } else { document.body.style.cursor = 'none'; } }
function cleanupSceneObjects() { console.log("Cleaning up scene objects..."); sprites.forEach(s => { if (s && s.object3D) { scene.remove(s.object3D); if(s.object3D.material) { if(s.object3D.material.map) s.object3D.material.map.dispose(); s.object3D.material.dispose(); } if(s.object3D.geometry) s.object3D.geometry.dispose(); if(s.idleMaterial) { if(s.idleMaterial.map) s.idleMaterial.map.dispose(); s.idleMaterial.dispose(); } if(s.attackMaterial) { if(s.attackMaterial.map) s.attackMaterial.map.dispose(); s.attackMaterial.dispose(); } } }); sprites = []; spriteObjects = {}; enemies = []; activeBulletHoles.forEach(h => { if (h && h.mesh) { scene.remove(h.mesh); if (h.mesh.geometry) h.mesh.geometry.dispose(); if (h.material) { if(h.material.map) h.material.map.dispose(); h.material.dispose(); } } }); activeBulletHoles = []; activeBloodSplatters.forEach(s => { if (s && s.mesh) { scene.remove(s.mesh); if (s.mesh.geometry) s.mesh.geometry.dispose(); if (s.material) { if(s.material.map) s.material.map.dispose(); s.material.dispose(); } } }); activeBloodSplatters = []; if (cratesGroup) { while(cratesGroup.children.length > 0){ const child = cratesGroup.children[0]; cratesGroup.remove(child); if (child.geometry) child.geometry.dispose(); } scene.remove(cratesGroup); } cratesGroup = new THREE.Group(); scene.add(cratesGroup); cratePositions = []; doorFrameMeshes.forEach(m => { if (m) { scene.remove(m); if (m.geometry) m.geometry.dispose(); } }); doorFrameMeshes = []; staticDetailMeshes.forEach(m => { if (m) { scene.remove(m); if (m.geometry) m.geometry.dispose(); } }); staticDetailMeshes = []; console.log("Cleanup complete."); }
function spawnSceneObjects() { initialSceneData.forEach(spData => { const gX = Math.floor(spData.mapX); const gY = Math.floor(spData.mapZ); if (cratePositions.some(p => p.gridX === gX && p.gridY === gY)) { console.warn(`Skipping spawn at (${gX},${gY}) due to crate obstruction: ${spData.id}`); return; } let spriteInfo = null; const itemY = -WALL_HEIGHT/2 + 0.3; const groundY = -WALL_HEIGHT/2; const enemyH = ENEMY_SCALE; const enemyY = groundY + (enemyH / 2); if (spData.type.startsWith('item_')) { if (spData.type === 'item_biggun' && playerHasBigGun) return; const tex = assets[spData.textureKey]; if (!tex) { console.warn(`Texture ${spData.textureKey} not found for item ${spData.id}`); return; } const mat = new THREE.SpriteMaterial({ map: tex.clone(), transparent: true, depthTest: true, depthWrite: true, sizeAttenuation: true }); mat.map.needsUpdate = true; const spr = new THREE.Sprite(mat); spr.position.set(spData.worldX, itemY, spData.worldZ); let scale = ITEM_SCALE_DEFAULT; if (spData.type === 'item_ammo') scale = ITEM_SCALE_AMMO; else if (spData.type === 'item_biggun') scale = ITEM_SCALE_BIGGUN; spr.scale.set(scale, scale, scale); spriteInfo = { id: spData.id, type: spData.type, value: spData.value || 0, object3D: spr, isEnemy: false }; } else if (spData.type === 'enemy') { const iTex = assets['enemy_idle']?.clone(); const aTex = assets['enemy_attack']?.clone(); if (!iTex || !aTex) { console.error(`Enemy textures missing for ${spData.id}`); return; } iTex.needsUpdate = true; iTex.repeat.set(1/ENEMY_IDLE_FRAMES, 1); iTex.offset.x = 0; const iMat = new THREE.SpriteMaterial({ map: iTex, transparent: true, depthTest: true, depthWrite: true, sizeAttenuation: true }); aTex.needsUpdate = true; aTex.repeat.set(1/ENEMY_ATTACK_FRAMES, 1); aTex.offset.x = 0; const aMat = new THREE.SpriteMaterial({ map: aTex, transparent: true, depthTest: true, depthWrite: true, sizeAttenuation: true }); const wMat = iMat; const spr = new THREE.Sprite(iMat); spr.position.set(spData.worldX, enemyY, spData.worldZ); spr.scale.set(ENEMY_SCALE, ENEMY_SCALE, ENEMY_SCALE); spriteInfo = { id: spData.id, type: spData.type, object3D: spr, health: ENEMY_HEALTH, maxHealth: ENEMY_HEALTH, state: 'idle', radius: ENEMY_RADIUS, moveSpeed: ENEMY_MOVE_SPEED, idleMaterial: iMat, attackMaterial: aMat, walkMaterial: wMat, attackCooldown: Math.random() * ENEMY_ATTACK_COOLDOWN, animationTimer: 0, currentFrame: 0, lastFrameAction: -1, deathTimer: 0, isEnemy: true }; enemies.push(spriteInfo); } if (spriteInfo) { sprites.push(spriteInfo); spriteObjects[spriteInfo.id] = spriteInfo; scene.add(spriteInfo.object3D); } }); }
function setupViewmodel() { if (gunMesh) camera.remove(gunMesh); if (crosshairGroup) camera.remove(crosshairGroup); const iW = weapons['pistol']; if (!iW || !iW.geometry || !iW.idleMaterial) { console.error("Pistol data not ready for viewmodel."); return; } gunMesh = new THREE.Mesh(iW.geometry, iW.idleMaterial); gunMesh.position.set(0, -0.09, -0.45); camera.add(gunMesh); crosshairGroup = new THREE.Group(); const cM = new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.7, depthTest: false }); const lL = 0.004; const lT = 0.0008; const lG = 0.0015; const cZ = -0.1; const hG = new THREE.PlaneGeometry(lL, lT); const vG = new THREE.PlaneGeometry(lT, lL); const l = new THREE.Mesh(hG,cM); const r = new THREE.Mesh(hG,cM); const t = new THREE.Mesh(vG,cM); const b = new THREE.Mesh(vG,cM); l.position.set(-lG-lL/2, 0, cZ); r.position.set(lG+lL/2, 0, cZ); t.position.set(0, lG+lL/2, cZ); b.position.set(0, -lG-lL/2, cZ); crosshairGroup.add(l,r,t,b); camera.add(crosshairGroup); switchWeapon('pistol'); }
function switchWeapon(key) { if (!weapons[key] || !gunMesh) { console.error(`Cannot switch to weapon: ${key}.`); return; } if (currentWeaponKey === key && gunMesh.material === weapons[key].idleMaterial) return; const wD = weapons[key]; if (gunMesh.geometry !== wD.geometry) { gunMesh.geometry.dispose(); gunMesh.geometry = wD.geometry; } gunMesh.material = wD.idleMaterial; isFiringAnimationPlaying = false; firingAnimationTimer = 0; fireCurrentFrame = 0; fireFrameTimer = 0; timeSinceLastShot = 1 / wD.fireRate; currentWeaponKey = key; updateHUD(); }
function setupInputListeners() { document.addEventListener('keydown',(e)=>{ if (!gameRunning) return; switch(e.code){case 'KeyW':moveForward=true;break;case 'KeyA':strafeLeft=true;break;case 'KeyS':moveBackward=true;break;case 'KeyD':strafeRight=true;break;case 'Space':jumpRequested=true;break;}});document.addEventListener('keyup',(e)=>{switch(e.code){case 'KeyW':moveForward=false;break;case 'KeyA':strafeLeft=false;break;case 'KeyS':moveBackward=false;break;case 'KeyD':strafeRight=false;break;case 'Space':jumpRequested=false;break;}});renderer.domElement.addEventListener('mousedown',(e)=>{if(e.button===0&&!isMobileDevice){if(gameRunning&&!isPointerLocked)controls.lock();else if(gameRunning&&isPointerLocked)shootRequested=true;}});renderer.domElement.addEventListener('mouseup',(e)=>{if(e.button===0)shootRequested=false;});renderer.domElement.addEventListener('touchstart',handleTouchStart,{passive:false});renderer.domElement.addEventListener('touchmove',handleTouchMove,{passive:false});renderer.domElement.addEventListener('touchend',handleTouchEnd,{passive:false});renderer.domElement.addEventListener('touchcancel',handleTouchEnd,{passive:false});function handleTouchStart(e){if(!isMobileDevice||!gameRunning)return;let onUI=false;const fR=fireButtonElement?.getBoundingClientRect();const jR=jumpButtonElement?.getBoundingClientRect();for(let i=0;i<e.changedTouches.length;i++){const t=e.changedTouches[i];if(fireButtonElement&&fR&&t.clientX>=fR.left&&t.clientX<=fR.right&&t.clientY>=fR.top&&t.clientY<=fR.bottom){onUI=true;break;}if(jumpButtonElement&&jR&&t.clientX>=jR.left&&t.clientX<=jR.right&&t.clientY>=jR.top&&t.clientY<=jR.bottom){onUI=true;break;}}if(!onUI){e.preventDefault();const t=e.changedTouches[0];const joyR=movementJoystick?.container.getBoundingClientRect();const isJoy=movementJoystick&&joyR&&t.clientX>=joyR.left&&t.clientX<=joyR.right&&t.clientY>=joyR.top&&t.clientY<=joyR.bottom;if(!isJoy&&lookTouchId===null){lookTouchId=t.identifier;lastLookX=t.clientX;}}} function handleTouchMove(e){if(!isMobileDevice||!gameRunning)return;for(let i=0;i<e.changedTouches.length;i++){const t=e.changedTouches[i];if(t.identifier===lookTouchId){e.preventDefault(); const dX=t.clientX-lastLookX;lastLookX=t.clientX;controls.getObject().rotation.y-=dX*TOUCH_SENSITIVITY;break;}}} function handleTouchEnd(e){if(!isMobileDevice||!gameRunning)return;for(let i=0;i<e.changedTouches.length;i++){if(e.changedTouches[i].identifier===lookTouchId){lookTouchId=null;break;}}} if(isMobileDevice){document.body.classList.add('mobile');const jC=document.getElementById('movementJoystick');const jK=document.getElementById('movementKnob');if(jC&&jK)movementJoystick=new Joystick(jC,jK);else console.error("Joystick missing"); if(jumpButtonElement){jumpButtonElement.addEventListener('touchstart',(e)=>{if(!gameRunning)return; e.preventDefault();jumpRequested=true;},{passive:false});jumpButtonElement.addEventListener('touchend',(e)=>{if(!gameRunning)return; e.preventDefault();jumpRequested=false;},{passive:false});}else console.error("Jump Btn missing"); if(fireButtonElement){fireButtonElement.addEventListener('touchstart',(e)=>{if(!gameRunning)return; e.preventDefault();shootRequested=true;},{passive:false});fireButtonElement.addEventListener('touchend',(e)=>{if(!gameRunning)return; e.preventDefault();shootRequested=false;},{passive:false});}else console.error("Fire Btn missing");}else{document.body.classList.remove('mobile');}}
let animationFrameId = null;
function animate() { if (!gameRunning) { if (animationFrameId) { cancelAnimationFrame(animationFrameId); animationFrameId = null; } return; } animationFrameId = requestAnimationFrame(animate); const delta = Math.min(0.1, clock.getDelta()); const cWD = weapons[currentWeaponKey]; if (gameRunning) { updateInput(delta); updatePhysics(delta); updateDoors(delta); checkItemPickups(delta); updateEnemies(delta); updateEnemyAnimations(delta); updateGunAnimation(delta, cWD); updateBulletHoles(delta); updateBloodSplatters(delta); timeSinceLastShot += delta; if (shootRequested && playerAmmo > 0 && timeSinceLastShot >= (1 / cWD.fireRate) && (isPointerLocked || isMobileDevice)) { triggerShooting(cWD); } else if (shootRequested && playerAmmo <= 0 && timeSinceLastShot >= (1 / cWD.fireRate)) { timeSinceLastShot = 0; } if(crosshairGroup)crosshairGroup.visible = isPointerLocked || isMobileDevice; if (USE_POSTPROCESSING && composer) composer.render(delta); else renderer.render(scene, camera); } }
function updateInput(delta) { if(isMobileDevice&&movementJoystick){const t=0.1;moveForward=movementJoystick.currentY<-t;moveBackward=movementJoystick.currentY>t;strafeLeft=movementJoystick.currentX<-t;strafeRight=movementJoystick.currentX>t;}if(controls.isLocked===true||isMobileDevice){direction.z=Number(moveForward)-Number(moveBackward);direction.x=Number(strafeLeft)-Number(strafeRight);if(direction.lengthSq()>1)direction.normalize();const speed=MOVE_SPEED*delta;let mX=0,mZ=0;const camDir=new THREE.Vector3();controls.getDirection(camDir);const fwd=new THREE.Vector3(camDir.x,0,camDir.z).normalize();const rt=new THREE.Vector3();rt.crossVectors(controls.getObject().up,fwd).normalize();mZ+=fwd.z*direction.z*speed;mX+=fwd.x*direction.z*speed;mZ+=rt.z*direction.x*speed;mX+=rt.x*direction.x*speed;const cPos=controls.getObject().position;const tX=cPos.x+mX;const tZ=cPos.z+mZ;if(canMoveTo(tX,cPos.z,PLAYER_RADIUS))cPos.x=tX;if(canMoveTo(cPos.x,tZ,PLAYER_RADIUS))cPos.z=tZ;}}
function updatePhysics(delta) { const pO=controls.getObject();if(jumpRequested&&isGrounded){playerVelocityY=JUMP_FORCE;isGrounded=false;jumpRequested=false;}if(!isGrounded)playerVelocityY-=GRAVITY*delta;pO.position.y+=playerVelocityY*delta;if(pO.position.y<PLAYER_EYE_HEIGHT){pO.position.y=PLAYER_EYE_HEIGHT;playerVelocityY=0;isGrounded=true;}else isGrounded=false;const cY=WALL_HEIGHT/2;if(pO.position.y>cY-PLAYER_RADIUS){pO.position.y=cY-PLAYER_RADIUS;if(playerVelocityY>0)playerVelocityY=0;}}
function updateDoors(delta) { const pP=controls.getObject().position;for(let i=0;i<doorData.length;i++){const dS=doorData[i];if(dS.meshIndex<0||dS.meshIndex>=doorMeshes.length)continue;const dM=doorMeshes[dS.meshIndex];const dx=pP.x-dM.position.x;const dz=pP.z-dM.position.z;const dSq=dx*dx+dz*dz;const tSq=DOOR_TRIGGER_DISTANCE*DOOR_TRIGGER_DISTANCE;let target=(dSq<tSq)?'opening':'closing';if(target==='opening'&&(dS.state==='closed'||dS.state==='closing'))dS.state='opening';else if(target==='closing'&&(dS.state==='open'||dS.state==='opening'))dS.state='closing';let changed=false;if(dS.state==='opening'){dS.offset+=DOOR_SPEED*delta;if(dS.offset>=DOOR_FULLY_OPEN_OFFSET){dS.offset=DOOR_FULLY_OPEN_OFFSET;dS.state='open';}changed=true;}else if(dS.state==='closing'){dS.offset-=DOOR_SPEED*delta;if(dS.offset<=0.0){dS.offset=0.0;dS.state='closed';}changed=true;}if(changed)dM.position.y=dS.offset;}}
function checkItemPickups(dt) { const pP=controls.getObject().position; for (let i=sprites.length-1; i>=0; i--) { const sI=sprites[i]; if (!sI||!sI.object3D||sI.isEnemy||!sI.type.startsWith('item_')) continue; const dx=pP.x-sI.object3D.position.x; const dz=pP.z-sI.object3D.position.z; const dSq=dx*dx+dz*dz; if(dSq<ITEM_PICKUP_RADIUS_SQ){let picked=false,remove=true; switch(sI.type){case 'item_health': if(playerHP<PLAYER_MAX_HP){playerHP=Math.min(PLAYER_MAX_HP,playerHP+sI.value);updateHUD();picked=true;}else remove=false;break;case 'item_ammo': if(playerAmmo<PLAYER_MAX_AMMO){playerAmmo=Math.min(PLAYER_MAX_AMMO,playerAmmo+sI.value);updateHUD();picked=true;}else remove=false;break;case 'item_biggun': if(!playerHasBigGun){playerHasBigGun=true;switchWeapon('biggun');picked=true;playerAmmo=Math.min(PLAYER_MAX_AMMO,playerAmmo+sI.value);updateHUD();console.log("Picked up Big Gun!");}else{if(playerAmmo<PLAYER_MAX_AMMO){playerAmmo=Math.min(PLAYER_MAX_AMMO,playerAmmo+sI.value);updateHUD();picked=true;}else remove=false;}break;} if(picked&&remove){scene.remove(sI.object3D);if(sI.object3D.material.map)sI.object3D.material.map.dispose();sI.object3D.material.dispose();if(sI.object3D.geometry)sI.object3D.geometry.dispose();delete spriteObjects[sI.id];sprites.splice(i,1);}}}}
function updateGunAnimation(dt, wD) { if (!gunMesh||!wD||!wD.idleMaterial||!wD.firingMaterial) return; if(isFiringAnimationPlaying){if(gunMesh.material!==wD.firingMaterial){gunMesh.material=wD.firingMaterial;if(wD.firingMaterial.map)wD.firingMaterial.map.offset.x=fireCurrentFrame/wD.fireFrames;}firingAnimationTimer-=dt;if(firingAnimationTimer<=0){isFiringAnimationPlaying=false;fireCurrentFrame=0;gunMesh.material=wD.idleMaterial;if(wD.firingMaterial.map)wD.firingMaterial.map.offset.x=0;}else{fireFrameTimer+=dt;if(fireFrameTimer>=wD.frameDuration){fireCurrentFrame=(fireCurrentFrame+1)%wD.fireFrames;fireFrameTimer-=wD.frameDuration;if(wD.firingMaterial.map)wD.firingMaterial.map.offset.x=fireCurrentFrame/wD.fireFrames;}}}else{if(gunMesh.material!==wD.idleMaterial){gunMesh.material=wD.idleMaterial;fireCurrentFrame=0;fireFrameTimer=0;if(wD.firingMaterial.map)wD.firingMaterial.map.offset.x=0;}}}
function createBloodSplatter(key, pos, rotY=0, scale=1.0, yOff=0.001) { const tex = assets[key]; if (!tex) return null; const geo = new THREE.PlaneGeometry(scale, scale); const mat = new THREE.MeshBasicMaterial({ map: tex.clone(), transparent: true, opacity: 1.0, depthWrite: false, polygonOffset: true, polygonOffsetFactor: -1, polygonOffsetUnits: -1, side: THREE.DoubleSide }); mat.map.needsUpdate = true; const mesh = new THREE.Mesh(geo, mat); mesh.userData.isBloodSplatter = true; mesh.position.copy(pos); mesh.position.y += yOff; mesh.rotation.x = -Math.PI/2; mesh.rotation.z = rotY; scene.add(mesh); return { mesh: mesh, material: mat }; }
function triggerShooting(wD) { if (!wD) return; timeSinceLastShot=0; playerAmmo--; updateHUD(); isFiringAnimationPlaying=true; firingAnimationTimer=wD.animationDuration; fireCurrentFrame=0; fireFrameTimer=0; if(gunMesh)gunMesh.material=wD.firingMaterial; if(wD.firingMaterial.map)wD.firingMaterial.map.offset.x=0; raycaster.setFromCamera(new THREE.Vector2(0,0),camera); const intersectObjs = scene.children.filter(o => o !== cratesGroup && !doorFrameMeshes.includes(o) && !staticDetailMeshes.includes(o) ); if(cratesGroup)intersectObjs.push(...cratesGroup.children); const intersects = raycaster.intersectObjects(intersectObjs, true); let hit=false; for (const i of intersects) { if(i.object===gunMesh||(crosshairGroup&&i.object.parent===crosshairGroup)||i.object.userData.isBullethole||i.object.userData.isBloodSplatter) continue; if (i.object instanceof THREE.Sprite) { const sI = Object.values(spriteObjects).find(s => s && s.object3D === i.object); if (sI && sI.isEnemy && sI.state!=='dying') { const dmg = wD.damage; sI.health -= dmg; if (sI.health <= 0) { const eP=sI.object3D.position; splatterBasePos.set(eP.x,-WALL_HEIGHT/2,eP.z); const s1=createBloodSplatter('blood',splatterBasePos,0,BLOOD_SPLATTER_SIZE,0.001); if(s1)activeBloodSplatters.push({...s1,createdAt:clock.getElapsedTime()}); const s2=createBloodSplatter('blood1',splatterBasePos,Math.random()*Math.PI*2,BLOOD_SPLATTER_SIZE*0.8,0.002); if(s2)activeBloodSplatters.push({...s2,createdAt:clock.getElapsedTime()}); sI.state='dying'; sI.deathTimer=ENEMY_DEATH_DURATION; sI.animationTimer=0; score+=SCORE_PER_KILL; updateHUD(); } hit=true; break; } else continue; } const isWallEtc = i.object.geometry instanceof THREE.BoxGeometry || i.object.geometry instanceof THREE.PlaneGeometry; if (bulletHoleTexture && isWallEtc && i.face && i.face.normal) { hit=true; const p=i.point; const n=i.face.normal.clone(); n.transformDirection(i.object.matrixWorld).normalize(); const hG = new THREE.PlaneGeometry(BULLETHOLE_SIZE,BULLETHOLE_SIZE); const hM = new THREE.MeshBasicMaterial({ map:bulletHoleTexture.clone(), color:0xffffff, transparent:true, opacity:1.0, depthWrite:false, polygonOffset:true, polygonOffsetFactor:-4, polygonOffsetUnits:-4 }); hM.map.needsUpdate=true; const hMe = new THREE.Mesh(hG,hM); hMe.userData.isBullethole = true; hMe.position.copy(p).addScaledVector(n, 0.001); hMe.lookAt(hMe.position.clone().add(n)); scene.add(hMe); activeBulletHoles.push({ mesh: hMe, material: hM, createdAt: clock.getElapsedTime() }); break; } } }
function updateBulletHoles(delta) { const now=clock.getElapsedTime(); for (let i = activeBulletHoles.length - 1; i >= 0; i--) { const h = activeBulletHoles[i]; if (!h || !h.mesh) { activeBulletHoles.splice(i, 1); continue; } const age = now - h.createdAt; if (age >= BULLETHOLE_LIFETIME) { scene.remove(h.mesh); if(h.mesh.geometry) h.mesh.geometry.dispose(); if(h.material) { if(h.material.map) h.material.map.dispose(); h.material.dispose(); } activeBulletHoles.splice(i, 1); } else { const fS = 0.8; const fST = BULLETHOLE_LIFETIME*fS; h.material.opacity = (age > fST) ? Math.max(0, 1.0 - (age - fST) / (BULLETHOLE_LIFETIME - fST)) : 1.0; } } }
function updateBloodSplatters(delta) { const now = clock.getElapsedTime(); for (let i=activeBloodSplatters.length-1; i>=0; i--) { const s = activeBloodSplatters[i]; if (!s || !s.mesh || !s.material) { activeBloodSplatters.splice(i, 1); continue; } const age = now - s.createdAt; if (age >= BLOOD_SPLATTER_LIFETIME) { scene.remove(s.mesh); if(s.mesh.geometry) s.mesh.geometry.dispose(); if(s.material) { if(s.material.map) s.material.map.dispose(); s.material.dispose(); } activeBloodSplatters.splice(i, 1); } else { const fS=0.8; const fST = BLOOD_SPLATTER_LIFETIME*fS; s.material.opacity = (age>fST) ? Math.max(0,1.0-(age-fST)/(BLOOD_SPLATTER_LIFETIME-fST)) : 1.0; } } }
function updateEnemies(delta) { const pP = controls.getObject().position; for (let i = enemies.length - 1; i >= 0; i--) { const eI = enemies[i]; if (!eI||!eI.object3D||eI.state==='dying') continue; const eS=eI.object3D; const eP=eS.position; const dx=pP.x-eP.x; const dz=pP.z-eP.z; const dSq=dx*dx+dz*dz; if (eI.attackCooldown>0) eI.attackCooldown-=delta; if(dSq<ENEMY_ATTACK_RANGE_SQ){if(eI.state!=='attacking'){eI.state='attacking';eI.animationTimer=0;eI.currentFrame=0;eI.lastFrameAction=-1;}}else if(dSq<ENEMY_SIGHT_RANGE_SQ){if(eI.state!=='chasing'){eI.state='chasing';eI.animationTimer=0;eI.currentFrame=0;}}else{if(eI.state!=='idle'){eI.state='idle';eI.animationTimer=0;eI.currentFrame=0;}} if (eI.state === 'chasing') { enemyMoveVec.set(dx,0,dz).normalize(); const move=eI.moveSpeed*delta; const tX=eP.x+enemyMoveVec.x*move; const tZ=eP.z+enemyMoveVec.z*move; if(canEnemyMoveTo(tX,eP.z,eI.radius))eP.x=tX; if(canEnemyMoveTo(eP.x,tZ,eI.radius))eP.z=tZ; } const lookT=tempVec3.set(camera.position.x,eP.y,camera.position.z); eS.lookAt(lookT); } }
function updateEnemyAnimations(delta) { const pP=controls.getObject().position; for (let i=enemies.length-1; i>=0; i--) { const eI=enemies[i]; if(!eI||!eI.object3D) continue; const eS=eI.object3D; const eP=eS.position; if(eI.state==='dying'){eI.deathTimer-=delta; const ratio=Math.max(0,eI.deathTimer/ENEMY_DEATH_DURATION); if(eS.material)eS.material.opacity=ratio; if(eI.deathTimer<=0){scene.remove(eS);if(eS.geometry)eS.geometry.dispose();if(eI.idleMaterial){if(eI.idleMaterial.map)eI.idleMaterial.map.dispose();eI.idleMaterial.dispose();}if(eI.attackMaterial){if(eI.attackMaterial.map)eI.attackMaterial.map.dispose();eI.attackMaterial.dispose();}delete spriteObjects[eI.id];const sIdx=sprites.findIndex(s => s && s.id===eI.id);if(sIdx>-1)sprites.splice(sIdx,1);enemies.splice(i,1);continue;}}else{if(eS.material&&eS.material.opacity<1.0)eS.material.opacity=1.0;} if(eI.state==='dying')continue; eI.animationTimer+=delta; let dur, count, mat, tex, numFrames; if (eI.state==='attacking') { mat=eI.attackMaterial; dur=ENEMY_ATTACK_FRAME_DURATION; numFrames=ENEMY_ATTACK_FRAMES; } else if (eI.state==='chasing') { mat=eI.walkMaterial; dur=ENEMY_IDLE_FRAME_DURATION; numFrames=ENEMY_IDLE_FRAMES; } else { mat=eI.idleMaterial; dur=ENEMY_IDLE_FRAME_DURATION; numFrames=ENEMY_IDLE_FRAMES; } count=numFrames; tex=mat?.map; if(eS.material!==mat&&mat){eS.material=mat;eI.animationTimer=0;eI.currentFrame=0;if(tex)tex.offset.x=0;eI.lastFrameAction=-1;} if(tex&&dur>0&&count>0){let prev=eI.currentFrame;while(eI.animationTimer>=dur){eI.currentFrame=(eI.currentFrame+1)%count;eI.animationTimer-=dur;}if(eI.currentFrame!==prev)tex.offset.x=eI.currentFrame/numFrames;if(eI.state==='attacking'&&eI.currentFrame===ENEMY_ATTACK_DAMAGE_FRAME&&eI.lastFrameAction!==ENEMY_ATTACK_DAMAGE_FRAME){eI.lastFrameAction=eI.currentFrame;if(eI.attackCooldown<=0){const dx=pP.x-eP.x;const dz=pP.z-eP.z;const dSq=dx*dx+dz*dz;if(dSq<ENEMY_ATTACK_RANGE_SQ){playerHP-=ENEMY_DAMAGE;playerHP=Math.max(0,playerHP);updateHUD();eI.attackCooldown=ENEMY_ATTACK_COOLDOWN;if(playerHP<=0){console.log("PLAYER DIED!");triggerGameOver();return;}}}}if(eI.currentFrame===0&&prev!==0)eI.lastFrameAction=-1;}}}
function triggerGameOver() { if (!gameRunning) return; gameRunning=false; moveForward=moveBackward=strafeLeft=strafeRight=jumpRequested=shootRequested=false; if(movementJoystick)movementJoystick.reset(); if(!isMobileDevice&&isPointerLocked)controls.unlock();else document.body.style.cursor='default'; isPointerLocked=false; if(hudElement)hudElement.style.display='none'; if(finalScoreElement)finalScoreElement.textContent=score; if(gameOverOverlayElement)gameOverOverlayElement.style.display='flex'; if(animationFrameId){cancelAnimationFrame(animationFrameId);animationFrameId=null;} }
function updateHUD() { if (!hudHpValueElement||!hudHpBarElement||!hudAmmoValueElement||!hudAmmoIconsElement||!hudScoreElement) return; hudHpValueElement.textContent=Math.max(0,Math.round(playerHP)); const hpP=Math.min(1,Math.max(0,playerHP/PLAYER_MAX_HP)); hudHpBarElement.style.width=`${hpP*100}%`; hudHpBarElement.style.backgroundColor = (hpP > 0.5) ? '#0f0' : (hpP > 0.2) ? '#ff0' : '#f00'; if(assets['hud_bullet']&&assets['hud_bullet'].image){hudAmmoValueElement.textContent=playerAmmo;hudAmmoIconsElement.innerHTML='';for(let i=0;i<MAX_AMMO_INDICATORS;i++){const img=document.createElement('img');img.src=assets['hud_bullet'].image.src;img.alt='b';img.classList.toggle('empty',playerAmmo<=i*BULLETS_PER_INDICATOR);hudAmmoIconsElement.appendChild(img);}}hudScoreElement.textContent=`Score: ${score}`; }
function canMoveTo(tX, tZ, r) { const gX=Math.floor((tX+mapOffsetX+Math.sign(tX-controls.getObject().position.x)*r)/CELL_SIZE); const gY=Math.floor((tZ+mapOffsetZ+Math.sign(tZ-controls.getObject().position.z)*r)/CELL_SIZE); return !isMapWall(gX,gY); }
function canEnemyMoveTo(tX, tZ, r) { let gX=Math.floor((tX+mapOffsetX)/CELL_SIZE); let gY=Math.floor((tZ+mapOffsetZ)/CELL_SIZE); if(isMapWall(gX,gY))return false; gX=Math.floor((tX+mapOffsetX+r)/CELL_SIZE); gY=Math.floor((tZ+mapOffsetZ+r)/CELL_SIZE); if(isMapWall(gX,gY))return false; gX=Math.floor((tX+mapOffsetX-r)/CELL_SIZE); gY=Math.floor((tZ+mapOffsetZ+r)/CELL_SIZE); if(isMapWall(gX,gY))return false; gX=Math.floor((tX+mapOffsetX+r)/CELL_SIZE); gY=Math.floor((tZ+mapOffsetZ-r)/CELL_SIZE); if(isMapWall(gX,gY))return false; gX=Math.floor((tX+mapOffsetX-r)/CELL_SIZE); gY=Math.floor((tZ+mapOffsetZ-r)/CELL_SIZE); if(isMapWall(gX,gY))return false; return true; }
function isMapWall(gX, gY) { if (gX<0||gX>=MAP_WIDTH||gY<0||gY>=MAP_HEIGHT) return true; const ct = mapData[gY]?.[gX]; if (ct === undefined) return true; if (ct > 0 && ct !== DOOR_MARKER) return true; if (ct === DOOR_MARKER) { const dS = doorMap[gY]?.[gX]; return (dS && dS.offset < (DOOR_FULLY_OPEN_OFFSET * 0.5)); } if (cratePositions.some(p => p.gridX === gX && p.gridY === gY)) return true; return false; }
function onWindowResize() { const w = window.innerWidth; const h = window.innerHeight; camera.aspect = w / h; camera.updateProjectionMatrix(); renderer.setSize(w, h); if (USE_POSTPROCESSING && composer) composer.setSize(w, h); }
function restartGame() { console.log("Restarting game..."); if (gameRunning) gameRunning = false; if(gameOverOverlayElement)gameOverOverlayElement.style.display='none'; cleanupSceneObjects(); doorData.forEach(dS=>{dS.state='closed';dS.offset=0.0;if(dS.meshIndex>=0&&dS.meshIndex<doorMeshes.length)doorMeshes[dS.meshIndex].position.y=0.0;}); addManualCrates(); addDoorFrame(); addKeycardReader(); spawnSceneObjects(); setupPlayerSpawn(); moveForward=moveBackward=strafeLeft=strafeRight=jumpRequested=shootRequested=false; lookTouchId=null; lastLookX=0; if(movementJoystick)movementJoystick.reset(); if(hudElement)hudElement.style.display='block'; updateHUD(); if(!animationFrameId) { gameRunning = true; animate(); } console.log("Game Restarted."); }
window.addEventListener('load', initGame);
class Joystick { constructor(container, knob){ this.container=container;this.knob=knob;this.centerX=0;this.centerY=0;this.maxDistance=container.offsetWidth/2-knob.offsetWidth/2;this.currentX=0;this.currentY=0;this.active=false; this.touchId=null; this.isMouse=false; const opts={passive:false}; this.container.addEventListener("touchstart",(e)=>this.start(e),opts); this.container.addEventListener("touchmove",(e)=>this.move(e),opts); this.container.addEventListener("touchend",(e)=>this.end(e),opts); this.container.addEventListener("touchcancel",(e)=>this.end(e),opts); this.container.addEventListener("mousedown",(e)=>this.startMouse(e)); document.addEventListener("mousemove",(e)=>this.moveMouse(e)); document.addEventListener("mouseup",(e)=>this.endMouse(e)); } start(e){if (!gameRunning) return; e.preventDefault();if(this.active)return;const touch=e.changedTouches[0];this.touchId=touch.identifier;this.active=true;let rect=this.container.getBoundingClientRect();this.centerX=rect.left+rect.width/2;this.centerY=rect.top+rect.height/2;this.updatePosition(touch);} move(e){if(!this.active || !gameRunning)return;let touch=null;for(let i=0;i<e.changedTouches.length;i++){if(e.changedTouches[i].identifier===this.touchId){touch=e.changedTouches[i];break;}}if(touch){e.preventDefault(); this.updatePosition(touch);}} end(e){if(!this.active)return;let touchEnded=false;for(let i=0;i<e.changedTouches.length;i++){if(e.changedTouches[i].identifier===this.touchId){touchEnded=true;break;}}if(touchEnded){this.resetJoystickState();}} startMouse(e){if (!gameRunning || e.button!==0||this.active)return;e.preventDefault();this.active=true;this.isMouse=true;let rect=this.container.getBoundingClientRect();this.centerX=rect.left+rect.width/2;this.centerY=rect.top+rect.height/2;this.updatePosition(e);} moveMouse(e){if(!this.active||!this.isMouse || !gameRunning)return;e.preventDefault();this.updatePosition(e);} endMouse(e){if(!this.active||!this.isMouse||e.button!==0)return;this.resetJoystickState();} updatePosition(evSrc){let clientX,clientY;if(evSrc.identifier!==undefined){clientX=evSrc.clientX;clientY=evSrc.clientY;}else{clientX=evSrc.clientX;clientY=evSrc.clientY;}let dx=clientX-this.centerX,dy=clientY-this.centerY;const distSq=dx*dx+dy*dy;const maxDistSq=this.maxDistance*this.maxDistance;let cX=dx,cY=dy;if(distSq>maxDistSq){const dist=Math.sqrt(distSq); cX=(dx/dist)*this.maxDistance; cY=(dy/dist)*this.maxDistance;} this.currentX=cX/this.maxDistance;this.currentY=cY/this.maxDistance;this.knob.style.transform=`translate(${cX}px, ${cY}px)`;} resetJoystickState() { this.active = false; this.touchId = null; this.isMouse = false; this.currentX = 0; this.currentY = 0; this.knob.style.transform = `translate(0px, 0px)`; moveForward = false; moveBackward = false; strafeLeft = false; strafeRight = false; } reset() { this.resetJoystickState(); }}
</script></body></html>