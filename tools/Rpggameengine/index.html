<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <title>Map Builder & Tester (With 5 New Fixes)</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

    /* --- BASIC RESET & BODY --- */
    * {
      box-sizing: border-box;
    }
    body {
      margin: 0;
      padding: 0;
      font-family: 'Press Start 2P', monospace;
      background-color: #1b1b1b;
      color: #f8f8f2;
      font-size: 12px;
      line-height: 1.4;
    }

    /* --- HEADERS --- */
    h1, h2, h3, h4 {
      margin-top: 0;
      letter-spacing: 1px;
      text-shadow: 1px 1px 0px #000;
      color: #f46290;
    }

    /* --- BUTTONS --- */
    button {
      cursor: pointer;
      font-size: 12px;
      font-family: inherit;
      border: 2px solid #f9a8c4;
      background: #1b1b1b;
      color: #f46290;
      padding: 6px 10px;
      border-radius: 6px;
    }
    button:hover {
      background: #f9a8c4;
      color: #1b1b1b;
    }

    /* --- INPUTS, SELECTS, TEXTAREAS --- */
    input[type="text"],
    input[type="number"],
    select,
    textarea {
      font-family: inherit;
      font-size: 12px;
      padding: 4px;
      background: #2a2a2a;
      color: #fff;
      border: 2px dashed #f46290;
      border-radius: 4px;
    }

    /* --- HEADER --- */
    .header {
      text-align: center;
      background-color: #2a2a2a;
      padding: 10px 0;
      margin-bottom: 10px;
      border-bottom: 3px solid #f46290;
    }
    .header p {
      margin: 0;
      font-size: 10px;
      color: #f9a8c4;
    }

    /* --- LAYOUT CONTAINER --- */
    .container {
      display: flex;
      flex-wrap: wrap;
      gap: 20px;
      margin: 0 auto;
      max-width: 1280px;
      padding: 10px;
    }
    @media (max-width: 768px) {
      .container {
        flex-direction: column;
      }
    }

    /* --- EDITOR PANEL --- */
    .editor {
      border: 3px solid #f46290;
      background-color: #2a2a2a;
      border-radius: 6px;
      padding: 10px;
      max-width: 440px;
      flex: 1 1 auto;
    }

    /* --- MAP GRID --- */
    .map-grid {
      display: grid;
      margin: 10px 0;
      border: 3px solid #f46290;
      background: #1b1b1b;
    }
    .map-grid div {
      width: 32px;
      height: 32px;
      border: 1px solid #444;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 16px;
      color: #000; 
      transition: background 0.1s ease;
    }
    .map-grid div:hover {
      background-color: #3a3a3a;
      cursor: crosshair;
    }
    .no-borders div {
      border: none !important;
    }

    /* --- GAME PANEL --- */
    .game-panel {
      flex: 1 1 auto;
      background-color: #2a2a2a;
      border: 3px solid #f46290;
      border-radius: 6px;
      padding: 10px;
    }
    #gameCanvas {
      display: block;
      border: 3px solid #f46290;
      max-width: 100%;
      height: auto;
      margin: 0 auto;
      background-color: #1b1b1b;
    }

    /* --- EXPORT / IMPORT --- */
    #exportOutput {
      white-space: pre-wrap;
      font-size: 10px;
      border: 2px dashed #f46290;
      background: #1b1b1b;
      color: #f8f8f2;
      padding: 5px;
      max-height: 150px;
      overflow-y: auto;
      margin-top: 10px;
      border-radius: 6px;
    }
    #importInput {
      width: 100%;
      height: 60px;
      font-size: 10px;
      box-sizing: border-box;
      margin-top: 5px;
      background: #1b1b1b;
      color: #f8f8f2;
      border: 2px dashed #f46290;
      border-radius: 6px;
    }

    /* --- FIELDSETS --- */
    fieldset {
      margin: 5px 0;
      border: 2px dashed #f46290;
      border-radius: 6px;
      padding: 5px;
    }
    legend {
      font-size: 10px;
      color: #f9a8c4;
      padding: 0 5px;
    }

    /* --- TOOL BUTTONS --- */
    .tool-buttons {
      display: flex;
      gap: 8px;
      margin: 10px 0;
      flex-wrap: wrap;
    }
    .tool-button {
      padding: 6px 10px;
      font-size: 12px;
      border: 2px solid #f9a8c4;
      background: #1b1b1b;
      color: #f46290;
      border-radius: 6px;
    }
    .tool-button:hover {
      background: #f9a8c4;
      color: #1b1b1b;
    }
    .tool-button.selected {
      background: #f46290;
      border-color: #f46290;
      color: #1b1b1b;
    }

    /* --- MOBILE CONTROLS --- */
    .controls-container {
      display: flex;
      justify-content: center;
      margin-top: 10px;
    }
    .controls-grid {
      display: grid;
      grid-template-columns: 60px 60px 60px;
      gap: 5px;
      justify-content: center;
    }
    .controls-grid button {
      width: 60px;
      height: 60px;
      font-size: 14px;
      border: 2px solid #f9a8c4;
      background: #1b1b1b;
      color: #f46290;
      border-radius: 6px;
    }
    .controls-grid button:hover {
      background: #f9a8c4;
      color: #1b1b1b;
    }

    /* --- MODAL --- */
    .modal-overlay {
      position: fixed;
      top: 0; 
      left: 0;
      width: 100%; 
      height: 100%;
      background: rgba(0, 0, 0, 0.7);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 9999;
    }
    .modal-overlay.active {
      display: flex;
    }
    .modal-content {
      background: #2a2a2a;
      border: 3px solid #f46290;
      border-radius: 6px;
      padding: 20px;
      max-width: 400px;
      width: 90%;
      text-align: center;
      box-shadow: 0 2px 8px rgba(0,0,0,0.3);
    }
    .modal-content h3 {
      margin-top: 0;
      color: #f46290;
      font-size: 14px;
    }
    .modal-content p {
      color: #f8f8f2;
      font-size: 12px;
    }
    .modal-buttons {
      margin-top: 10px;
    }

    .hidden {
      display: none;
    }

    /* --- OPTIONAL LOADING INDICATOR (for long operations) --- */
    #loadingIndicator {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.8);
      color: #f8f8f2;
      padding: 20px;
      border-radius: 8px;
      z-index: 10000;
      font-size: 14px;
    }
    #loadingIndicator.hidden {
      display: none;
    }
  </style>
</head>
<body>

<div class="header">
  <h1>Map Builder & Tester</h1>
  <p>build game maps and test them</p>
</div>

<div class="container">
  <!-- EDITOR PANEL -->
  <div class="editor">
    <h2>MAP EDITOR</h2>
    <div>
      <label>Rows:
        <input type="number" id="rowsInput" value="10" min="1">
      </label>
      <label>Cols:
        <input type="number" id="colsInput" value="10" min="1">
      </label>
      <button id="generateButton">Generate Grid</button>
    </div>
    <div style="margin-top: 5px;">
      <button id="randomMapButton">Randomize Map</button>
      <button id="toggleGridButton">Toggle Grid Lines</button>
      <button id="undoButton">Undo</button>
    </div>

    <h3>Tile Settings</h3>
    <div>
      <label>Tile Type:
        <select id="tileTypeSelect">
          <option value="floor">Floor</option>
          <option value="wall">Wall</option>
          <option value="door_locked">Door (Locked)</option>
          <option value="stairs_up">Stairs Up</option>
          <option value="stairs_down">Stairs Down</option>
          <option value="chest">Chest</option>
          <option value="hole">Hole</option>
          <option value="spawn">Spawn</option>
          <option value="arrow_up">Arrow Up</option>
          <option value="arrow_down">Arrow Down</option>
          <option value="arrow_left">Arrow Left</option>
          <option value="arrow_right">Arrow Right</option>
          <option value="treasure">Treasure</option>
          <option value="lava">Lava</option>
        </select>
      </label>
    </div>
    <div>
      <label>Collider:
        <input type="checkbox" id="colliderCheckbox">
      </label>
      <label>Interactable:
        <input type="checkbox" id="interactableCheckbox">
      </label>
    </div>
    <div>
      <label>Label:
        <input type="text" id="labelInput" placeholder="e.g. Clothes">
      </label>
    </div>

    <!-- HOLE PROPERTIES -->
    <fieldset id="holeProperties" class="hidden">
      <legend>Hole Properties</legend>
      <div>
        <label>Target Map:
          <input type="text" id="holeTargetMapInput" placeholder="Map name/ID">
        </label>
      </div>
      <div>
        <label>Target X:
          <input type="number" id="holeTargetXInput" value="0">
        </label>
        <label>Target Y:
          <input type="number" id="holeTargetYInput" value="0">
        </label>
      </div>
      <div>
        <label>Death:
          <input type="checkbox" id="holeDeathCheckbox">
        </label>
      </div>
    </fieldset>

    <!-- EVENT PROPERTIES -->
    <fieldset>
      <legend>Event Properties</legend>
      <div>
        <label>Event Type:
          <select id="eventTypeSelect">
            <option value="">(none)</option>
            <option value="dialogue">Dialogue</option>
            <option value="shop">Shop</option>
            <option value="battle">Battle</option>
            <option value="teleport">Teleport</option>
          </select>
        </label>
      </div>
      <div>
        <label>Event Data:
          <input type="text" id="eventDataInput" placeholder='e.g. {"targetMap":"Dungeon2","targetX":4,"targetY":7}'>
        </label>
      </div>
    </fieldset>

    <h3>Brush Tools</h3>
    <div class="tool-buttons">
      <button id="toolPaint" class="tool-button selected" title="Shortcut: P">Paint</button>
      <button id="toolEraser" class="tool-button" title="Shortcut: E">Eraser</button>
      <button id="toolFill" class="tool-button" title="Shortcut: F">Flood Fill</button>
    </div>

    <h4>Brush Size</h4>
    <label>
      <select id="brushSizeSelect">
        <option value="1">1×1</option>
        <option value="3">3×3</option>
        <option value="5">5×5</option>
      </select>
    </label>

    <div style="margin: 10px 0;">
      <label>Tile Color:
        <input type="color" id="tileColorPicker" value="#ffffff">
      </label>
    </div>

    <fieldset>
      <legend>Door Settings</legend>
      <label>Door Fade Speed (ms):
        <input type="number" id="doorFadeSpeedInput" value="150" min="50" step="50">
      </label>
    </fieldset>

    <div id="mapGrid" class="map-grid"></div>

    <button id="exportButton">Export Map</button>
    <button id="loadGameButton">Load in Game</button>

    <h3>Import JSON</h3>
    <p>Paste JSON here, then click “Import Map”:</p>
    <textarea id="importInput" placeholder="Paste JSON to import"></textarea>
    <button id="importButton">Import Map</button>

    <h3>Exported JSON</h3>
    <pre id="exportOutput"></pre>
  </div>

  <!-- GAME PANEL -->
  <div class="game-panel">
    <h2>GAME PREVIEW</h2>
    <canvas id="gameCanvas" width="320" height="320"></canvas>

    <div class="controls-container">
      <div class="controls-grid">
        <div></div>
        <button id="btnUp">↑</button>
        <div></div>
        <button id="btnLeft">←</button>
        <div></div>
        <button id="btnRight">→</button>
        <div></div>
        <button id="btnDown">↓</button>
        <div></div>
      </div>
    </div>
  </div>

</div>

<!-- MODAL OVERLAY -->
<div class="modal-overlay" id="modalOverlay" role="dialog" aria-modal="true" aria-labelledby="modalTitle" aria-describedby="modalMessage">
  <div class="modal-content" id="modalContent">
    <h3 id="modalTitle">EVENT</h3>
    <p id="modalMessage">Event details go here.</p>
    <div class="modal-buttons">
      <button id="modalCloseBtn">Close</button>
    </div>
  </div>
</div>

<!-- OPTIONAL LOADING INDICATOR -->
<div id="loadingIndicator" class="hidden">
  <p>Loading...</p>
</div>

<script>
/****************************************************************
 * 1) GLOBAL DATA & STRUCTURES
 ****************************************************************/
let currentTool = 'paint'; // properly declare to avoid global pollution

let mapData = [];
let currentMap = null;
let undoStack = [];
let maps = Object.create(null); // store multiple named maps

/****************************************************************
 * 2) HELPER FUNCTIONS
 ****************************************************************/
function deepCopy(obj) {
  return JSON.parse(JSON.stringify(obj));
}

function isInBounds(r, c) {
  return r >= 0 && r < mapData.length && c >= 0 && c < mapData[0].length;
}

function selectTool(tool) {
  currentTool = tool;
  toolPaint.classList.remove('selected');
  toolEraser.classList.remove('selected');
  toolFill.classList.remove('selected');
  if (tool === 'paint') {
    toolPaint.classList.add('selected');
  } else if (tool === 'eraser') {
    toolEraser.classList.add('selected');
  } else if (tool === 'fill') {
    toolFill.classList.add('selected');
  }
}

function showLoading() {
  document.getElementById('loadingIndicator').classList.remove('hidden');
}
function hideLoading() {
  document.getElementById('loadingIndicator').classList.add('hidden');
}

function saveCurrentState() {
  const MAX_UNDO = 20;
  if (undoStack.length >= MAX_UNDO) {
    undoStack.shift();
  }
  undoStack.push(deepCopy(mapData));
}

function validateTile(tile) {
  const validTileTypes = [
    'floor','wall','door_locked','stairs_up','stairs_down','chest','hole','spawn',
    'arrow_up','arrow_down','arrow_left','arrow_right','treasure','lava'
  ];
  if (!validTileTypes.includes(tile.tileType)) return false;
  if (typeof tile.tileColor !== 'string') return false;
  if (typeof tile.collider !== 'boolean') return false;
  if (typeof tile.interactable !== 'boolean') return false;
  if (typeof tile.label !== 'string') return false;
  return true;
}

function getDefaultTile() {
  return {
    tileColor: '#ffffff',
    tileType: 'floor',
    collider: false,
    interactable: false,
    label: '',
    holeTargetMap: '',
    holeTargetX: 0,
    holeTargetY: 0,
    holeDeath: false,
    eventType: '',
    eventData: '',
    _iconChar: '',
    _unlocking: false
  };
}

/****************************************************************
 * DOM ELEMENTS
 ****************************************************************/
const rowsInput  = document.getElementById('rowsInput');
const colsInput  = document.getElementById('colsInput');
const generateButton  = document.getElementById('generateButton');
const randomMapButton = document.getElementById('randomMapButton');
const toggleGridButton= document.getElementById('toggleGridButton'); 
const undoButton      = document.getElementById('undoButton');
const mapGrid         = document.getElementById('mapGrid');

const tileTypeSelect       = document.getElementById('tileTypeSelect');
const colliderCheckbox     = document.getElementById('colliderCheckbox');
const interactableCheckbox = document.getElementById('interactableCheckbox');
const labelInput           = document.getElementById('labelInput');

const holeProperties       = document.getElementById('holeProperties');
const holeTargetMapInput   = document.getElementById('holeTargetMapInput');
const holeTargetXInput     = document.getElementById('holeTargetXInput');
const holeTargetYInput     = document.getElementById('holeTargetYInput');
const holeDeathCheckbox    = document.getElementById('holeDeathCheckbox');

const eventTypeSelect      = document.getElementById('eventTypeSelect');
const eventDataInput       = document.getElementById('eventDataInput');
const brushSizeSelect      = document.getElementById('brushSizeSelect');
const tileColorPicker      = document.getElementById('tileColorPicker');
const doorFadeSpeedInput   = document.getElementById('doorFadeSpeedInput');

const toolPaint      = document.getElementById('toolPaint');
const toolEraser     = document.getElementById('toolEraser');
const toolFill       = document.getElementById('toolFill');

const exportButton   = document.getElementById('exportButton');
const exportOutput   = document.getElementById('exportOutput');
const loadGameButton = document.getElementById('loadGameButton');
const importInput    = document.getElementById('importInput');
const importButton   = document.getElementById('importButton');

const gameCanvas     = document.getElementById('gameCanvas');
const ctx            = gameCanvas.getContext('2d');
let playerRow        = 0;
let playerCol        = 0;
let jumpPending      = false;

const btnUp          = document.getElementById('btnUp');
const btnDown        = document.getElementById('btnDown');
const btnLeft        = document.getElementById('btnLeft');
const btnRight       = document.getElementById('btnRight');

let spawnEffectTime       = 0;
let spawnEffectDuration   = 800;
let spawnEffectActive     = false;

/****************************************************************
 * 3) INITIALIZATION & EVENTS
 ****************************************************************/
document.addEventListener('DOMContentLoaded', () => {
  setupMobileControls(); // ensure mobile controls on load
});

// Toggle Grid Lines (Fix #2: improved text)
let gridVisible = true;
toggleGridButton.textContent = 'Hide Grid Lines'; // Start with lines visible
toggleGridButton.addEventListener('click', () => {
  gridVisible = !gridVisible;
  if (gridVisible) {
    mapGrid.classList.remove('no-borders');
    toggleGridButton.textContent = 'Hide Grid Lines';
  } else {
    mapGrid.classList.add('no-borders');
    toggleGridButton.textContent = 'Show Grid Lines';
  }
});

// Show/hide holeProperties based on tile type (Fix #3)
tileTypeSelect.addEventListener('change', () => {
  if (tileTypeSelect.value === 'hole') {
    holeProperties.classList.remove('hidden');
  } else {
    holeProperties.classList.add('hidden');
  }
});

/****************************************************************
 * GENERATE GRID
 ****************************************************************/
generateButton.addEventListener('click', () => {
  const rows = parseInt(rowsInput.value, 10);
  const cols = parseInt(colsInput.value, 10);
  if (rows < 1 || cols < 1) {
    openModal("Invalid Dimensions", "Rows and Cols must be at least 1.");
    return;
  }

  saveCurrentState();
  mapData = [];
  for (let r = 0; r < rows; r++) {
    const rowArr = [];
    for (let c = 0; c < cols; c++) {
      rowArr.push(getDefaultTile());
    }
    mapData.push(rowArr);
  }

  const mapName = prompt("Enter a name for this new map:", "Default");
  if (!mapName) {
    openModal("Generation Canceled", "No map name provided.");
  } else {
    if (maps[mapName]) {
      const overwrite = confirm(`Map "${mapName}" already exists. Overwrite?`);
      if (!overwrite) {
        openModal("Generation Canceled", `Map "${mapName}" was not overwritten.`);
        return;
      }
    }
    maps[mapName] = deepCopy(mapData);
    openModal("Grid Generated", `New grid stored as "${mapName}".`);
  }

  currentMap = mapData;
  renderEditorGrid();
  setupMobileControls();
});

/****************************************************************
 * RANDOM MAP
 ****************************************************************/
randomMapButton.addEventListener('click', () => {
  if (!mapData.length) {
    openModal("No Map", "Generate a grid first!");
    return;
  }
  saveCurrentState();

  const tileTypes = ['floor','wall','door_locked','chest','hole','spawn','treasure','lava'];
  let spawnAssigned = false;

  for (let r = 0; r < mapData.length; r++) {
    for (let c = 0; c < mapData[r].length; c++) {
      const tile = mapData[r][c];
      const randType = tileTypes[Math.floor(Math.random() * tileTypes.length)];

      tile.tileType = randType;
      tile.tileColor = '#dddddd';
      tile.collider = false;
      tile.interactable = false;
      tile.label = '';

      if (randType === 'wall' || randType === 'door_locked') {
        tile.collider = true;
      }
      if (randType === 'lava') {
        tile.tileColor = '#ff6600';
      }
      if (randType === 'spawn') {
        tile.tileColor = '#00ff00';
        spawnAssigned = true;
      }
    }
  }

  if (!spawnAssigned && mapData.length && mapData[0].length) {
    mapData[0][0].tileType = 'spawn';
    mapData[0][0].tileColor = '#00ff00';
    mapData[0][0].collider = false;
  }

  const mapName = prompt("Enter a name for this randomized map:", "RandomMap");
  if (!mapName) {
    openModal("Randomization Canceled", "Randomized map was not saved.");
    renderEditorGrid();
    return;
  }
  if (maps[mapName]) {
    const overwrite = confirm(`Map "${mapName}" already exists. Overwrite?`);
    if (!overwrite) {
      openModal("Randomization Canceled", `Map "${mapName}" was not overwritten.`);
      renderEditorGrid();
      return;
    }
  }
  maps[mapName] = deepCopy(mapData);
  openModal("Random Map", `Map has been randomized and saved as "${mapName}".`);
  renderEditorGrid();
});

/****************************************************************
 * IMPORT
 ****************************************************************/
importButton.addEventListener('click', () => {
  const jsonStr = importInput.value.trim();
  if (!jsonStr) {
    openModal("Import Error", "No JSON to import!");
    return;
  }
  try {
    const loadedMap = JSON.parse(jsonStr);
    if (!Array.isArray(loadedMap) || !Array.isArray(loadedMap[0])) {
      openModal("Import Error", "JSON does not look like a 2D array!");
      return;
    }
    const colCount = loadedMap[0].length;
    for (let row of loadedMap) {
      if (!Array.isArray(row) || row.length !== colCount) {
        openModal("Import Error", "All rows must have the same number of columns!");
        return;
      }
    }
    for (let row of loadedMap) {
      for (let tile of row) {
        if (!validateTile(tile)) {
          openModal("Import Error", "One or more tiles contain invalid properties!");
          return;
        }
      }
    }
    const mapName = prompt("Enter a name for this imported map:", "ImportedMap");
    if (!mapName) {
      openModal("Import Canceled", "No map name provided.");
      return;
    }
    if (maps[mapName]) {
      const overwrite = confirm(`Map "${mapName}" already exists. Overwrite?`);
      if (!overwrite) {
        openModal("Import Canceled", `Map "${mapName}" was not overwritten.`);
        return;
      }
    }

    // Fix #1: only assign _unlocking for door_locked tiles
    const importedMap = loadedMap.map(row =>
      row.map(tile => ({
        ...tile,
        _iconChar: tile.tileType === 'door_locked' ? '█' : '',
        ...(tile.tileType === 'door_locked' ? { _unlocking: false } : {})
      }))
    );

    maps[mapName] = deepCopy(importedMap);
    mapData       = deepCopy(importedMap);
    currentMap    = mapData;

    rowsInput.value = mapData.length;
    colsInput.value = mapData[0].length;
    renderEditorGrid();
    setupMobileControls();
    openModal("Import Successful", `Map "${mapName}" imported successfully!`);
  } catch (err) {
    openModal("Import Error", `Error parsing JSON: ${err}`);
  }
});

/****************************************************************
 * EXPORT
 ****************************************************************/
exportButton.addEventListener('click', () => {
  // remove _iconChar & _unlocking
  const exportMap = mapData.map(row =>
    row.map(tile => {
      const { _iconChar, _unlocking, ...publicTile } = tile;
      return publicTile;
    })
  );
  const jsonString = JSON.stringify(exportMap, null, 2);
  exportOutput.textContent = jsonString;

  const now = new Date();
  const yyyy = now.getFullYear();
  const mm   = String(now.getMonth() + 1).padStart(2, '0');
  const dd   = String(now.getDate()).padStart(2, '0');
  const hh   = String(now.getHours()).padStart(2, '0');
  const min  = String(now.getMinutes()).padStart(2, '0');
  const ss   = String(now.getSeconds()).padStart(2, '0');
  const timestamp = `${yyyy}-${mm}-${dd}_${hh}-${min}-${ss}`;

  const fileName = `map_${timestamp}.json`;
  const blob = new Blob([jsonString], { type: 'application/json' });
  const url  = URL.createObjectURL(blob);
  const a    = document.createElement('a');
  a.href     = url;
  a.download = fileName;
  a.click();
  URL.revokeObjectURL(url);
});

/****************************************************************
 * RENDER EDITOR GRID
 ****************************************************************/
function renderEditorGrid() {
  showLoading();
  setTimeout(() => {
    mapGrid.innerHTML = '';

    const rows = mapData.length;
    const cols = rows > 0 ? mapData[0].length : 0;
    mapGrid.style.gridTemplateRows    = `repeat(${rows},32px)`;
    mapGrid.style.gridTemplateColumns = `repeat(${cols},32px)`;

    for (let r = 0; r < rows; r++) {
      for (let c = 0; c < cols; c++) {
        const tile = mapData[r][c];
        const cellDiv = document.createElement('div');
        cellDiv.dataset.row = r;
        cellDiv.dataset.col = c;
        cellDiv.title = `Row ${r}, Col ${c}`;
        cellDiv.style.backgroundColor = tile.tileColor;
        if (tile.tileType !== 'floor' && tile.tileType !== 'wall' && tile.tileType !== 'lava') {
          cellDiv.textContent = tileTypeToIcon(tile);
        }
        mapGrid.appendChild(cellDiv);
      }
    }
    hideSharedBorders();
    hideLoading();
  }, 40);
}

function tileTypeToIcon(tile) {
  if (tile.tileType === 'door_locked') {
    return tile._iconChar || '█';
  }
  switch (tile.tileType) {
    case 'spawn':        return '★';
    case 'stairs_up':    return '⇧';
    case 'stairs_down':  return '⇩';
    case 'chest':        return '☒';
    case 'hole':         return 'O';
    case 'arrow_up':     return '↑';
    case 'arrow_down':   return '↓';
    case 'arrow_left':   return '←';
    case 'arrow_right':  return '→';
    case 'treasure':     return '⬛';
    default:             return '';
  }
}

function hideSharedBorders() {
  const rows = mapData.length;
  if (!rows) return;
  const cols = mapData[0].length;
  const cells = mapGrid.querySelectorAll('div');

  function cellAt(rr, cc) { return cells[rr * cols + cc]; }

  cells.forEach(div => {
    div.style.border = '1px solid #444';
  });

  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      const tile = mapData[r][c];
      const currentDiv = cellAt(r, c);
      if (c < cols - 1) {
        const neighbor = mapData[r][c + 1];
        const neighborDiv = cellAt(r, c + 1);
        if (tile.collider && neighbor.collider) {
          currentDiv.style.borderRight = 'none';
          neighborDiv.style.borderLeft = 'none';
        }
      }
      if (r < rows - 1) {
        const neighbor = mapData[r + 1][c];
        const neighborDiv = cellAt(r + 1, c);
        if (tile.collider && neighbor.collider) {
          currentDiv.style.borderBottom = 'none';
          neighborDiv.style.borderTop   = 'none';
        }
      }
    }
  }
}

/****************************************************************
 * BRUSH & FLOOD FILL
 ****************************************************************/
function applyBrush(r, c) {
  const bSize = parseInt(brushSizeSelect.value, 10);
  const offset = Math.floor((bSize - 1) / 2);

  for (let rr = r - offset; rr <= r + offset; rr++) {
    for (let cc = c - offset; cc <= c + offset; cc++) {
      if (rr < 0 || cc < 0 || rr >= mapData.length || cc >= mapData[0].length) continue;
      const tile = mapData[rr][cc];
      if (currentTool === 'eraser') {
        tile.tileType     = 'floor';
        tile.tileColor    = '#ffffff';
        tile.collider     = false;
        tile.interactable = false;
        tile.label        = '';
      } else if (currentTool === 'paint') {
        setTileToCurrentSettings(tile);
      }
    }
  }
}

function floodFill(r, c) {
  const startTile = mapData[r][c];
  const tColor    = startTile.tileColor;
  const tType     = startTile.tileType;
  const tColl     = startTile.collider;
  const tIntr     = startTile.interactable;

  const stack = [[r, c]];
  const visited = new Set([`${r},${c}`]);

  while (stack.length) {
    const [rr, cc] = stack.pop();
    const tile = mapData[rr][cc];
    if (
      tile.tileColor === tColor &&
      tile.tileType === tType &&
      tile.collider === tColl &&
      tile.interactable === tIntr
    ) {
      setTileToCurrentSettings(tile);

      [[rr-1, cc],[rr+1, cc],[rr, cc-1],[rr, cc+1]].forEach(([nr, nc]) => {
        if (nr >= 0 && nr < mapData.length && nc >= 0 && nc < mapData[0].length) {
          const key = `${nr},${nc}`;
          if (!visited.has(key)) {
            visited.add(key);
            stack.push([nr, nc]);
          }
        }
      });
    }
  }
}

function setTileToCurrentSettings(tile) {
  tile.tileType     = tileTypeSelect.value;
  tile.interactable = interactableCheckbox.checked;
  tile.label        = labelInput.value.trim();
  tile.tileColor    = tileColorPicker.value;

  if (tile.tileType === 'wall' || tile.tileType === 'door_locked') {
    tile.collider = true;
  } else {
    tile.collider = colliderCheckbox.checked;
  }

  if (tile.tileType === 'lava') {
    tile.tileColor = '#ff6600';
  }
  if (tile.tileType === 'spawn') {
    tile.tileColor = '#00ff00';
  }

  if (tile.tileType === 'hole') {
    tile.holeTargetMap = holeTargetMapInput.value.trim();
    tile.holeTargetX   = parseInt(holeTargetXInput.value, 10) || 0;
    tile.holeTargetY   = parseInt(holeTargetYInput.value, 10) || 0;
    tile.holeDeath     = holeDeathCheckbox.checked;
  } else {
    tile.holeTargetMap = '';
    tile.holeTargetX   = 0;
    tile.holeTargetY   = 0;
    tile.holeDeath     = false;
  }

  if (tile.tileType !== 'door_locked') {
    tile._unlocking = false;
    tile._iconChar  = '';
  }

  const chosenEvent = eventTypeSelect.value.trim();
  if (chosenEvent) {
    tile.eventType = chosenEvent;
    tile.eventData = eventDataInput.value.trim();
  } else {
    tile.eventType = '';
    tile.eventData = '';
  }
}

/****************************************************************
 * UNDO
 ****************************************************************/
undoButton.addEventListener('click', () => {
  if (undoStack.length > 0) {
    mapData = undoStack.pop();
    renderEditorGrid();
    openModal("Undo", "Your last change has been undone.");
  } else {
    openModal("Undo", "No previous state to revert to!");
  }
});

/****************************************************************
 * LOAD GAME
 ****************************************************************/
loadGameButton.addEventListener('click', () => {
  const availableNames = Object.keys(maps);
  if (!availableNames.length) {
    openModal("No Maps", "No maps are stored yet. Generate or import a map first.");
    return;
  }
  const chosen = prompt(`Enter map name to load:\n${availableNames.join(', ')}`, "Default");
  if (!chosen || !maps[chosen]) {
    openModal("Load Error", `Map "${chosen}" does not exist!`);
    return;
  }
  undoStack = [];

  mapData = deepCopy(maps[chosen]);
  currentMap = mapData;

  setupKeyboardControls();
  setupMobileControls();

  let spawnFound = false;
  for (let r = 0; r < currentMap.length; r++) {
    for (let c = 0; c < currentMap[r].length; c++) {
      if (currentMap[r][c].tileType === 'spawn') {
        playerRow = r;
        playerCol = c;
        spawnFound = true;
        break;
      }
    }
    if (spawnFound) break;
  }
  if (!spawnFound) {
    playerRow = 0;
    playerCol = 0;
    currentMap[0][0].collider = false;
    currentMap[0][0].tileType = 'spawn';
    currentMap[0][0].tileColor = '#00ff00';
  }
  spawnEffectTime = 0;
  spawnEffectActive = true;

  renderEditorGrid();
  renderGameMap(currentMap);
  openModal("Load Successful", `Map "${chosen}" loaded successfully!`);
});

/****************************************************************
 * RENDER GAME MAP
 ****************************************************************/
function renderGameMap(data) {
  if (!data) return;
  ctx.clearRect(0, 0, gameCanvas.width, gameCanvas.height);

  const rows = data.length;
  const cols = rows > 0 ? data[0].length : 0;
  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      const tile = data[r][c];
      const x = c * 32;
      const y = r * 32;

      if (tile.tileType === 'lava') {
        ctx.fillStyle = '#ff6600';
      } else {
        ctx.fillStyle = tile.tileColor;
      }
      ctx.fillRect(x, y, 32, 32);

      if (tile.tileType !== 'floor' && tile.tileType !== 'wall' && tile.tileType !== 'lava') {
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.font = '14px "Press Start 2P", monospace';
        ctx.fillStyle = '#000';
        ctx.fillText(tileTypeToIcon(tile), x + 16, y + 16);
      }
      if (tile.label) {
        ctx.textAlign = 'left';
        ctx.textBaseline = 'top';
        ctx.font = '8px "Press Start 2P", monospace';
        ctx.fillStyle = '#000';
        ctx.fillText(tile.label, x + 2, y + 2);
      }
    }
  }
  drawPlayer();
  if (spawnEffectActive) {
    drawSpawnEffect();
  }
}

function drawPlayer() {
  const x = playerCol * 32 + 16;
  const y = playerRow * 32 + 16;
  ctx.fillStyle = '#f46290';
  ctx.font = '20px "Press Start 2P", monospace';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText('유', x, y);
}

function drawSpawnEffect() {
  const now = performance.now();
  if (spawnEffectTime === 0) {
    spawnEffectTime = now;
  }
  const elapsed = now - spawnEffectTime;
  const progress = elapsed / spawnEffectDuration;
  if (progress >= 1) {
    spawnEffectActive = false;
    return;
  }
  const centerX = (playerCol + 0.5) * 32;
  const centerY = (playerRow + 0.5) * 32;

  const steps = 50;
  ctx.save();
  ctx.strokeStyle = `rgba(0,0,0,${1 - progress})`;
  ctx.lineWidth = 2;
  ctx.beginPath();

  let angleMax = 4 * Math.PI;
  let radiusMax = 25;
  for (let i = 0; i <= steps; i++) {
    const t = i / steps;
    const angle = angleMax * t;
    const radius = radiusMax * t;
    const px = centerX + radius * Math.cos(angle);
    const py = centerY + radius * Math.sin(angle);
    if (i === 0) ctx.moveTo(px, py);
    else ctx.lineTo(px, py);
  }
  ctx.stroke();
  ctx.restore();

  requestAnimationFrame(() => renderGameMap(currentMap));
}

/****************************************************************
 * MOVEMENT & MOBILE
 ****************************************************************/
function setupKeyboardControls() {
  window.removeEventListener('keydown', handleSpaceKey);
  window.removeEventListener('keydown', handleMovement);
  window.removeEventListener('keydown', handleToolShortcuts);

  window.addEventListener('keydown', handleSpaceKey, { passive: false });
  window.addEventListener('keydown', handleMovement);
  window.addEventListener('keydown', handleToolShortcuts);
}

function handleSpaceKey(e) {
  if (e.code === 'Space') {
    e.preventDefault();
    jumpPending = true;
  }
}
function handleToolShortcuts(e) {
  switch (e.key.toLowerCase()) {
    case 'p': selectTool('paint');  break;
    case 'e': selectTool('eraser'); break;
    case 'f': selectTool('fill');   break;
  }
}
function handleMovement(e) {
  switch (e.key) {
    case 'ArrowUp':
    case 'w':
    case 'W':
      jumpPending ? tryJumpPlayer(-1, 0) : tryMovePlayer(-1, 0);
      break;
    case 'ArrowDown':
    case 's':
    case 'S':
      jumpPending ? tryJumpPlayer(1, 0) : tryMovePlayer(1, 0);
      break;
    case 'ArrowLeft':
    case 'a':
    case 'A':
      jumpPending ? tryJumpPlayer(0, -1) : tryMovePlayer(0, -1);
      break;
    case 'ArrowRight':
    case 'd':
    case 'D':
      jumpPending ? tryJumpPlayer(0, 1) : tryMovePlayer(0, 1);
      break;
  }
}

function setupMobileControls() {
  btnUp.removeEventListener('click', moveUp);
  btnDown.removeEventListener('click', moveDown);
  btnLeft.removeEventListener('click', moveLeft);
  btnRight.removeEventListener('click', moveRight);

  btnUp.addEventListener('click', moveUp);
  btnDown.addEventListener('click', moveDown);
  btnLeft.addEventListener('click', moveLeft);
  btnRight.addEventListener('click', moveRight);
}

function moveUp()    { jumpPending ? tryJumpPlayer(-1, 0) : tryMovePlayer(-1, 0); }
function moveDown()  { jumpPending ? tryJumpPlayer(1, 0) : tryMovePlayer(1, 0); }
function moveLeft()  { jumpPending ? tryJumpPlayer(0, -1) : tryMovePlayer(0, -1); }
function moveRight() { jumpPending ? tryJumpPlayer(0, 1)  : tryMovePlayer(0, 1); }

function tryMovePlayer(dR, dC) {
  if (!currentMap) return;
  const newR = playerRow + dR;
  const newC = playerCol + dC;
  if (!isInBounds(newR, newC)) {
    openModal("Move Blocked", "Cannot move outside map bounds.");
    return;
  }
  const tile = currentMap[newR][newC];
  if (tile.tileType === 'door_locked' && !tile._unlocking) {
    unlockDoor(newR, newC, tile);
    return;
  }
  if (tile.collider) {
    openModal("Move Blocked", "Tile is blocked!");
    return;
  }
  playerRow = newR;
  playerCol = newC;

  if (tile.tileType === 'lava') {
    openModal("GAME OVER", "You stepped into lava!");
    playerRow = 0;
    playerCol = 0;
    spawnEffectTime = 0;
    spawnEffectActive = true;
    renderGameMap(currentMap);
    return;
  }
  if (tile.tileType === 'hole') {
    const lethal = tile.holeDeath || !tile.holeTargetMap.trim();
    if (lethal) {
      openModal("DEATH", "You fell into a hole and died!");
      playerRow = 0;
      playerCol = 0;
      spawnEffectTime = 0;
      spawnEffectActive = true;
    } else {
      if (tile.holeTargetMap === "sameMap" || tile.holeTargetMap === "thisMap") {
        playerRow = tile.holeTargetY;
        playerCol = tile.holeTargetX;
      } else {
        // Fix #5: Teleport to different map
        teleportToMap(tile.holeTargetMap, tile.holeTargetX, tile.holeTargetY);
      }
    }
  }
  handleTileEvent(tile);
  renderGameMap(currentMap);
}

function tryJumpPlayer(dR, dC) {
  jumpPending = false;
  const skipR = playerRow + dR;
  const skipC = playerCol + dC;
  const landR = playerRow + 2 * dR;
  const landC = playerCol + 2 * dC;

  if (!isInBounds(skipR, skipC)) {
    openModal("Jump Blocked", "Can't jump outside the map.");
    return;
  }
  const skipTile = currentMap[skipR][skipC];
  if (skipTile.collider) {
    openModal("BUMP!", "You bumped into a wall/door and stayed put.");
    return;
  }
  if (!isInBounds(landR, landC)) {
    openModal("Jump Blocked", "No space to land!");
    return;
  }
  const landTile = currentMap[landR][landC];
  if (landTile.collider) {
    openModal("Jump Blocked", "Landing tile is blocked.");
    return;
  }

  playerRow = landR;
  playerCol = landC;

  if (landTile.tileType === 'lava') {
    openModal("GAME OVER", "You jumped right into lava!");
    playerRow = 0;
    playerCol = 0;
    spawnEffectTime = 0;
    spawnEffectActive = true;
    renderGameMap(currentMap);
    return;
  }
  if (landTile.tileType === 'hole') {
    const lethal = landTile.holeDeath || !landTile.holeTargetMap.trim();
    if (lethal) {
      openModal("DEATH", "You fell into a hole and died!");
      playerRow = 0;
      playerCol = 0;
      spawnEffectTime = 0;
      spawnEffectActive = true;
    } else {
      if (landTile.holeTargetMap === "sameMap" || landTile.holeTargetMap === "thisMap") {
        playerRow = landTile.holeTargetY;
        playerCol = landTile.holeTargetX;
      } else {
        // Fix #5: Teleport to different map
        teleportToMap(landTile.holeTargetMap, landTile.holeTargetX, landTile.holeTargetY);
      }
    }
  }
  handleTileEvent(landTile);
  renderGameMap(currentMap);
}

/****************************************************************
 * TILE EVENTS & TELEPORT
 ****************************************************************/
function handleTileEvent(tile) {
  if (tile.tileType === 'chest') {
    openModal("CHEST", "You found a chest!");
  }
  if (!tile.eventType) return;

  switch (tile.eventType) {
    case 'dialogue':
      openModal("DIALOGUE EVENT", tile.eventData || "No message provided.");
      break;
    case 'shop':
      openModal("SHOP EVENT", tile.eventData || "Open shop interface here.");
      break;
    case 'battle':
      openModal("BATTLE EVENT", tile.eventData || "A wild monster appears!");
      break;
    case 'teleport':
      try {
        const tData = JSON.parse(tile.eventData);
        if (!tData.targetMap) {
          openModal("TELEPORT ERROR", "No targetMap specified.");
          return;
        }
        if (tData.targetX === undefined || tData.targetY === undefined) {
          openModal("TELEPORT ERROR", "Missing targetX/targetY.");
          return;
        }
        teleportToMap(tData.targetMap, tData.targetX, tData.targetY);
      } catch (err) {
        openModal("TELEPORT ERROR", "Failed to parse teleport data.");
      }
      break;
    case 'stairs_up':
      const upstairsMap = prompt("Enter the name of the upstairs map:", "UpstairsMap");
      if (upstairsMap && maps[upstairsMap]) {
        teleportToMap(upstairsMap, 0, 0);
      } else {
        openModal("STAIRS UP ERROR", `Map "${upstairsMap}" does not exist or not provided.`);
      }
      break;
    case 'stairs_down':
      const downstairsMap = prompt("Enter the name of the downstairs map:", "DownstairsMap");
      if (downstairsMap && maps[downstairsMap]) {
        teleportToMap(downstairsMap, 0, 0);
      } else {
        openModal("STAIRS DOWN ERROR", `Map "${downstairsMap}" does not exist or not provided.`);
      }
      break;
    default:
      console.log(`Unhandled event: ${tile.eventType}`);
      break;
  }
}

function teleportToMap(targetMapName, targetX, targetY) {
  if (!maps[targetMapName]) {
    openModal("TELEPORT ERROR", `Map "${targetMapName}" does not exist.`);
    return;
  }
  const targetMap = maps[targetMapName];
  const maxRows   = targetMap.length;
  const maxCols   = targetMap[0].length;

  if (targetY < 0 || targetY >= maxRows || targetX < 0 || targetX >= maxCols) {
    openModal("TELEPORT ERROR", 
      `Target coords (${targetX},${targetY}) out of bounds for "${targetMapName}".`);
    return;
  }

  saveCurrentState(); // keep teleport in the undo stack

  mapData  = deepCopy(targetMap);
  currentMap = mapData;
  playerRow   = targetY;
  playerCol   = targetX;

  spawnEffectTime  = 0;
  spawnEffectActive= true;

  renderEditorGrid();
  renderGameMap(currentMap);

  // Fix #4: re-init controls after teleport
  setupKeyboardControls();
  setupMobileControls();

  openModal("TELEPORTED", `Teleported to "${targetMapName}"!`);
}

/****************************************************************
 * DOOR UNLOCK
 ****************************************************************/
function unlockDoor(r, c, tile) {
  if (tile._unlocking) return;
  const doorFadeStates = ['█','▓','▒','░'];
  let step = 0;
  tile._unlocking = true;
  tile._iconChar  = doorFadeStates[step];
  tile.collider   = true;

  const fadeSpeed = parseInt(doorFadeSpeedInput.value, 10) || 150;
  const fadeInterval = setInterval(() => {
    step++;
    if (step < doorFadeStates.length) {
      tile._iconChar = doorFadeStates[step];
      renderGameMap(currentMap);
    } else {
      clearInterval(fadeInterval);
      tile.tileType   = 'floor';
      tile.collider   = false;
      tile._unlocking = false;
      tile._iconChar  = '';

      playerRow = r;
      playerCol = c;
      renderGameMap(currentMap);
    }
  }, fadeSpeed);
}

/****************************************************************
 * MODAL SYSTEM
 ****************************************************************/
const modalOverlay  = document.getElementById('modalOverlay');
const modalContent  = document.getElementById('modalContent');
const modalTitle    = document.getElementById('modalTitle');
const modalMessage  = document.getElementById('modalMessage');
const modalCloseBtn = document.getElementById('modalCloseBtn');
let lastFocusedElement = null;

function openModal(title, message) {
  lastFocusedElement = document.activeElement;
  modalTitle.textContent   = title;
  modalMessage.textContent = message;
  modalOverlay.classList.add('active');
  modalCloseBtn.focus();
}
function closeModal() {
  modalOverlay.classList.remove('active');
  if (lastFocusedElement) {
    lastFocusedElement.focus();
  }
}
modalCloseBtn.addEventListener('click', closeModal);
modalOverlay.addEventListener('click', (e) => {
  if (e.target === modalOverlay) {
    closeModal();
  }
});
modalOverlay.addEventListener('keydown', (e) => {
  if (e.key === 'Tab') {
    e.preventDefault();
    modalCloseBtn.focus();
  } else if (e.key === 'Escape') {
    closeModal();
  }
});
</script>
</body>
</html>

