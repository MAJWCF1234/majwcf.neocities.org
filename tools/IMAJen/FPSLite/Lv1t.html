<!DOCTYPE html>
<html lang=en>
<head>
    <meta charset=utf-8>
    <title>Bunker FPS - Level 1 Enhanced</title>
    <meta name=viewport content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <link rel=preconnect href=https://fonts.googleapis.com>
    <link rel=preconnect href=https://fonts.gstatic.com crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel=stylesheet>
    <style>
        html,body{margin:0;padding:0;height:100%;overflow:hidden;background:#112;color:#fff;font-family:'Courier New',Courier,monospace}
        #mapCanvas{display:block;width:100vw;height:100vh;background:#334;cursor:none}

        .info{position:absolute;top:10px;left:10px;padding:8px 12px;background:#000b;border-radius:8px;z-index:1000;line-height:1.5;font-size:13px;pointer-events:none}
        .info strong{display:block;margin-bottom:4px;font-size:15px}
        .info div{margin-bottom:4px}
        .info .mobile-controls, .info .desktop-controls{display:none} body.mobile .info .mobile-controls{display:block} body:not(.mobile) .info .desktop-controls{display:block}
        @media (max-width:600px){.info{font-size:11px;padding:6px 8px} .info strong{font-size:13px}}

        .joystick-container{position:absolute;bottom:20px;width:120px;height:120px;border-radius:50%;background:#fff2;touch-action:none;user-select:none;-webkit-user-select:none;z-index:1001;display:none;box-shadow:0 0 10px #0006} #movementJoystick{left:30px}
        .joystick-knob{position:absolute;width:60px;height:60px;left:30px;top:30px;border-radius:50%;background:#fff6;transform:translate(0,0);pointer-events:none;transition:transform .1s}
        #fireButton,#jumpButton,#switchButton{position:absolute;right:30px;width:90px;height:50px;border-radius:8px;color:#fff;font-size:16px;display:none;align-items:center;justify-content:center;cursor:pointer;user-select:none;-webkit-user-select:none;touch-action:manipulation;z-index:1001;box-shadow:0 0 8px #0006;padding:5px;box-sizing:border-box;font-family:'Press Start 2P',Courier,monospace;line-height:1.2;text-align:center}
        #fireButton{bottom:100px;background:#f336;border:2px solid #f339}
        #jumpButton{bottom:40px;background:#fff4;border:2px solid #fff6}
        #switchButton{bottom:40px;background:#44f6;border:2px solid #44f9;font-size:12px; display: none !important;}
        #fireButton:active{background:#f339} #jumpButton:active{background:#fff6}
        body.mobile #movementJoystick, body.mobile #jumpButton, body.mobile #fireButton {display:flex}
        body.mobile #movementJoystick {display: block}

        #hud{position:absolute;top:10px;right:10px;background:#0008;padding:8px 12px;border-radius:5px;color:#fff;font-size:14px;text-align:right;z-index:1000;pointer-events:none}
        #hud-hp-label{display:flex;justify-content:flex-end;align-items:center;margin-bottom:2px}
        #hud-hp-value{margin-left:5px;min-width:30px;text-align:left}
        #hud-hp-bar-bg{width:100px;height:12px;background:#555;border:1px solid #888;margin-bottom:4px}
        #hud-hp-bar{height:100%;background:#0f0;width:100%;transition:width .2s ease-out,background .2s ease-out}
        #hud-ammo{display:flex;justify-content:flex-end;align-items:center;margin-top:4px;height:16px}
        #hud-ammo-value{margin-right:5px;min-width:30px;text-align:left}
        #hud-ammo-icons{display:flex;align-items:center}
        #hud-ammo-icons img{width:10px;height:16px;margin-left:2px;image-rendering:pixelated;object-fit:contain;transition:opacity .2s} #hud-ammo-icons img.empty{opacity:.3}

        #loadingOverlay{position:absolute;top:0;left:0;right:0;bottom:0;background:#000;color:#fff;display:flex;align-items:center;justify-content:center;flex-direction:column;z-index:2000;font-family:'Courier New',Courier,monospace;text-align:center}#loadingOverlay.hide{display:none}
        #instructions { display: none; }

        #message { position: absolute; bottom: 15%; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.7); color: #fff; padding: 10px 20px; border-radius: 5px; font-size: 16px; font-family: 'Press Start 2P', Courier, monospace; z-index: 1002; display: none; text-align: center; pointer-events: none; }

        #fadeOverlay {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background-color: #000;
            opacity: 0;
            pointer-events: none;
            z-index: 3000;
            transition: opacity 0.8s ease-in;
        }
        #fadeOverlay.active {
            opacity: 1;
            pointer-events: all;
        }

    </style>
</head>
<body>
    <canvas id=mapCanvas></canvas>
    <div id=loadingOverlay><h1>Load</h1><p id=loadingText>Init</p></div>
    <div id=fadeOverlay></div>

    <div class=info>
        <div class=desktop-controls><strong>Controls (Desktop):</strong><div>W/A/S/D: Move | Space: Jump | L Click: Shoot | Mouse: Look | R: Reload</div></div>
        <div class=mobile-controls><strong>Controls (Mobile):</strong><div>L Joy: Move | Top R: Shoot | Btm R: Jump</div></div>
    </div>

    <div id=movementJoystick class=joystick-container><div class=joystick-knob id=movementKnob></div></div>
    <button id=fireButton>FIRE</button>
    <button id=jumpButton>JUMP</button>
    <button id=switchButton>SWITCH<br>WPN</button>

    <div id=hud>
        <div id=hud-hp-label>HP:<span id=hud-hp-value>100</span></div>
        <div id=hud-hp-bar-bg><div id=hud-hp-bar></div></div>
        <div id=hud-ammo><span id=hud-ammo-value>50</span><div id=hud-ammo-icons></div></div>
    </div>

    <div id=message></div>

    <script src=https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js></script>
    <script src=https://unpkg.com/three@0.128.0/examples/js/controls/PointerLockControls.js></script>

<script>
// --- Constants and Variables ---
const TW=500,TH=500,TS=256,THS=25,CSZ=1,ISKC=.4,GTF=3,GWN=.6,GWX=1,GHN=1.2,GHX=1.6,GSN=.5,GSX=.8,BW=36,BD=24,BMH=14,BBH=16,BBOX=4,BBOZ=4,BCX=0,BCZ=-50,EW=BW*.4,ED=CSZ*15,ET=CSZ*10,DH=BBH*.6,DW=EW*.8,DTK=.6,DZOFB=.01;
const DOX=-DW/2,EBD=75,EHH=45;
const B_B=[{cx:BCX-15,cz:BCZ+10,r:10,h:2.8},{cx:BCX+16,cz:BCZ+8,r:12,h:3.5},{cx:BCX-18,cz:BCZ-10,r:9,h:2.2},{cx:BCX+20,cz:BCZ-12,r:11,h:3},{cx:BCX,cz:BCZ-18,r:8,h:1.8},{cx:BCX-22,cz:BCZ,r:7,h:2}];
const RHX=BCX,RHZ=BCZ-55,RHH=THS*1.3,RH_SX=4e-4,RH_SZ=7e-4,RH_EF=.9,RH_NF1=.035,RH_NA1=.15,RH_NF2=.09,RH_NA2=.08;

let M_SEN=.002, T_SEN=.006, GRAV=19.6;
let P_MAX_HP=100, P_DMG=25, P_MAX_A=50, A_PACK=20, B_PER_IND=10, MAX_A_IND=5;
let PSTL = { RT:4, FRM:19, W:350, H:200, DUR:.05, ANIM_DUR:.05*19 };
let BGGN = { RT:5, FRM:14, W:350, H:200, DUR:.045, ANIM_DUR:.045*14, DMG:35 };
let BH_SZ=0.1, BH_LIFE=30;

const DOOR_TRIGGER_DISTANCE = 3.5;
const DOOR_SPEED = 1.8;
const DOOR_FULLY_OPEN_OFFSET = 1.0;
const DOOR_SCALE = 0.5;
const SCALED_DW = DW * DOOR_SCALE;
const SCALED_DH = DH * DOOR_SCALE;
const DOOR_SLIDE_DISTANCE = (SCALED_DW * 0.5);

const KEYCARD_PICKUP_DIST = 2.5;
const MESSAGE_DISPLAY_TIME = 2.0;

const LEVEL_TRANSITION_FADE_DURATION = 800;
const LEVEL_TRANSITION_TARGET = 'level2.html';

// --- THREE.js Shortcuts ---
const {clamp:cl,lerp:lp,randFloat:rn}=THREE.MathUtils,{FrontSide:FS,DoubleSide:DS,BackSide:BS,RepeatWrapping:RW,ClampToEdgeWrapping:CE,NearestFilter:NF,sRGBEncoding:SE,EquirectangularReflectionMapping:ER}=THREE;
const {PI,max,min,sin,cos,exp,abs,sqrt,floor:flr}=Math;
const V=THREE.Vector3,MS=THREE.MeshStandardMaterial,MB=THREE.MeshBasicMaterial,CT=THREE.CanvasTexture,GP=THREE.Group,PG=THREE.PlaneGeometry,BG=THREE.BoxGeometry,SP=THREE.Sprite,SM=THREE.SpriteMaterial,BF=THREE.BufferGeometry,F32=Float32Array,M4=THREE.Matrix4,Q=THREE.Quaternion,E=THREE.Euler,B3=THREE.Box3, RC=THREE.Raycaster;
const ss=(t,n,x)=>{const v=cl( (t-n)/(x-n),0,1);return v*v*(3-2*v)},$=s=>document.getElementById(s);
const isMobile = ('ontouchstart' in window || navigator.maxTouchPoints > 0);

// --- Asset Map (Original + New) ---
const aM={
    'gg':'images/GRASS_1A.png','wd':'images/dirt.png','dm':'images/bigdoor23.png','sp':'images/sky.png',
    'cw':'images/concretewall.png','dft':'images/trim2.png','t1':'images/tree.png','t2':'images/tree1.png',
    't3':'images/tree2.png','t4':'images/tree3.png','g1':'images/grass1.png','g2':'images/grass2.png',
    'g3':'images/grass3.png','g4':'images/grass4.png','ik':'images/level1keycard.png',
    'kr':'images/keycardreader.png','fa1':'images/foresta1.png','fa2':'images/foresta2.png',
    'fa3':'images/foresta3.png','fa4':'images/foresta4.png','fa5':'images/foresta5.png','fa6':'images/foresta6.png',
    'hb': 'images/bullet.png', 'pi': 'images/gun.gif', 'pf': 'images/fire.png', 'bgi': 'images/biggun1.png',
    'bgf': 'images/biggun.png', 'bh': 'images/bullethole.png',
    // New textures added here:
    'iron': 'images/iron.png',
    'light': 'images/LIGHT_1B.png',
    'darkbricks': 'images/darkbricks.png',
    'darktiles': 'images/darktiles.png',
    'concrete3c': 'images/CONCRETE_3C.png'
};
const sW={1:'wd',6:'cw'},dK='dm',gK='gg',tK=['t1','t2','t3','t4'],rK=['g1','g2','g3','g4'],faK=['fa1','fa2','fa3','fa4','fa5','fa6'];

let wpns = {
    'p': { k:'p', i:'pi', f:'pf', fr:PSTL.FRM, w:PSTL.W, h:PSTL.H, dur:PSTL.DUR, ad:PSTL.ANIM_DUR, rt:PSTL.RT, dmg:P_DMG, iMat:null, fMat:null, geo:null },
    'b': { k:'b', i:'bgi', f:'bgf', fr:BGGN.FRM, w:BGGN.W, h:BGGN.H, dur:BGGN.DUR, ad:BGGN.ANIM_DUR, rt:BGGN.RT, dmg:BGGN.DMG, iMat:null, fMat:null, geo:null }
};

// --- Global Variables ---
let bD={bMY:0,bNX:0,bXX:0,bNZ:0,bXZ:0}, A={}, gM, dM, cM, iM, fM={t:[],r:[],fa:[]};
let ironM, lightM, darkBricksM, darkTilesM, concrete3cM; // Materials for new textures
let kL=new V(0, 0, 0);
let scn, cam, rnd, ldM, txL, ldO, ldT, tM, tG, rG, faG, bG, eG, tV=new V(), dFrM, kRdM, kRdTexM, pthM=null;
const _q=new Q(),_m4=new M4(),_vS=new V(1,1,1),_vP=new V(),_e=new E();
const colliders = [];
const doorDataArray = [];

let clock = new THREE.Clock();
let player = {
    height: 1.8, width: 0.5, depth: 0.5,
    speed: 8.0, turnSpeed: M_SEN,
    jumpVelocity: 6.0,
    velocity: new V(), direction: new V(),
    onGround: false, canJump: false,
    moveForward: false, moveBackward: false, moveLeft: false, moveRight: false,
    collider: new B3(),
    hp: P_MAX_HP, ammo: P_MAX_A,
    currentWeapon: 'p', hasBigGun: false,
    isFiring: false, fireAnimTime: 0, fireCurrentFrame: 0, fireFrameTime: 0, timeSinceLastShot: 1,
    shootRequested: false, jumpRequested: false,
    hasKeycard: false,
};
let controls;

let weaponViewModel = null, crosshairGroup = null, bulletHoles = [], bulletHoleTexture = null;
let pointerLocked = false;
let gameReady = false;
let moveJoystick = null, lookTouchId = null, lastLookX = 0;

let raycaster = new RC();
let tempPlayerCollider = new B3();
let tempCheckPos = new V();
let tempDirection = new V();

let hudElement, hpLabelElement, hpValueElement, hpBarElement, ammoElement, ammoValueElement, ammoIconsElement;
let jumpButtonElement, fireButtonElement, switchButtonElement;
let messageElement, fadeOverlayElement;

let keycardSprite = null;
let doorLeft = null;
let doorRight = null;
let doorLeftCollider = null;
let doorRightCollider = null;
let levelTransitionHole = null;
let levelTransitionTriggerZone = new B3();
let isTransitioning = false;

let messageDisplayTimer = 0;
let doorMessageCooldown = 0;

let doorCenterPosX = 0;
let doorCenterPosY = 0;
let doorCenterPosZ = 0;

// --- Loading Functions ---
const iLd=()=>{ldO=$("loadingOverlay");ldT=$("loadingText");txL=new THREE.TextureLoader(ldM=new THREE.LoadingManager(()=>{},(u,l,t)=>ldT.innerText=`Ld:${u.split('/').pop()}(${~~(l/t*100)}%)`,u=>ldT.innerText=`ERR:${u}`))}
const ldA=()=>{ldT.innerText="LdA...";const nS=['norm','hgt','ao','rough','metal'];return Promise.all(Object.keys(aM).map(k=>new Promise(r=>{txL.load(aM[k],t=>{t.magFilter=t.minFilter=NF;t.generateMipmaps=!1;if(!nS.some(s=>k.includes(s))&&!aM[k].endsWith('.gif')&&k!=='sp'&&k!=='pi'&&k!=='bgi'&&k!=='bgf'&&k!=='pf'&&k!=='light')t.encoding=SE;else if(k==='sp')t.encoding=SE; A[k]=t; if(k==='bh') bulletHoleTexture = t; r(); },()=>{const c=document.createElement('canvas');c.width=c.height=16;const x=c.getContext('2d');x.fillStyle='#F0F';x.fillRect(0,0,16,16);x.fillStyle='#000';x.fillRect(0,0,8,8);x.fillRect(8,8,8,8);const pt=new CT(c);pt.magFilter=pt.minFilter=NF;A[k]=pt; if(k==='bh') bulletHoleTexture = null; r();})}))) }

// --- Material Creation ---
const cMa=()=>{
    const c={side:FS}, cDS={side:DS}; // Add DoubleSide option
    const cX=(k,rx=1,ry=1,w=RW)=>{const t=A[k];if(!t||t instanceof CT)return null;const tc=t.clone();tc.wrapS=tc.wrapT=w;tc.repeat.set(rx,ry);tc.needsUpdate=!0;return tc};
    let tx;
    // Original materials
    gM=(tx=cX(gK,TW/GTF,TH/GTF))?new MS({map:tx,roughness:1,metalness:0,...c}):new MS({color:0x3a5f0b,...c});
    iM=(tx=cX(sW[1],EW/2,ED/2))?new MS({map:tx,roughness:.9,metalness:.1,...c}):new MS({color:0x8B4513,...c});
    cM=(tx=cX(sW[6], BW/3, BMH/3))?new MS({map:tx,roughness:.8,metalness:.1,...c}):new MS({color:0x808080,...c}); // Adjusted repeat
    dM=(tx=cX(dK,1,1,CE))?(A[dK].wrapS = A[dK].wrapT = CE, new MS({map:tx,roughness:.6,metalness:.4,...c})):new MS({color:0x555555,...c}); // Changed wrap to CE for door
    dFrM=(tx=cX('dft',1,1,CE))?new MS({map:tx,roughness:.7,metalness:.2,...c}):new MS({color:0xCD853F,roughness:.7,metalness:.2,...c});
    kRdM=new MS({color:0x444444,roughness:.3,metalness:.6,...c});
    kRdTexM=(tx=cX('kr',1,1,CE))?new MS({map:tx,roughness:.5,metalness:.5,...c}):null;
    // Foliage materials
    const cF=k=>(tx=A[k])&&!(tx instanceof CT)?new MB({map:tx,color:0xFFFFFF,transparent:!0,side:DS,alphaTest:.5}):new MB({color:0xff00ff,transparent:!0,opacity:.5});
    const cFa=k=>(tx=A[k])&&!(tx instanceof CT)?new MB({map:tx,color:0xFFFFFF,transparent:!0,side:FS,depthWrite:!1}):new MB({color:0x00ff00,transparent:!0,opacity:.5});
    fM={t:tK.map(cF),r:rK.map(cF),fa:faK.map(cFa)};
    // New materials
    ironM=(tx=cX('iron', 1, 5))?new MS({map:tx, roughness:0.4, metalness:0.9, ...c}):new MS({color:0x444444, roughness:0.4, metalness:0.9, ...c});
    lightM=(tx=cX('light'))?new MB({map:tx, color:0xFFFFFF, transparent: true, alphaTest: 0.1, ...cDS}):new MB({color:0xFFFF00, ...cDS}); // Basic material, double sided
    darkBricksM=(tx=cX('darkbricks', BW/5, BD/5))?new MS({map:tx, roughness:0.85, metalness:0.1, ...c}):new MS({color:0x332222, ...c});
    darkTilesM=(tx=cX('darktiles', BW/4, BMH/4))?new MS({map:tx, roughness:0.6, metalness:0.2, ...c}):new MS({color:0x2a2a2a, ...c});
    concrete3cM=(tx=cX('concrete3c', (BW+BBOX*2)/4, BBH/2))?new MS({map:tx, roughness:0.8, metalness:0.1, ...c}):new MS({color:0x999999, ...c});
}

// --- Weapon Setup Functions ---
function createWeaponMaterials() { for(let k in wpns){ let w=wpns[k], iT=A[w.i], fT=A[w.f]; if(!iT)console.warn(`Idle tex miss ${k}`); if(!fT)console.warn(`Fire tex miss ${k}`); w.iMat=new THREE.MeshBasicMaterial({map:iT, transparent:!0, depthTest:!1, side:DS, color:iT?0xffffff:0xff00ff}); if(iT)w.iMat.map.needsUpdate=!0; let fTC=fT?fT.clone():null; if(fTC){fTC.needsUpdate=!0; fTC.repeat.set(1/w.fr,1);} w.fMat=new THREE.MeshBasicMaterial({map:fTC, transparent:!0, depthTest:!1, side:DS, color:fTC?0xffffff:0xff00ff}); let gA=w.w/w.h, gVH=.42, gVW=gVH*gA; w.geo=new PG(gVW, gVH); }}
function setupViewModel(){ weaponViewModel && cam.remove(weaponViewModel); crosshairGroup && cam.remove(crosshairGroup); let wD=wpns[player.currentWeapon] || wpns['p']; if (!wD||!wD.geo||!wD.iMat){ console.error("Default weapon fail."); weaponViewModel=new THREE.Mesh(new PG(.1,.1), new MB({color:0xff00ff, side:DS})); } else { weaponViewModel=new THREE.Mesh(wD.geo, wD.iMat); } weaponViewModel.position.set(0.15,-.11,-.4); cam.add(weaponViewModel); crosshairGroup=new GP(); let cM=new MB({color:0x00ff00, transparent:!0, opacity:.7, depthTest:!1, side:DS}), dotGeo=new PG(.0015,.0015), dot=new THREE.Mesh(dotGeo, cM); dot.position.z=-0.5; crosshairGroup.add(dot); cam.add(crosshairGroup); switchWeapon(player.currentWeapon); }
function switchWeapon(key){ if (!wpns[key] || !weaponViewModel){console.warn(`No switch ${key}.`);return;} if(player.currentWeapon===key && !player.isFiring && weaponViewModel.material===wpns[key].iMat && weaponViewModel.geometry===wpns[key].geo) return; if(!wpns[key].geo || !wpns[key].iMat){console.warn(`Data miss ${key}.`); return;} let wData = wpns[key]; if(weaponViewModel.geometry !== wData.geo){ weaponViewModel.geometry.dispose(); weaponViewModel.geometry = wData.geo; } weaponViewModel.material = wData.iMat; player.isFiring=false; player.fireAnimTime=0; player.fireCurrentFrame=0; player.fireFrameTime=0; if(wData.fMat && wData.fMat.map) wData.fMat.map.offset.x=0; player.timeSinceLastShot = 1 / wData.rt; player.currentWeapon = key; updateHUD(); }

// --- World Building Functions ---
const addColliderFromMesh = (mesh, targetArray) => { const box=new B3(); box.setFromObject(mesh); targetArray.push(box); return box; };

const cB=()=>{ // Create Bunker - MODIFIED
    bG = new GP();
    const cx = BCX, cz = BCZ;
    const baseW = BW + BBOX * 2, baseD = BD + BBOZ * 2;
    const baseBottomY = 0;
    const baseTopY = baseBottomY + BBH;
    const mainTopY = baseTopY + BMH;

    bD = { bMY: baseBottomY, bNX: cx - baseW / 2, bXX: cx + baseW / 2, bNZ: cz - baseD / 2, bXZ: cz + baseD / 2 };

    // --- Base Mesh --- (Using CONCRETE_3C)
    const baseMesh = new THREE.Mesh(new BG(baseW, BBH, baseD), concrete3cM || cM); // Use new concrete texture
    baseMesh.position.set(cx, baseBottomY + BBH / 2, cz);
    baseMesh.updateMatrixWorld();
    addColliderFromMesh(baseMesh, colliders);
    baseMesh.castShadow = false; baseMesh.receiveShadow = true;
    bG.add(baseMesh);

    // --- Main Bunker Block --- (Using original concrete, will be overlaid)
    const mainMesh = new THREE.Mesh(new BG(BW, BMH, BD), cM); // Original concrete texture
    mainMesh.position.set(cx, baseTopY + BMH / 2, cz);
    mainMesh.updateMatrixWorld();
    addColliderFromMesh(mainMesh, colliders);
    mainMesh.castShadow = false; mainMesh.receiveShadow = true;
    bG.add(mainMesh);

    // --- Sloped Transition --- (Using Dark Bricks)
    const slopeGeom = new BF(), slopeTargetY = baseTopY + BMH / 4;
    const vertices = new F32([bD.bNX, baseTopY, bD.bXZ, bD.bXX, baseTopY, bD.bXZ, bD.bXX, baseTopY, bD.bNZ, bD.bNX, baseTopY, bD.bNZ, cx - BW / 2, slopeTargetY, cz + BD / 2, cx + BW / 2, slopeTargetY, cz + BD / 2, cx + BW / 2, slopeTargetY, cz - BD / 2, cx - BW / 2, slopeTargetY, cz - BD / 2]);
    const indices = [0, 1, 5, 0, 5, 4, 1, 2, 6, 1, 6, 5, 2, 3, 7, 2, 7, 6, 3, 0, 4, 3, 4, 7], uvs = new F32(vertices.length / 3 * 2);
    const uvScaleX = 1 / baseW, uvScaleZ = 1 / baseD;
    for (let i = 0; i < vertices.length / 3; i++) { const vx = vertices[i * 3], vz = vertices[i * 3 + 2]; uvs[i * 2] = (vx - bD.bNX) * uvScaleX; uvs[i * 2 + 1] = 1 - (vz - bD.bNZ) * uvScaleZ }
    slopeGeom.setAttribute('position', new THREE.BufferAttribute(vertices, 3)).setAttribute('uv', new THREE.BufferAttribute(uvs, 2)).setIndex(indices); slopeGeom.computeVertexNormals();
    const slopeMat = darkBricksM || cM; // Use dark bricks material
    const slopeMesh = new THREE.Mesh(slopeGeom, slopeMat);
    slopeMesh.castShadow = false; slopeMesh.receiveShadow = true;
    bG.add(slopeMesh);

    // --- ADDED: Iron Exoskeleton ---
    const ironFrame = new GP();
    const beamThickness = 0.5;
    const beamDepth = 0.6; // How far it sticks out
    const offset = 0.05; // Small gap from wall
    const mainHalfW = BW / 2;
    const mainHalfD = BD / 2;
    const mainY = baseTopY + BMH / 2;

    const beamGeoVert = new BG(beamThickness, BMH, beamDepth);
    const beamGeoHorizX = new BG(BW, beamThickness, beamDepth);
    const beamGeoHorizZ = new BG(beamDepth, beamThickness, BD);

    const addBeam = (geo, x, y, z, rx=0, ry=0, rz=0) => {
        const beam = new THREE.Mesh(geo, ironM);
        beam.position.set(cx + x, y, cz + z);
        beam.rotation.set(rx, ry, rz);
        beam.castShadow = true; beam.receiveShadow = true;
        beam.updateMatrixWorld();
        addColliderFromMesh(beam, colliders);
        ironFrame.add(beam);
    };

    // Vertical Beams (Corners)
    addBeam(beamGeoVert, -mainHalfW - offset, mainY, -mainHalfD - offset);
    addBeam(beamGeoVert, mainHalfW + offset, mainY, -mainHalfD - offset);
    addBeam(beamGeoVert, -mainHalfW - offset, mainY, mainHalfD + offset);
    addBeam(beamGeoVert, mainHalfW + offset, mainY, mainHalfD + offset);
    // Vertical Beams (Mid-sides - optional, adds complexity)
    addBeam(beamGeoVert, 0, mainY, -mainHalfD - offset);
    addBeam(beamGeoVert, 0, mainY, mainHalfD + offset);
    addBeam(beamGeoVert, -mainHalfW - offset, mainY, 0);
    addBeam(beamGeoVert, mainHalfW + offset, mainY, 0);


    // Horizontal Beams (Top/Bottom Edges)
    const topY = mainTopY + beamThickness / 2 + offset;
    const bottomY = baseTopY - beamThickness / 2 - offset;
    addBeam(beamGeoHorizX, 0, topY, -mainHalfD - offset);
    addBeam(beamGeoHorizX, 0, topY, mainHalfD + offset);
    addBeam(beamGeoHorizX, 0, bottomY, -mainHalfD - offset);
    addBeam(beamGeoHorizX, 0, bottomY, mainHalfD + offset);

    addBeam(beamGeoHorizZ, -mainHalfW - offset, topY, 0);
    addBeam(beamGeoHorizZ, mainHalfW + offset, topY, 0);
    addBeam(beamGeoHorizZ, -mainHalfW - offset, bottomY, 0);
    addBeam(beamGeoHorizZ, mainHalfW + offset, bottomY, 0);

    // Horizontal Beams (Middle - optional)
    addBeam(beamGeoHorizX, 0, mainY, -mainHalfD - offset);
    addBeam(beamGeoHorizX, 0, mainY, mainHalfD + offset);
    addBeam(beamGeoHorizZ, -mainHalfW - offset, mainY, 0);
    addBeam(beamGeoHorizZ, mainHalfW + offset, mainY, 0);

    bG.add(ironFrame);

    // --- ADDED: Small Lights ---
    const lightSize = 0.4;
    const lightGeo = new PG(lightSize, lightSize);
    const lightY = mainTopY - lightSize; // Near the top
    const lightOffset = 0.1; // How far from corner/edge

    const addLight = (x, y, z, lookAtX, lookAtY, lookAtZ) => {
        const lightMesh = new THREE.Mesh(lightGeo, lightM);
        lightMesh.position.set(cx + x, y, cz + z);
        lightMesh.lookAt(cx + lookAtX, lookAtY, cz + lookAtZ);
        lightMesh.castShadow = false; lightMesh.receiveShadow = false;
        bG.add(lightMesh); // Add directly to bunker group
    };

    // Example: Lights near top corners facing outwards
    addLight(-mainHalfW + lightOffset, lightY, -mainHalfD - beamDepth - offset*2, -mainHalfW * 1.1, lightY, -mainHalfD * 1.1); // Front-Left
    addLight(mainHalfW - lightOffset, lightY, -mainHalfD - beamDepth - offset*2, mainHalfW * 1.1, lightY, -mainHalfD * 1.1); // Front-Right
    addLight(-mainHalfW - beamDepth - offset*2, lightY, -mainHalfD + lightOffset, -mainHalfW * 1.1, lightY, -mainHalfD * 1.1); // Left-Front
    addLight(-mainHalfW - beamDepth - offset*2, lightY, mainHalfD - lightOffset, -mainHalfW * 1.1, lightY, mainHalfD * 1.1); // Left-Back


    scn.add(bG);
};

// --- Environment Creation (Mostly Unchanged) ---
const cE=()=>{const sX=A['sp'];if(sX&&!(sX instanceof CT)){sX.mapping=ER;sX.encoding=SE;sX.needsUpdate=!0;scn.background=sX;scn.environment=sX}else{scn.background=new THREE.Color(0x6a8699)}scn.fog=new THREE.Fog(0x6a8699,60,400);const tg=new PG(TW,TH,TS,TS);tg.rotateX(-PI/2);const p=tg.attributes.position;let tDX=BCX+DOX,pStartX=0,pEndX=0,pStartZ=0,pEndZ=0,pFloorY=0;if(bD?.bMY==0){pStartX=tDX-EW/2;pEndX=tDX+EW/2;pStartZ=bD.bXZ;pEndZ=pStartZ+ED;pFloorY=bD.bMY}const perturbationAmount=EW*.15,noiseFreq=.4;for(let i=0;i<p.count;i++){const vx=p.getX(i),vz=p.getZ(i);let baseCalculatedY=gBH(vx,vz),targetY=baseCalculatedY;if(bD?.bMY==0){const transStartX=bD.bNX-ET,transEndX=bD.bXX+ET,transStartZ=bD.bNZ-ET,transEndZ=bD.bXZ+ED+ET,bunkerBaseTopY=bD.bMY+BBH,blendDist=ET*3.5,moundHeightOffset=BBH*-.5,cornerBoostF=.2,cornerDist=ET*.8,sharpEdgeBD=2.5,sharpEdgeOffset=.05;let isInBunker=vx>=bD.bNX&&vx<=bD.bXX&&vz>=bD.bNZ&&vz<=bD.bXZ;let isInPath=!1;if(!isInBunker&&vz>=pStartZ&&vz<=pEndZ&&vx>=pStartX-perturbationAmount*1.5&&vx<=pEndX+perturbationAmount*1.5){const pathRelativeZ=vz-pStartZ,offset=sin(pathRelativeZ*noiseFreq)*perturbationAmount,currentHalfWidth=EW/2+abs(offset);if(abs(vx-tDX)<currentHalfWidth)isInPath=!0}if(isInPath){targetY=pFloorY}else if(isInBunker){targetY=bD.bMY-.1}else if(vx>=transStartX&&vx<=transEndX&&vz>=transStartZ&&vz<=transEndZ){let distBX=max(0,bD.bNX-vx,vx-bD.bXX),distBZ=max(0,bD.bNZ-vz,vz-bD.bXZ);let distPathX=0;if(vz>=pStartZ&&vz<=pEndZ)distPathX=max(0,pStartX-vx,vx-pEndX);let distPathZ=0;if(vz>pEndZ&&vx>=pStartX&&vx<=pEndX)distPathZ=vz-pEndZ;const distBEdge=max(distBX,distBZ,distPathX,distPathZ);if(distBEdge<blendDist){const wallBlendF=ss(1-cl(distBEdge/blendDist,0,1),0,1);let baseMoundTargetY=bunkerBaseTopY+moundHeightOffset;if(vz>bD.bNZ&&vz<bD.bXZ+cornerDist&&(vx<bD.bNX+cornerDist||vx>bD.bXX-cornerDist)){const cornerX=vx<BCX?bD.bNX:bD.bXX,cornerZ=bD.bXZ,distToCorner=sqrt((vx-cornerX)**2+(vz-cornerZ)**2);if(distToCorner<cornerDist*1.2){baseMoundTargetY+=BBH*.5*cornerBoostF*ss(1-cl(distToCorner/(cornerDist*1.2),0,1),0,1)}}let blobHeightAddition=0;for(const blob of B_B){const dxBlob=vx-blob.cx,dzBlob=vz-blob.cz,distSqBlob=dxBlob*dxBlob+dzBlob*dzBlob,radiusSq=blob.r*blob.r;if(distSqBlob<radiusSq){const distBlob=sqrt(distSqBlob);blobHeightAddition+=ss(1-distBlob/blob.r,0,1)*blob.h}}targetY=lp(baseCalculatedY,baseMoundTargetY+blobHeightAddition,wallBlendF)}if(distBEdge<sharpEdgeBD)targetY=lp(targetY,bunkerBaseTopY+sharpEdgeOffset,ss(1-distBEdge/sharpEdgeBD,0,1))}}p.setY(i,targetY)}p.needsUpdate=!0;tg.computeVertexNormals();tM=new THREE.Mesh(tg,gM);tM.receiveShadow=true; tM.castShadow=false; scn.add(tM); if(bG){ bG.children.forEach(child=>{if(child.isMesh)child.receiveShadow=true;});} if(pthM?.parent)pthM.parent.remove(pthM);if(bD?.bMY==0&&iM&&ED>0&&EW>0){const pW=EW,pD=ED,tpX=tDX,tpZ=pStartZ+pD/2;const pathWidthSegments=10,pathHeightSegments=max(4,flr(pD/1.5));const pG=new PG(pW,pD,pathWidthSegments,pathHeightSegments);pG.rotateX(-PI/2);const pathPos=pG.attributes.position,halfPW=pW/2,edgeThreshold=.1;for(let i=0;i<pathPos.count;i++){const x=pathPos.getX(i),z=pathPos.getZ(i);if(abs(x-halfPW)<edgeThreshold||abs(x+halfPW)<edgeThreshold){const offset=sin(z*noiseFreq+rn(-.5,.5))*perturbationAmount*rn(.6,1.1);let newX=x+offset;newX=x>0?max(x*.1,newX):min(x*.1,newX);pathPos.setX(i,newX)}}pathPos.needsUpdate=!0;pG.computeVertexNormals();const pathMat=iM.clone();if(pathMat.map?.isTexture){pathMat.map=pathMat.map.clone();pathMat.map.repeat.set(pW/3,pD/3);pathMat.map.needsUpdate=!0}pthM=new THREE.Mesh(pG,pathMat);pthM.position.set(tpX,pFloorY+.02,tpZ);pthM.receiveShadow=true; pthM.castShadow=false; scn.add(pthM)} const bp=new PG(1,1);tG=new GP();const tb=12,tv=4,tw=6,twv=2;const tP=[{x:-30,z:-70},{x:35,z:-80},{x:10,z:-95},{x:-25,z:-110},{x:40,z:-60},{x:-60,z:-90},{x:70,z:-120},{x:-100,z:-150},{x:120,z:-80},{x:0,z:-140},{x:-150,z:-100},{x:150,z:-180},{x:50,z:-200},{x:-80,z:-170},{x:180,z:-130},{x:-190,z:-160},{x:-120,z:-210},{x:100,z:-230},{x:20,z:-160},{x:-45,z:-145},{x:80,z:-100},{x:-90,z:-190}];tP.forEach(s=>{const isBnk=bD.bMY==0&&s.x>=bD.bNX&&s.x<=bD.bXX&&s.z>=bD.bNZ&&s.z<=bD.bXZ;const isPth=pFloorY==0&&s.x>=pStartX-perturbationAmount*1.2&&s.x<=pEndX+perturbationAmount*1.2&&s.z>=pStartZ&&s.z<=pEndZ;if(isBnk||isPth)return;const y=gFH(s.x,s.z);if(y<-1||y>max(EHH*.8,RHH*.9))return;const h=tb+rn(0,tv),w=tw+rn(0,twv);const m=fM.t[~~rn(0,fM.t.length)];if(!m)return;const mh=new THREE.Mesh(bp,m);mh.scale.set(w,h,1);mh.position.set(s.x,y+h/2-.2,s.z);mh.castShadow=true; mh.receiveShadow=false; mh.onBeforeRender=()=>{tV.setFromMatrixPosition(cam.matrixWorld);mh.lookAt(tV.x,mh.position.y+1,tV.z)};tG.add(mh)});scn.add(tG);rG=new GP();const nG=850,gP=5,gS=4,mxInst=nG*gP*3;if(fM.r[0]){const gMat=fM.r[0];const instM=new THREE.InstancedMesh(bp,gMat,mxInst);instM.castShadow=false; instM.receiveShadow=true; let instCt=0;const rotY1=1.047+rn(-.45,.45),rotY2=-1.047+rn(-.45,.45);for(let i=0;i<nG;i++){const cX=rn(-TW*.45,TW*.45),cZ=rn(TH*-.9,TH*.45);const isBnk=bD.bMY==0&&cX>=bD.bNX&&cX<=bD.bXX&&cZ>=bD.bNZ&&cZ<=bD.bXZ;const isPth=pFloorY==0&&cX>=pStartX-perturbationAmount*1.2&&cX<=pEndX+perturbationAmount*1.2&&cZ>=pStartZ&&cZ<=pEndZ;if(isBnk||isPth)continue;const cY=gFH(cX,cZ);if(cY<-.5||cY>max(EHH*.7,RHH*.8)||isNaN(cY))continue;for(let j=0;j<gP;j++){if(instCt>=mxInst)break;const w=rn(GWN,GWX),h=w*rn(GHN,GHX),s=rn(GSN,GSX);const pX=cX+rn(-gS*.25,gS*.25),pZ=cZ+rn(-gS*.25,gS*.25),pY=cY+h*s/2-.1;const scX=w*s,scY=h*s;_vS.set(scX,scY,1);_vP.set(pX,pY,pZ);_e.set(0,0,0);_q.setFromEuler(_e);_m4.compose(_vP,_q,_vS);instM.setMatrixAt(instCt++,_m4);if(instCt>=mxInst)break;_e.set(0,rotY1,0);_q.setFromEuler(_e);_m4.compose(_vP,_q,_vS);instM.setMatrixAt(instCt++,_m4);if(instCt>=mxInst)break;_e.set(0,rotY2,0);_q.setFromEuler(_e);_m4.compose(_vP,_q,_vS);instM.setMatrixAt(instCt++,_m4);}if(instCt>=mxInst)break;}instM.count=instCt;instM.instanceMatrix.needsUpdate=!0;rG.add(instM);}scn.add(rG);faG=new GP();const farZ=-TH/2+5,sideX=TW/2-5,placementDepth=50,billboardYOffset=-1.5,billboardYOffsetVar=1;const numForestStrips=35,treeStripW=55,treeStripWV=20,treeStripH=18,treeStripHV=6,bushStripW=22,bushStripWV=8,bushStripH=7,bushStripHV=3;for(let i=0;i<numForestStrips;i++){let x,z,rotY=0,isBush=!1;const matIndex=~~rn(0,fM.fa.length),textureKey=faK[matIndex],forestMat=fM.fa[matIndex];if(!forestMat)continue;if(textureKey==='fa3'||textureKey==='fa6')isBush=!0;const zone=rn(0,3);if(zone<1.5){x=rn(-TW*.5,TW*.5);z=farZ+rn(0,placementDepth);rotY=rn(-.1,.1)}else if(zone<2.25){x=-sideX-rn(0,placementDepth);z=rn(-TH*.5,farZ*.5);rotY=PI/2+rn(-.15,.15)}else{x=sideX+rn(0,placementDepth);z=rn(-TH*.5,farZ*.5);rotY=-PI/2+rn(-.15,.15)}const y=gFH(x,z);if(y<3||isNaN(y))continue;let w,h,yOff;if(isBush){w=bushStripW+rn(-bushStripWV,bushStripWV);h=bushStripH+rn(-bushStripHV,bushStripHV);yOff=billboardYOffset*.5+rn(-billboardYOffsetVar*.5,billboardYOffsetVar*.5)}else{w=treeStripW+rn(-treeStripWV,treeStripWV);h=treeStripH+rn(-treeStripHV,treeStripHV);yOff=billboardYOffset+rn(-billboardYOffsetVar,billboardYOffsetVar)}const faMesh=new THREE.Mesh(bp,forestMat);faMesh.scale.set(w,h,1);faMesh.position.set(x,y+h/2+yOff,z);faMesh.rotation.y=rotY;faMesh.castShadow=false; faMesh.receiveShadow=true; faMesh.renderOrder=-1;faG.add(faMesh)}const numDistantTrees=150,distantTreeBH=18,distantTreeHV=5,distantTreeBW=5,distantTreeWV=2,distantTreeYO=-.5;for(let i=0;i<numDistantTrees;i++){let x,z;const zone=rn(0,3);if(zone<1.8){x=rn(-TW*.5,TW*.5);z=farZ+rn(5,placementDepth+10)}else if(zone<2.4){x=-sideX-rn(5,placementDepth+10);z=rn(-TH*.5,farZ*.6)}else{x=sideX+rn(5,placementDepth+10);z=rn(-TH*.5,farZ*.6)}const y=gFH(x,z);if(y<4||isNaN(y))continue;const matIndex=~~rn(0,fM.t.length),treeMat=fM.t[matIndex];if(!treeMat)continue;const h=distantTreeBH+rn(0,distantTreeHV),w=distantTreeBW+rn(0,distantTreeWV);const treeMesh=new THREE.Mesh(bp,treeMat);treeMesh.scale.set(w,h,1);treeMesh.position.set(x,y+h/2+distantTreeYO,z);treeMesh.castShadow=true; treeMesh.receiveShadow=false; treeMesh.renderOrder=-1;treeMesh.onBeforeRender=()=>{tV.setFromMatrixPosition(cam.matrixWorld);treeMesh.lookAt(tV.x,treeMesh.position.y+1,tV.z)};faG.add(treeMesh)}scn.add(faG)};

const cEn=()=>{ // Create Entrance - Unchanged Logic, only positioning relative to cB
    eG=new GP();
    if(!bD||bD.bMY!=0)return;

    const halfScaledDW = SCALED_DW / 2;

    doorCenterPosX = BCX + DOX; // Use constant BCX
    doorCenterPosZ = bD.bXZ + DZOFB + DTK / 2; // Position relative to bunker base Z extent
    doorCenterPosY = bD.bMY + (SCALED_DH / 2); // Position relative to bunker base Y

    const doorHalfGeo = new BG(halfScaledDW, SCALED_DH, DTK);

    const doorMat = dM || new MS({color:0x555555});
    const leftMat = doorMat.clone();
    if (leftMat.map && leftMat.map.isTexture) {
        leftMat.map = leftMat.map.clone();
        leftMat.map.repeat.set(0.5, 1);
        leftMat.map.offset.set(0, 0);
        leftMat.map.needsUpdate = true;
    }
    const rightMat = doorMat.clone();
    if (rightMat.map && rightMat.map.isTexture) {
        rightMat.map = rightMat.map.clone();
        rightMat.map.repeat.set(0.5, 1);
        rightMat.map.offset.set(0.5, 0);
        rightMat.map.needsUpdate = true;
    }

    const doorLeftMesh = new THREE.Mesh(doorHalfGeo, leftMat);
    const doorRightMesh = new THREE.Mesh(doorHalfGeo, rightMat);
    doorLeft = doorLeftMesh;
    doorRight = doorRightMesh;

    const leftClosedX = doorCenterPosX - halfScaledDW / 2;
    const rightClosedX = doorCenterPosX + halfScaledDW / 2;
    doorLeftMesh.position.set(leftClosedX, doorCenterPosY, doorCenterPosZ);
    doorRightMesh.position.set(rightClosedX, doorCenterPosY, doorCenterPosZ);
    doorLeftMesh.updateMatrixWorld();
    doorRightMesh.updateMatrixWorld();

    const doorLeftBox = addColliderFromMesh(doorLeftMesh, colliders);
    const doorRightBox = addColliderFromMesh(doorRightMesh, colliders);
    doorLeftCollider = doorLeftBox;
    doorRightCollider = doorRightBox;

    const doorData = {
        type: 'sliding',
        meshLeft: doorLeftMesh, meshRight: doorRightMesh,
        colliderLeft: doorLeftBox, colliderRight: doorRightBox,
        worldX: doorCenterPosX, worldZ: doorCenterPosZ,
        state: 'closed', offset: 0.0,
        originalLeftX: leftClosedX, originalRightX: rightClosedX,
        requiresKeycard: true, keycardActivated: false,
        collidersActive: true
    };
    doorDataArray.push(doorData);

    doorLeftMesh.castShadow = doorRightMesh.castShadow = true;
    doorLeftMesh.receiveShadow = doorRightMesh.receiveShadow = true;
    eG.add(doorLeftMesh);
    eG.add(doorRightMesh);

    // Use darkTilesM for the door frame trim for variety
    addDrFrm(doorCenterPosX, doorCenterPosY, doorCenterPosZ, SCALED_DW, SCALED_DH, DTK, darkTilesM || dFrM);
    addKcRd(doorCenterPosX, doorCenterPosY, doorCenterPosZ, SCALED_DW, SCALED_DH, DTK);

    scn.add(eG);

    createLevelTransitionHoleAndTrigger();
};

const createLevelTransitionHoleAndTrigger = () => { // Unchanged
    const holeWidth = SCALED_DW;
    const holeHeight = SCALED_DH;
    const holeDepth = 1.0;
    const holePosX = doorCenterPosX;
    const holePosY = doorCenterPosY;
    const holePosZ = doorCenterPosZ - (DTK / 2) - (holeDepth / 2) - 0.05;

    const holeGeometry = new BG(holeWidth, holeHeight, holeDepth);
    const holeMaterial = new MB({ color: 0x000000, side: DS });
    levelTransitionHole = new THREE.Mesh(holeGeometry, holeMaterial);
    levelTransitionHole.position.set(holePosX, holePosY, holePosZ);
    levelTransitionHole.castShadow = false;
    levelTransitionHole.receiveShadow = false;
    levelTransitionHole.visible = true;
    scn.add(levelTransitionHole);
    console.log("Level transition VISUAL HOLE created at:", levelTransitionHole.position);

    const triggerWidth = SCALED_DW * 1.1;
    const triggerHeight = SCALED_DH * 1.1;
    const triggerDepth = 1.5;
    const triggerPosX = doorCenterPosX;
    const triggerPosY = doorCenterPosY;
    const triggerCenterZ = doorCenterPosZ + triggerDepth / 2 + 0.2; // Slightly behind the door visual

    const triggerCenter = new V(triggerPosX, triggerPosY, triggerCenterZ);
    const triggerSize = new V(triggerWidth, triggerHeight, triggerDepth);
    levelTransitionTriggerZone.setFromCenterAndSize(triggerCenter, triggerSize);

    console.log("Level transition TRIGGER ZONE defined at center:", triggerCenter, "size:", triggerSize);
    console.log("Trigger Zone bounds:", levelTransitionTriggerZone.min, levelTransitionTriggerZone.max);

};

// Modified to accept a material
const addDrFrm=(tDX, doorCenterY, dZ, doorW, doorH, doorTh, frameMat = dFrM)=>{
    if(!frameMat) frameMat = dFrM || new MS({color:0xCD853F}); // Fallback
    const trmW=CSZ*.25;
    const trmD=.25;
    const frameCenterZ=bD.bXZ+trmD/2; // Place frame on the front face of the bunker base
    const addF=(w,h,x,y)=>{
        const m=new THREE.Mesh(new BG(w, h, trmD), frameMat);
        m.position.set(x, y, frameCenterZ);
        m.updateMatrixWorld();
        addColliderFromMesh(m, colliders);
        m.castShadow=true;
        m.receiveShadow=true;
        eG.add(m);
    };
    // Top frame part
    addF(doorW + 2 * trmW, trmW, tDX, doorCenterY + doorH / 2 + trmW / 2);
    // Side frame parts
    const sideH = doorH + trmW; // Make sides connect to top frame
    addF(trmW, sideH, tDX - doorW / 2 - trmW / 2, doorCenterY - trmW / 2); // Adjusted Y pos
    addF(trmW, sideH, tDX + doorW / 2 + trmW / 2, doorCenterY - trmW / 2); // Adjusted Y pos
};


const addKcRd=(tDX, doorCenterY, dZ, doorW, doorH, doorTh)=>{ // Unchanged
    const readerMat=kRdTexM||kRdM;
    if(!readerMat)return;
    const rW=.15,rH=.2,rD=.03;
    const trmW=CSZ*.25,trmD=.25,rOff=.05;
    // Position reader relative to the right door frame part
    const rX = tDX + doorW / 2 + trmW / 2 + rOff + rD / 2; // X position next to the right frame side
    const rY = doorCenterY;
    const frameFrontZ=bD.bXZ+trmD; // Z position same as frame front face
    const rZ=frameFrontZ-rW/2; // Place it centered depth-wise on the frame surface
    const readerMesh=new THREE.Mesh(new BG(rD, rH, rW), readerMat); // D W H swapped to orient correctly
    readerMesh.position.set(rX, rY, rZ);
    // No rotation needed if BG dimensions are correct for orientation
    readerMesh.updateMatrixWorld();
    addColliderFromMesh(readerMesh, colliders);
    readerMesh.castShadow=true;
    readerMesh.receiveShadow=true;
    eG.add(readerMesh);
};

const sS=(d,i=!1)=>{ // Create Sprite - Unchanged
    const tx=A[d.textureKey];if(!tx||tx instanceof CT)return;
    const p=d.worldPos.clone(),bO=.2,fY=bD.bMY;
    let groundY = tM ? gFH(p.x, p.z) : (bD ? bD.bMY : 0);
    // Ensure groundY is a number before adding
    if (typeof groundY !== 'number' || isNaN(groundY)) {
        console.warn(`Invalid ground height ${groundY} at (${p.x}, ${p.z}) for sprite ${d.textureKey}. Using 0.`);
        groundY = 0;
    }
    p.y = groundY + bO;

    const m=new SM({map:tx.clone(),transparent:!0,depthTest:!0,depthWrite:!0,sizeAttenuation:!0,alphaTest:.1});
    m.map.needsUpdate=!0;
    const s=new SP(m);s.position.copy(p);s.scale.set(ISKC,ISKC,ISKC);s.renderOrder=1; s.castShadow = true;
    scn.add(s);
    if (d.textureKey === 'ik') { keycardSprite = s; }
}

// --- Terrain Height Functions (Unchanged) ---
const gBH=(x,z)=>{const s=.009,a=THS,hcx1=BCX,hcz1=BCZ-15,dx1_b=x-hcx1,dz1_b=z-hcz1,d2_1_b=dx1_b*dx1_b*6e-4+dz1_b*dz1_b*3e-4,mH1=exp(-d2_1_b*1.2)*(a*.05);const hcx2=TW*.3,hcz2=TH*-.4,dx2_g=x-hcx2,dz2_g=z-hcz2,d2_2_g=dx2_g*dx2_g*2e-4+dz2_g*dz2_g*2e-4,mH2=exp(-d2_2_g*.8)*(a*.6);const hcx3=TW*-.35,hcz3=TH*-.6,dx3_g=x-hcx3,dz3_g=z-hcz3,d2_3_g=dx3_g*dx3_g*3e-4+dz3_g*dz3_g*2.5e-4,mH3=exp(-d2_3_g)*(a*.5);const baseNoiseAmp=a*.22,h1=sin(x*s*1.1+z*s*.4)*.3,h2=cos(x*s*.6-z*s*1.3)*.2,h3=sin(x*s*2.5+z*s*2.1)*.1;const s2=.025,h4=sin(x*s2*.8-z*s2*.5)*.15,h5=cos(x*s2*1.5+z*s2*1.1)*.1;const s3=.003,h6=cos(x*s3*1.2+z*s3*.9)*.4;const noiseH=(h1+h2+h3+h4+h5+h6)*baseNoiseAmp;const dx_rh=x-RHX,dz_rh=z-RHZ,d2_rh=dx_rh*dx_rh*RH_SX+dz_rh*dz_rh*RH_SZ,baseRearHillH=exp(-d2_rh*RH_EF)*RHH;const hillNoise1=sin(x*RH_NF1+z*RH_NF1*.6)*RH_NA1,hillNoise2=cos(x*RH_NF2*.7+z*RH_NF2)*RH_NA2;const totalHillNoiseFactor=1+hillNoise1+hillNoise2,rearHillH=max(0,baseRearHillH*totalHillNoiseFactor);const baseH=mH1+mH2+mH3+noiseH+rearHillH;let edgeHeightIncrease=0;const halfW=TW/2,halfH=TH/2,minDistToEdge=min(x+halfW,halfW-x,z+halfH,halfH-z);if(minDistToEdge<EBD){const blendFactor=1-cl(minDistToEdge/EBD,0,1),smoothBlend=ss(blendFactor,0,1),edgeHillModulation=cl(1-rearHillH/RHH*.5,.5,1);edgeHeightIncrease=smoothBlend*EHH*edgeHillModulation}return baseH+edgeHeightIncrease}
const gFH=(x,z)=>{if(!tM)return gBH(x,z);const g=tM.geometry,pa=g.attributes.position;if(!pa)return 0;const ws=g.parameters.widthSegments,hs=g.parameters.heightSegments,tw=g.parameters.width,th=g.parameters.height;const gx=(x+tw/2)/tw,gz=(z+th/2)/th;if(gx<0||gx>1||gz<0||gz>1)return gBH(x,z); const cgx=cl(gx,0,1),cgz=cl(gz,0,1);const xi=flr(cgx*ws),zi=flr(cgz*hs); const v=(iz,ix)=>min(iz*(ws+1)+ix,pa.count-1);const i0=v(zi,xi),i1=v(zi,xi+1),i2=v(zi+1,xi),i3=v(zi+1,xi+1);if(i0>=pa.count||i1>=pa.count||i2>=pa.count||i3>=pa.count||i0<0||i1<0||i2<0||i3<0)try{return pa.getY(cl(v(zi,xi),0,pa.count-1))}catch{return 0}const y0=pa.getY(i0),y1=pa.getY(i1),y2=pa.getY(i2),y3=pa.getY(i3),tx=cgx*ws-xi,tz=cgz*hs-zi;return lp(lp(y0,y1,tx),lp(y2,y3,tx),tz)}

// --- Input and Interaction Logic (Unchanged) ---
function setupInputListeners() {
    hudElement=$('hud'); hpLabelElement=$('hud-hp-label'); hpValueElement=$('hud-hp-value'); hpBarElement=$('hud-hp-bar');
    ammoElement=$('hud-ammo'); ammoValueElement=$('hud-ammo-value'); ammoIconsElement=$('hud-ammo-icons');
    jumpButtonElement=$('jumpButton'); fireButtonElement=$('fireButton'); switchButtonElement=$('switchButton');
    messageElement = $('message');
    fadeOverlayElement = $('fadeOverlay');

    document.addEventListener('keydown', e=>{ if(!gameReady || isTransitioning)return; switch(e.code){
        case 'KeyW': player.moveForward=true; break;
        case 'KeyA': player.moveLeft=true; break;
        case 'KeyS': player.moveBackward=true; break;
        case 'KeyD': player.moveRight=true; break;
        case 'Space': if(!player.jumpRequested) player.jumpRequested=true; break;
        case 'KeyR': player.ammo=P_MAX_A; updateHUD(); break;
    }});
    document.addEventListener('keyup', e=>{ if(!gameReady) return; switch(e.code){
        case 'KeyW': player.moveForward=false; break;
        case 'KeyA': player.moveLeft=false; break;
        case 'KeyS': player.moveBackward=false; break;
        case 'KeyD': player.moveRight=false; break;
        case 'Space': player.jumpRequested=false; break;
    }});
    rnd.domElement.addEventListener('mousedown', e=>{ if(e.button===0&&!isMobile){ if(gameReady&&!pointerLocked) controls.lock(); else if(gameReady&&pointerLocked && !isTransitioning) player.shootRequested=true; }});
    rnd.domElement.addEventListener('mouseup', e=>{if(e.button===0) player.shootRequested=false;});

    rnd.domElement.addEventListener('touchstart', handleTouchStartLook, {passive:!1});
    rnd.domElement.addEventListener('touchmove', handleTouchMoveLook, {passive:!1});
    rnd.domElement.addEventListener('touchend', handleTouchEndLook, {passive:!1});
    rnd.domElement.addEventListener('touchcancel', handleTouchEndLook, {passive:!1});

    if(isMobile){
        document.body.classList.add('mobile');
        let joyContainer=document.getElementById('movementJoystick'), joyKnob=document.getElementById('movementKnob');
        if(joyContainer&&joyKnob) moveJoystick=new Joy(joyContainer,joyKnob); else console.error("Joystick elements not found!");
        if(jumpButtonElement){ jumpButtonElement.addEventListener('touchstart', e=>{if(gameReady && !isTransitioning){e.preventDefault();player.jumpRequested=true;}},{passive:!1}); jumpButtonElement.addEventListener('touchend', e=>{if(gameReady){e.preventDefault();player.jumpRequested=false;}},{passive:!1}); } else console.error("Jump Button not found!");
        if(fireButtonElement){ fireButtonElement.addEventListener('touchstart', e=>{if(gameReady && !isTransitioning){e.preventDefault();player.shootRequested=true;}},{passive:!1}); fireButtonElement.addEventListener('touchend', e=>{if(gameReady){e.preventDefault();player.shootRequested=false;}},{passive:!1}); } else console.error("Fire Button not found!");
    } else { document.body.classList.remove('mobile'); }
}
function handleTouchStartLook(e){ if(!isMobile||!gameReady||isTransitioning)return; let t=e.changedTouches[0], tgt=document.elementFromPoint(t.clientX,t.clientY); if(tgt&&(tgt.closest('.joystick-container')||tgt.closest('button')||tgt.closest('#hud'))) return; e.preventDefault(); if(lookTouchId===null){lookTouchId=t.identifier; lastLookX=t.clientX;} }
function handleTouchMoveLook(e){ if(!isMobile||!gameReady||isTransitioning||lookTouchId===null)return; for(let i=0;i<e.changedTouches.length;i++){ let t=e.changedTouches[i]; if(t.identifier===lookTouchId){e.preventDefault(); let dX=t.clientX-lastLookX; lastLookX=t.clientX; cam.rotation.y -= dX * T_SEN; break;} } }
function handleTouchEndLook(e){ if(!isMobile||!gameReady||lookTouchId===null)return; for(let i=0;i<e.changedTouches.length;i++){ if(e.changedTouches[i].identifier===lookTouchId){ lookTouchId=null; break; } } }

function showMessage(text, duration = MESSAGE_DISPLAY_TIME) {
    if (!messageElement || isTransitioning) return;
    messageElement.textContent = text;
    messageElement.style.display = 'block';
    messageDisplayTimer = duration;
}

function checkInteractions(delta) {
    if (!gameReady || isTransitioning) return;
    const playerPos = cam.position;

    if (keycardSprite && !player.hasKeycard) {
        const distToKeycard = playerPos.distanceTo(keycardSprite.position);
        if (distToKeycard < KEYCARD_PICKUP_DIST) {
            player.hasKeycard = true;
            disposeMesh(keycardSprite);
            keycardSprite = null;
            showMessage("Keycard Collected!");
            console.log("Keycard collected!");
        }
    }

    if (messageDisplayTimer > 0) {
        messageDisplayTimer -= delta;
        if (messageDisplayTimer <= 0 && messageElement) {
            messageElement.style.display = 'none';
        }
    }
    if (doorMessageCooldown > 0) {
        doorMessageCooldown -= delta;
    }

    checkLevelTransition();
}

function checkLevelTransition() {
    if (!gameReady || isTransitioning || !player.collider || !levelTransitionTriggerZone) return;

    if (levelTransitionTriggerZone.intersectsBox(player.collider)) {
        // console.log("Player intersecting transition zone"); // Debug log
        if (player.hasKeycard) {
            startLevelTransition();
        } else {
            // Optional: Show message if player tries without keycard
             if (doorMessageCooldown <= 0) {
                 showMessage("Requires Keycard to Proceed");
                 doorMessageCooldown = MESSAGE_DISPLAY_TIME * 1.5;
             }
        }
    }
}


function startLevelTransition() {
    if (isTransitioning) return;

    isTransitioning = true;
    console.log("Initiating level transition...");

    player.moveForward = player.moveBackward = player.moveLeft = player.moveRight = false;
    player.jumpRequested = player.shootRequested = false;
    moveJoystick?.reset();

    if (pointerLocked) {
        controls.unlock();
        document.body.style.cursor='default';
    }

    if (fadeOverlayElement) {
        fadeOverlayElement.classList.add('active');

        setTimeout(() => {
            console.log(`Faded. Transitioning to ${LEVEL_TRANSITION_TARGET}...`);
            try {
                 window.location.href = LEVEL_TRANSITION_TARGET;
            } catch (e) {
                console.error("Error during redirection:", e);
                alert(`Failed to load next level (${LEVEL_TRANSITION_TARGET}). Check console for details.`);
                isTransitioning = false; // Allow player control again if transition fails
                fadeOverlayElement.classList.remove('active');
            }
        }, LEVEL_TRANSITION_FADE_DURATION);

    } else {
        console.error("Fade overlay element not found! Cannot transition visually.");
         // Attempt non-visual transition anyway? Or alert user?
         alert("Transition error: Fade overlay missing. Attempting direct load.");
         try {
             window.location.href = LEVEL_TRANSITION_TARGET;
         } catch (e) {
             console.error("Error during redirection:", e);
             alert(`Failed to load next level (${LEVEL_TRANSITION_TARGET}). Check console for details.`);
             isTransitioning = false;
         }
    }
}


function updateDoorLogic(dt) { // Unchanged
    if (isTransitioning) return;
    if (!controls || (!controls.isLocked && !isMobile)) return;
    let pP = controls.getObject().position;

    for (let i = 0; i < doorDataArray.length; i++) {
        let d = doorDataArray[i];
        if (!d || !d.meshLeft || !d.meshRight) continue;

        let dx = pP.x - d.worldX, dz = pP.z - d.worldZ, dSq = dx * dx + dz * dz;
        let tSq = DOOR_TRIGGER_DISTANCE * DOOR_TRIGGER_DISTANCE;
        let targetState = dSq < tSq ? 'opening' : 'closing';
        let canOpen = true;

        if (targetState === 'opening') {
            if (d.requiresKeycard && !d.keycardActivated) {
                if (player.hasKeycard) {
                    d.keycardActivated = true;
                    showMessage("Access Granted", 1.5);
                    canOpen = true;
                } else {
                    canOpen = false;
                    if (dSq < tSq && doorMessageCooldown <= 0) {
                        showMessage("Requires Keycard");
                        doorMessageCooldown = MESSAGE_DISPLAY_TIME * 1.5;
                    }
                }
            }
            if (canOpen && (d.state === 'closed' || d.state === 'closing')) {
                d.state = 'opening';
                if (!d.collidersActive) {
                     if (d.colliderLeft && colliders.indexOf(d.colliderLeft) === -1) colliders.push(d.colliderLeft);
                     if (d.colliderRight && colliders.indexOf(d.colliderRight) === -1) colliders.push(d.colliderRight);
                     d.collidersActive = true;
                }
            }
        }
        else if (targetState === 'closing') {
            if (d.state === 'open' || d.state === 'opening') {
                d.state = 'closing';
                 if (!d.collidersActive) {
                     if (d.colliderLeft && colliders.indexOf(d.colliderLeft) === -1) colliders.push(d.colliderLeft);
                     if (d.colliderRight && colliders.indexOf(d.colliderRight) === -1) colliders.push(d.colliderRight);
                     d.collidersActive = true;
                }
            }
        }

        let changed = false;
        if (d.state === 'opening') {
            d.offset += DOOR_SPEED * dt;
            if (d.offset >= DOOR_FULLY_OPEN_OFFSET) {
                d.offset = DOOR_FULLY_OPEN_OFFSET;
                if (d.state !== 'open') {
                    d.state = 'open';
                    if (d.collidersActive) {
                        if(d.colliderLeft) { const indexL = colliders.indexOf(d.colliderLeft); if (indexL > -1) colliders.splice(indexL, 1); }
                        if(d.colliderRight) { const indexR = colliders.indexOf(d.colliderRight); if (indexR > -1) colliders.splice(indexR, 1); }
                        d.collidersActive = false;
                    }
                }
            }
            changed = true;
        } else if (d.state === 'closing') {
            d.offset -= DOOR_SPEED * dt;
            if (d.offset <= 0) {
                d.offset = 0;
                 if (d.state !== 'closed') {
                    d.state = 'closed';
                    if (!d.collidersActive) {
                         if (d.colliderLeft && colliders.indexOf(d.colliderLeft) === -1) colliders.push(d.colliderLeft);
                         if (d.colliderRight && colliders.indexOf(d.colliderRight) === -1) colliders.push(d.colliderRight);
                         d.collidersActive = true;
                    }
                }
            }
            changed = true;
        }

        if (changed) {
            if (d.type === 'sliding' && d.meshLeft && d.meshRight) {
                let slideAmount = (d.offset / DOOR_FULLY_OPEN_OFFSET) * DOOR_SLIDE_DISTANCE;
                d.meshLeft.position.x = d.originalLeftX - slideAmount;
                d.meshRight.position.x = d.originalRightX + slideAmount;
                if(d.collidersActive) {
                    if(d.colliderLeft) d.colliderLeft.setFromObject(d.meshLeft);
                    if(d.colliderRight) d.colliderRight.setFromObject(d.meshRight);
                }
            }
        }
    }
}


const updatePlayerMovement = (delta) => { // Unchanged
    if (isTransitioning) {
        player.velocity.set(0,0,0);
        return;
    }

    if(isMobile && moveJoystick){ let deadzone = 0.1; player.moveForward = moveJoystick.cY < -deadzone; player.moveBackward = moveJoystick.cY > deadzone; player.moveLeft = moveJoystick.cX < -deadzone; player.moveRight = moveJoystick.cX > deadzone; }
    if (!player.onGround) { player.velocity.y -= GRAV * delta; } else { player.velocity.y = max(0, player.velocity.y); }
    if (player.jumpRequested && player.canJump) { player.velocity.y = player.jumpVelocity; player.canJump = false; player.onGround = false; }
    player.direction.z = Number(player.moveForward) - Number(player.moveBackward);
    player.direction.x = Number(player.moveRight) - Number(player.moveLeft);
    player.direction.normalize();
    const currentSpeed = player.speed * (player.onGround ? 1 : 0.6); const damping = Math.exp(-4 * delta) - 1;
    if (controls.isLocked || isMobile) {
        controls.getDirection(tempDirection);
        const forward = tempDirection.setY(0).normalize();
        const right = new V().crossVectors(cam.up, forward).normalize();

        let intendedVelX = 0; let intendedVelZ = 0;
        if (player.direction.lengthSq() > 0) {
            intendedVelX += forward.x * player.direction.z * currentSpeed;
            intendedVelZ += forward.z * player.direction.z * currentSpeed;
            intendedVelX -= right.x * player.direction.x * currentSpeed;
            intendedVelZ -= right.z * player.direction.x * currentSpeed;
        }
        player.velocity.x = lp(player.velocity.x, intendedVelX, delta*15 );
        player.velocity.z = lp(player.velocity.z, intendedVelZ, delta*15 );
        if(player.direction.lengthSq() === 0){ player.velocity.x += player.velocity.x * damping; player.velocity.z += player.velocity.z * damping; }
    } else {
         player.velocity.x += player.velocity.x * damping;
         player.velocity.z += player.velocity.z * damping;
    }
    const deltaPosition = player.velocity.clone().multiplyScalar(delta);
    let collidedX = false; let collidedZ = false; const playerCenterOffset = player.height / 2;
    const playerColliderCenter = cam.position.clone().setY(cam.position.y - playerCenterOffset);

    tempCheckPos.copy(playerColliderCenter); tempCheckPos.x += deltaPosition.x;
    tempPlayerCollider.setFromCenterAndSize( tempCheckPos, new V(player.width, player.height, player.depth) );
    for (const box of colliders) {
         if (box && tempPlayerCollider.intersectsBox(box)) { collidedX = true; break; }
    }
    if (collidedX) { player.velocity.x = 0; deltaPosition.x = 0; }

    tempCheckPos.copy(playerColliderCenter); tempCheckPos.x += deltaPosition.x; tempCheckPos.z += deltaPosition.z;
    tempPlayerCollider.setFromCenterAndSize( tempCheckPos, new V(player.width, player.height, player.depth) );
    for (const box of colliders) {
         if (box && tempPlayerCollider.intersectsBox(box)) { collidedZ = true; break; }
    }
    if (collidedZ) { player.velocity.z = 0; deltaPosition.z = 0; }

    tempCheckPos.copy(playerColliderCenter);
    tempCheckPos.x += deltaPosition.x; tempCheckPos.z += deltaPosition.z; tempCheckPos.y += deltaPosition.y;
    tempPlayerCollider.setFromCenterAndSize( tempCheckPos, new V(player.width, player.height, player.depth) );

    let collidedY = false;
    let groundCollisionY = -Infinity;
    for (const box of colliders) {
        if (box && tempPlayerCollider.intersectsBox(box)) {
            if (deltaPosition.y < 0 && box.max.y > groundCollisionY && box.max.y <= playerColliderCenter.y + 0.1) {
                groundCollisionY = box.max.y;
                collidedY = true;
            } else if (deltaPosition.y > 0 && box.min.y >= playerColliderCenter.y + playerCenterOffset - 0.1) { // Check ceiling collision more carefully
                 // Allow some tolerance before stopping upward movement
                if (tempPlayerCollider.min.y < box.max.y && tempPlayerCollider.max.y > box.min.y) {
                    player.velocity.y = 0; deltaPosition.y = 0; collidedY = true;
                }
            }
        }
    }
    const terrainY = gFH(cam.position.x + deltaPosition.x, cam.position.z + deltaPosition.z);
    const playerFeetTargetY = tempCheckPos.y - playerCenterOffset;

    if (playerFeetTargetY <= terrainY) {
        if (deltaPosition.y <= 0 && terrainY > groundCollisionY) {
             groundCollisionY = terrainY;
             collidedY = true;
        }
    }
    if (collidedY && deltaPosition.y <= 0) {
        player.velocity.y = 0;
        // Adjust position precisely to avoid sinking slightly
        deltaPosition.y = (groundCollisionY + playerCenterOffset) - playerColliderCenter.y;
        if (!player.onGround) { player.onGround = true; player.canJump = true; }
    } else {
        player.onGround = false;
    }

    cam.position.add(deltaPosition);

    const worldBoundary = TW / 2 - 1;
    cam.position.x = cl(cam.position.x, -worldBoundary, worldBoundary);
    cam.position.z = cl(cam.position.z, -worldBoundary, worldBoundary);

    // Update player collider AFTER final position is set
    player.collider.setFromCenterAndSize(
        cam.position.clone().setY(cam.position.y - playerCenterOffset),
        new V(player.width, player.height, player.depth)
    );
};


// --- Shooting and HUD Logic (Unchanged) ---
function updateGunAnimation(delta, weaponData) {
    if(!weaponViewModel || !weaponData || !weaponData.iMat || !weaponData.fMat || isTransitioning) return;
    if(player.isFiring) {
        if(weaponViewModel.material !== weaponData.fMat){
             weaponViewModel.material = weaponData.fMat;
             if(weaponData.fMat.map) weaponData.fMat.map.offset.x = player.fireCurrentFrame / weaponData.fr;
        }
        player.fireAnimTime -= delta;
        if(player.fireAnimTime <= 0) {
            player.isFiring = false; player.fireCurrentFrame = 0;
            weaponViewModel.material = weaponData.iMat;
             if(weaponData.fMat.map) weaponData.fMat.map.offset.x = 0;
        } else {
             player.fireFrameTime += delta;
             if(player.fireFrameTime >= weaponData.dur) {
                player.fireCurrentFrame = (player.fireCurrentFrame + 1);
                 if(weaponData.fMat.map){
                     const frameToShow = Math.min(player.fireCurrentFrame, weaponData.fr - 1);
                     weaponData.fMat.map.offset.x = frameToShow / weaponData.fr;
                 }
                player.fireFrameTime -= weaponData.dur;
             }
        }
    } else {
        if(weaponViewModel.material !== weaponData.iMat){
            weaponViewModel.material = weaponData.iMat;
            player.fireCurrentFrame = 0;
            if(weaponData.fMat && weaponData.fMat.map) weaponData.fMat.map.offset.x = 0;
        }
    }
}
function tryShoot(weaponData) {
    if(!weaponData || player.isFiring || isTransitioning) return;
    if (player.ammo <= 0) {
        player.timeSinceLastShot = 0; // Reset timer even if no ammo to prevent immediate shot on pickup
        // Optional: Play empty clip sound here
        return;
    }

    player.timeSinceLastShot = 0; player.ammo--; updateHUD(); player.isFiring = true; player.fireAnimTime = weaponData.ad; player.fireCurrentFrame = 0; player.fireFrameTime = 0; if(weaponViewModel && weaponData.fMat) { weaponViewModel.material = weaponData.fMat; if(weaponData.fMat.map) weaponData.fMat.map.offset.x = 0; }
    // Optional: Play shoot sound here

    raycaster.setFromCamera(new THREE.Vector2(0,0), cam);
    const objectsToIntersect = [tM]; // Start with terrain
    // Add bunker parts (including new iron frame)
    if (bG) bG.children.forEach(child => {
        if(child.isMesh) objectsToIntersect.push(child);
        // If ironFrame is a group within bG, add its children too
        if(child instanceof GP && child.children.length > 0) {
            child.children.forEach(grandChild => {
                if(grandChild.isMesh) objectsToIntersect.push(grandChild);
            });
        }
    });
    // Add entrance parts (excluding doors if open, and transition hole)
    if (eG) eG.children.forEach(child => {
        if(child.isMesh && child !== levelTransitionHole) {
             // Check if it's a door mesh and if that door is open
             let isDoor = false;
             let doorIsOpen = false;
             for (const doorData of doorDataArray) {
                 if (child === doorData.meshLeft || child === doorData.meshRight) {
                     isDoor = true;
                     if (doorData.state === 'open') {
                         doorIsOpen = true;
                     }
                     break;
                 }
             }
             if (!isDoor || !doorIsOpen) { // Only intersect closed/moving doors
                objectsToIntersect.push(child);
             }
        }
    });
    if (pthM) objectsToIntersect.push(pthM); // Add path mesh

    let intersects = raycaster.intersectObjects(objectsToIntersect, false); // Intersect non-recursively initially
    if(intersects.length > 0 && bulletHoleTexture) {
        const intersect = intersects[0];
        // Check distance to prevent bulletholes miles away
        if (intersect.distance < 100 && intersect.point && intersect.object && intersect.face && intersect.face.normal) {
            const point = intersect.point;
            const object = intersect.object;
            const normal = intersect.face.normal.clone();
            normal.transformDirection( object.matrixWorld ).normalize(); // Use world normal

            const bhGeo = new PG(BH_SZ, BH_SZ);
            const bhMat = new MB({map: bulletHoleTexture.clone(), color:0xffffff, transparent:true, opacity:1, depthWrite:false, polygonOffset:true, polygonOffsetFactor:-2, polygonOffsetUnits:-1, side:DS});
            bhMat.map.needsUpdate = true;

            const bhMesh = new THREE.Mesh(bhGeo, bhMat);
            bhMesh.position.copy(point).addScaledVector(normal, 0.005); // Offset slightly
            bhMesh.lookAt(point.clone().add(normal)); // Orient to surface
            bhMesh.userData.isBulletHole = true;
            bhMesh.renderOrder = 1; // Render after surfaces

            scn.add(bhMesh);
            bulletHoles.push({ mesh: bhMesh, material: bhMat, createdAt: clock.getElapsedTime() });
        }
    }
}
function updateBulletHoles(delta) {
    if (isTransitioning) return;
    let now = clock.getElapsedTime();
    for(let i = bulletHoles.length - 1; i >= 0; i--) {
        let hole = bulletHoles[i];
        if (!hole || !hole.mesh || !hole.material) {
            bulletHoles.splice(i, 1); continue;
        }
        let age = now - hole.createdAt;
        if (age >= BH_LIFE) {
            disposeMesh(hole.mesh);
            bulletHoles.splice(i, 1);
        } else {
            let fadeStart = BH_LIFE * 0.8;
            if (age > fadeStart) {
                hole.material.opacity = Math.max(0, 1 - (age - fadeStart) / (BH_LIFE - fadeStart));
            } else {
                hole.material.opacity = 1;
            }
        }
    }
}
function disposeMesh(mesh) {
    if (!mesh) return;
    if (mesh.parent) mesh.parent.remove(mesh);
    mesh.geometry?.dispose();
    if (mesh.material) {
        if (Array.isArray(mesh.material)) {
            mesh.material.forEach(m => {
                m.map?.dispose();
                m.dispose();
            });
        } else {
            mesh.material.map?.dispose();
            mesh.material.dispose();
        }
    }
}
function updateHUD() {
    if(!hpValueElement || !hpBarElement || !ammoValueElement || !ammoIconsElement) return;
    hpValueElement.textContent = Math.max(0, Math.round(player.hp));
    let hpPercent = Math.min(1, Math.max(0, player.hp / P_MAX_HP));
    hpBarElement.style.width = `${hpPercent * 100}%`;
    hpBarElement.style.backgroundColor = hpPercent > .5 ? '#0f0' : hpPercent > .2 ? '#ff0' : '#f00';

    if(A['hb'] && A['hb'].image) {
        ammoValueElement.textContent = player.ammo;
        ammoIconsElement.innerHTML = '';
        for(let i = 0; i < MAX_A_IND; i++) {
            let img = document.createElement('img');
            img.src = A['hb'].image.src;
            img.alt = 'b';
            img.classList.toggle('empty', player.ammo <= i * B_PER_IND);
            ammoIconsElement.appendChild(img);
        }
    } else {
        ammoValueElement.textContent = `Ammo: ${player.ammo}`;
        ammoIconsElement.innerHTML = '';
    }
}
function takeDamage(amount) {
    if (!gameReady || isTransitioning) return;
    player.hp -= amount;
    if (player.hp < 0) player.hp = 0;
    updateHUD();
    if (player.hp <= 0) {
        triggerGameOver();
    }
}
function triggerGameOver() {
    if (isTransitioning) return; // Ensure it doesn't trigger multiple times or during other transitions
    console.log("Game Over Triggered");
    gameReady = false; // Stop main game loop logic
    isTransitioning = true; // Use transition flag to stop updates

    player.moveForward = player.moveBackward = player.moveLeft = player.moveRight = false;
    player.jumpRequested = player.shootRequested = false;
    moveJoystick?.reset();

    if (pointerLocked) { controls.unlock(); }
    document.body.style.cursor = 'default';

    // Clean up bullet holes immediately
    bulletHoles.forEach(hole => disposeMesh(hole.mesh));
    bulletHoles = [];

    // Show Game Over message / screen (can be more elaborate)
    showMessage("GAME OVER!", 10); // Show message for longer
    // Optional: Fade to black or show a game over screen

    // Reload page after a delay
    setTimeout(() => {
        // alert("GAME OVER! Refresh to restart."); // Or just reload
        window.location.reload();
    }, 3000); // Delay before reload
}

// --- Initialization and Main Loop ---
const init = () => {
    scn = new THREE.Scene();
    cam = new THREE.PerspectiveCamera(60, innerWidth / innerHeight, .1, 1000);
    rnd = new THREE.WebGLRenderer({ canvas: $('mapCanvas'), antialias: true, alpha: false });
    rnd.setPixelRatio(devicePixelRatio);
    rnd.setSize(innerWidth, innerHeight);
    rnd.shadowMap.enabled = true;
    rnd.shadowMap.type = THREE.PCFSoftShadowMap;
    rnd.outputEncoding = SE;
    rnd.physicallyCorrectLights = false; // Keep false for consistency unless lights are adjusted

    // Lighting (consider slight adjustments if needed for new materials)
    scn.add(new THREE.AmbientLight(0x8090a0, .7)); // Ambient light
    const dL = new THREE.DirectionalLight(0xffffff, .9); // Directional light
    dL.position.set(-90, 140, -70);
    dL.castShadow = true;
    dL.shadow.mapSize.width = 2048; // Good shadow resolution
    dL.shadow.mapSize.height = 2048;
    const d = 150; // Shadow camera frustum size
    dL.shadow.camera.left = -d; dL.shadow.camera.right = d;
    dL.shadow.camera.top = d; dL.shadow.camera.bottom = -d;
    dL.shadow.camera.far = 400;
    dL.shadow.camera.bias = -0.0005; // Adjust bias if shadow acne occurs
    scn.add(dL);
    // Optional: Add a slight hemisphere light for softer underside lighting
    // scn.add(new THREE.HemisphereLight(0xaaaaaa, 0x444444, 0.4));

    controls = new THREE.PointerLockControls(cam, rnd.domElement);
    controls.pointerSpeed = player.turnSpeed / .002; // Adjust if needed
    controls.addEventListener('lock', () => {
        if(gameReady && !isTransitioning){
            pointerLocked = true;
            document.body.style.cursor='none';
        } else {
            controls.unlock(); // Prevent locking if not ready or transitioning
        }
    });
    controls.addEventListener('unlock', () => {
        pointerLocked = false;
        document.body.style.cursor='default';
        // Reset movement keys on unlock to prevent unwanted movement
        player.moveForward = player.moveBackward = player.moveLeft = player.moveRight = false;
    });
    scn.add(controls.getObject()); // Add camera pivot to scene

    iLd(); // Initialize loader display
    ldA().then(() => { // Load assets
        cMa(); // Create materials (including new ones)
        createWeaponMaterials(); // Create weapon materials/geometry
        cB(); // Create the enhanced bunker
        cE(); // Create terrain and foliage
        cEn(); // Create the entrance (door, frame, reader, transition trigger)

        // --- Player Spawn ---
        // Spawn near the end of the path, facing the bunker
        const spawnX = BCX + DOX; // Center of path X
        const spawnZ = bD.bXZ + ED + 8; // A bit back from the bunker entrance path end
        const spawnY = gFH(spawnX, spawnZ) + player.height / 2 + 0.1; // Place feet slightly above ground
        cam.position.set(spawnX, spawnY, spawnZ);
        controls.getObject().position.copy(cam.position); // Sync PointerLockControls position
        // Look towards the bunker entrance
        controls.getObject().lookAt(BCX + DOX, spawnY, bD.bXZ);


        // --- Keycard Spawn --- *** LOCATION CHANGED HERE ***
        // Place it near the bunker entrance, off path to the right
        const keycardX = doorCenterPosX + EW/2 + 2; // Right of path
        const keycardZ = bD.bXZ + 5; // Closer to bunker base than original spawn
        kL.x = keycardX;
        kL.z = keycardZ;
        console.log(`Spawning keycard at: ${kL.x.toFixed(2)}, ${kL.z.toFixed(2)}`); // Log spawn location
        sS({ worldPos: kL, textureKey: 'ik' }, false); // Create keycard sprite

        // Reset player state
        player.hp = P_MAX_HP;
        player.ammo = P_MAX_A;
        player.velocity.set(0,0,0);
        player.onGround = false; // Will be determined in first update
        player.hasBigGun = false; // Reset weapon state if applicable
        player.currentWeapon = 'p';
        player.hasKeycard = false;
        isTransitioning = false; // Ensure not transitioning on start

        setupViewModel(); // Setup gun view model
        setupInputListeners(); // Setup keyboard/mouse/touch listeners
        updateHUD(); // Initialize HUD display

        ldO && ldO.classList.add("hide"); // Hide loading overlay
        gameReady = true; // Enable game logic
        anim(); // Start the main animation loop

    }).catch(e => { // Handle loading errors
        console.error("Initialization Error:", e);
        ldT.innerText = "ERROR loading assets. Check console.";
        ldO && ldO.classList.remove("hide") // Keep loading screen visible
    });

    window.addEventListener('resize', onWindowResize, false); // Handle window resize
}
const onWindowResize = () => { // Unchanged
    cam.aspect = innerWidth / innerHeight;
    cam.updateProjectionMatrix();
    rnd.setSize(innerWidth, innerHeight);
}

let animFrameId = null; // Unchanged
const anim = () => { // Main Game Loop
    animFrameId = requestAnimationFrame(anim);

    // Skip updates if not ready or during transitions (except rendering)
    if (!gameReady && !isTransitioning) {
        // Still render the scene even if paused/loading failed initially
        // This prevents a blank screen if loading fails after setup starts
        try { rnd.render(scn, cam); } catch(e) { console.error("Render error before game ready:", e); }
        return;
    }

    const delta = Math.min(0.1, clock.getDelta()); // Get frame time, cap delta

    // Only update game logic if game is ready and not transitioning
    if (gameReady && !isTransitioning) {
        updatePlayerMovement(delta);
        checkInteractions(delta); // Check for keycard pickup, messages
        updateDoorLogic(delta); // Update door opening/closing

        const currentWeaponData = wpns[player.currentWeapon];
        if (currentWeaponData) {
            player.timeSinceLastShot += delta;
            updateGunAnimation(delta, currentWeaponData); // Update weapon sprite animation
            if (player.shootRequested && player.ammo >= 0 && player.timeSinceLastShot >= (1 / currentWeaponData.rt) && (pointerLocked || isMobile)) {
                tryShoot(currentWeaponData); // Attempt to shoot
            } else if (player.shootRequested && player.ammo <= 0 && player.timeSinceLastShot >= (1 / currentWeaponData.rt)) {
                 // Handle attempting to shoot with no ammo (e.g., click sound)
                 player.timeSinceLastShot = 0; // Reset timer to prevent sound spam
            }
        }

        updateBulletHoles(delta); // Update bullet hole fading/removal
    }

    // Update elements that need continuous updates regardless of game state (like sprite facing)
    cam.updateMatrixWorld(); // Update camera matrix for billboarding
    tG.children.forEach(child => { if (child.onBeforeRender) child.onBeforeRender(); }); // Update tree sprites
    faG.children.forEach(child => { if (child.onBeforeRender) child.onBeforeRender(); }); // Update distant foliage sprites

    // Render the scene
    try {
        rnd.render(scn, cam);
    } catch (e) {
        console.error("Render Error:", e);
        gameReady = false; // Stop game loop on critical render error
        cancelAnimationFrame(animFrameId);
        alert("A critical error occurred during rendering. Please refresh the page.");
    }
}

// --- Joystick Class (Unchanged) ---
class Joy{ constructor(c,k){this.c=c;this.k=k;this.x=0;this.y=0;this.mD=c.offsetWidth/2-k.offsetWidth/2;this.cX=0;this.cY=0;this.a=!1;this.tId=null;this.iM=!1;let o={passive:!1};c.addEventListener("touchstart",e=>this.st(e),o);c.addEventListener("touchmove",e=>this.mv(e),o);c.addEventListener("touchend",e=>this.en(e),o);c.addEventListener("touchcancel",e=>this.en(e),o);c.addEventListener("mousedown",e=>this.stM(e));document.addEventListener("mousemove",e=>this.mvM(e));document.addEventListener("mouseup",e=>this.enM(e));} st(e){if(!gameReady||isTransitioning)return;e.preventDefault();if(this.a)return;let t=e.changedTouches[0];this.tId=t.identifier;this.a=!0;let r=this.c.getBoundingClientRect();this.x=r.left+r.width/2;this.y=r.top+r.height/2;this.uP(t);} mv(e){if(!this.a||!gameReady||isTransitioning)return;let t=null;for(let i=0;i<e.changedTouches.length;i++)if(e.changedTouches[i].identifier===this.tId){t=e.changedTouches[i];break;} if(t){e.preventDefault();this.uP(t);}} en(e){if(!this.a)return;let end=!1;for(let i=0;i<e.changedTouches.length;i++)if(e.changedTouches[i].identifier===this.tId){end=!0;break;} end&&this.reset();} stM(e){if(!gameReady||isTransitioning||e.button||this.a||!isMobile)return;e.preventDefault();this.a=!0;this.iM=!0;let r=this.c.getBoundingClientRect();this.x=r.left+r.width/2;this.y=r.top+r.height/2;this.uP(e);} mvM(e){if(!this.a||!this.iM||!gameReady||!isMobile||isTransitioning)return;e.preventDefault();this.uP(e);} enM(e){if(!this.a||!this.iM||e.button||!isMobile)return;this.reset();} uP(es){let clX,clY;('identifier' in es)?(clX=es.clientX,clY=es.clientY):(clX=es.clientX,clY=es.clientY);let dx=clX-this.x,dy=clY-this.y,dSq=dx*dx+dy*dy,mDSq=this.mD*this.mD,cx_=dx,cy_=dy;if(dSq>mDSq){let d=Math.sqrt(dSq);cx_=(dx/d)*this.mD;cy_=(dy/d)*this.mD;} this.cX=cl(cx_/this.mD, -1, 1);this.cY=cl(cy_/this.mD, -1, 1);this.k.style.transform=`translate(${cx_}px, ${cy_}px)`;} reset(){this.a=!1;this.tId=null;this.iM=!1;this.cX=0;this.cY=0;this.k.style.transform='translate(0px, 0px)';player.moveForward=player.moveBackward=player.moveLeft=player.moveRight=!1;} }

// --- Start ---
window.addEventListener('load', init); // Initialize on window load
</script>
</body>
</html>