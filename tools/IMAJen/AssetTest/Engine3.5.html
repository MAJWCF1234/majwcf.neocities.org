<!DOCTYPE html>
<html lang=en>
<head>
    <meta charset=utf8>
    <title>Map Editor Rebuild v3.5.1</title>
    <meta name=viewport content=width=device-width,initial-scale=1>
    <style>
        :root{--bg-color-darkest:#1e1e1e;--bg-color-dark:#252526;--bg-color-medium:#333;--bg-color-light:#3c3c3c;--border-color:#4a4a4a;--text-color-primary:#d4d4d4;--text-color-secondary:#ccc;--text-color-muted:#999;--accent-color-primary:#007acc;--accent-color-secondary:#6c757d;--accent-color-danger:#cd3131;--selection-color:#094771;--highlight-color:#00aaff;--font-size-base:12px;--font-size-small:11px;--font-size-header:14px;--border-radius:3px;--padding-base:8px;--padding-small:4px}
        body{margin:0;overflow:hidden;font-family:Segoe UI,Frutiger,Frutiger Linotype,Dejavu Sans,Helvetica Neue,Arial,sans-serif;background-color:var(--bg-color-darkest);color:var(--text-color-primary);font-size:var(--font-size-base)}
        canvas{display:block}
        #ui{position:absolute;top:0;left:0;background:var(--bg-color-dark);padding:0;border-right:1px solid var(--border-color);color:var(--text-color-primary);z-index:10;width:260px;height:100vh;display:flex;flex-direction:column;box-shadow:2px 0 5px rgba(0,0,0,.3)}
        #ui-header{background-color:var(--bg-color-light);padding:var(--padding-small) var(--padding-base);border-bottom:1px solid var(--border-color);text-align:center;font-size:var(--font-size-header);font-weight:bold;flex-shrink:0;user-select:none}
        #ui-content{overflow-y:auto;flex-grow:1;padding:var(--padding-base)}
        #ui-content::-webkit-scrollbar{width:8px}
        #ui-content::-webkit-scrollbar-track{background:var(--bg-color-dark)}
        #ui-content::-webkit-scrollbar-thumb{background:var(--bg-color-light);border-radius:4px}
        #ui-content::-webkit-scrollbar-thumb:hover{background:var(--border-color)}
        #ui h3{font-size:var(--font-size-base);font-weight:bold;margin:12px 0 8px;padding-bottom:4px;border-bottom:1px solid var(--border-color);color:var(--text-color-secondary)}
        #ui h3:first-child{margin-top:0}
        #ui h4{font-size:var(--font-size-small);font-weight:bold;margin:10px 0 5px;color:var(--text-color-muted);text-transform:uppercase}
        #ui button{display:block;margin:5px 0;width:100%;padding:6px var(--padding-base);border:1px solid var(--border-color);border-radius:var(--border-radius);font-size:var(--font-size-base);cursor:pointer;background-color:var(--bg-color-light);color:var(--text-color-primary);transition:background-color .15s,border-color .15s;box-sizing:border-box;text-align:center}
        #ui button:hover:not(:disabled){background-color:var(--border-color);border-color:#5a5a5a}
        #ui button:active:not(:disabled){background-color:var(--selection-color);border-color:var(--accent-color-primary)}
        #ui button.primary{background-color:var(--accent-color-primary);border-color:var(--accent-color-primary);color:white}
        #ui button.primary:hover:not(:disabled){background-color:#005a9e;border-color:#005a9e}
        #ui button.secondary{background-color:var(--accent-color-secondary);border-color:var(--accent-color-secondary);color:white}
        #ui button.secondary:hover:not(:disabled){background-color:#5a6268;border-color:#545b62}
        #ui button.danger{background-color:var(--accent-color-danger);border-color:var(--accent-color-danger);color:white}
        #ui button.danger:hover:not(:disabled){background-color:#a71d1d;border-color:#a71d1d}
        #ui button:disabled{background-color:var(--bg-color-medium);border-color:var(--border-color);color:var(--text-color-muted);cursor:not-allowed;opacity:.6}
        #ui .section{margin-bottom:12px}
        #ui label{display:block;margin:8px 0 3px;font-size:var(--font-size-small);color:var(--text-color-muted)}
        #ui input[type=checkbox]{margin-right:5px;vertical-align:middle;accent-color:var(--accent-color-primary)}
        #ui label input[type=checkbox]{margin-top:-2px}
        #ui input[type=text],#ui input[type=number],#ui input[type=color],#ui select{width:100%;padding:4px 6px;margin-bottom:6px;background:var(--bg-color-darkest);color:var(--text-color-primary);border:1px solid var(--border-color);border-radius:var(--border-radius);font-size:var(--font-size-base);box-sizing:border-box;line-height:1.4}
        #ui input:focus,#ui select:focus{outline:none;border-color:var(--accent-color-primary);box-shadow:0 0 0 1px var(--accent-color-primary)}
        #ui input:disabled,#ui select:disabled{background-color:var(--bg-color-medium);color:var(--text-color-muted);cursor:not-allowed;opacity:.7}
        #ui input[type=color]{height:26px;padding:2px}
        #ui select{padding-right:20px;appearance:none;background:url('data:image/svg+xml;charset=US-ASCII,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 292.4 292.4%22%3E%3Cpath fill=%22%23ccc%22 d=%22M287 69.4a17.6 17.6 0 00-13-5.4H18.4c-5 0-9.3 1.8-12.9 5.4A17.6 17.6 0 000 82.2c0 5 1.8 9.3 5.4 12.9l128 127.9c3.6 3.6 7.8 5.4 12.8 5.4s9.2-1.8 12.8-5.4L287 95c3.5-3.5 5.4-7.8 5.4-12.8 0-5-1.9-9.2-5.4-12.8z%22/%3E%3C/svg%3E') no-repeat right 6px top 50%/8px auto var(--bg-color-darkest)}
        #textureGrid{display:grid;grid-template-columns:repeat(auto-fill,minmax(45px,1fr));gap:4px;margin-top:5px;max-height:145px;overflow-y:auto;background:var(--bg-color-darkest);padding:var(--padding-small);border-radius:var(--border-radius);border:1px solid var(--border-color)}
        .textureItem{width:45px;height:45px;background-color:var(--bg-color-medium);border:1px solid transparent;border-radius:var(--border-radius);cursor:pointer;background-size:cover;background-position:center;position:relative;display:inline-flex;justify-content:center;align-items:center;overflow:hidden;transition:border-color .15s}
        .textureItem:hover{border-color:var(--text-color-muted)}
        .textureItem.selected{border-color:var(--highlight-color);box-shadow:0 0 0 1px var(--highlight-color) inset}
        .textureItem[data-texture-path=""]{background:var(--bg-color-medium) none !important;border:1px dashed var(--border-color)}
        .textureItem[data-texture-path=""]::after{content:"None";color:var(--text-color-muted);font-size:10px;text-align:center}
        #selectedObjectInfo{margin-top:15px;border-top:1px solid var(--border-color);padding-top:10px;font-size:var(--font-size-base)}
        #selectedObjectInfo div{margin-bottom:4px}
        .coord-input-group,.half-input-group{display:flex;gap:4px;align-items:center}
        .coord-label{display:inline-block;width:10px;text-align:center;color:var(--text-color-muted);font-size:var(--font-size-small)}
        .coord-input,.half-input{flex:1;min-width:0;margin:0}
        .prop-section{margin-top:10px;padding-top:10px;border-top:1px solid var(--bg-color-light)}
        #currentModeInfo{margin-top:5px;font-style:italic;color:var(--text-color-muted);font-size:var(--font-size-small);text-align:center}
        #statusBar{padding:var(--padding-small) var(--padding-base);background-color:var(--bg-color-light);border-top:1px solid var(--border-color);font-size:var(--font-size-small);color:var(--text-color-muted);min-height:1.5em;line-height:1.5em;flex-shrink:0;user-select:none}
        .mode-button-group{display:flex;gap:4px;margin-bottom:10px}
        .mode-button-group button{flex:1;padding:5px;margin:0}
        .mode-button-group button.active,#faceSelector button.active, #addDecalPlane.active {background-color:var(--selection-color);border-color:var(--accent-color-primary);color:var(--text-color-primary);box-shadow:inset 0 0 0 1px var(--accent-color-primary)}
        #instructionsPanel{position:fixed;top:5px;right:5px;width:200px;max-height:calc(100vh - 10px);background:rgba(37,37,38,.85);padding:10px;border-radius:var(--border-radius);border:1px solid var(--border-color);color:var(--text-color-secondary);z-index:9;font-size:var(--font-size-small);overflow-y:auto;box-shadow:0 2px 5px rgba(0,0,0,.3)}
        #instructionsPanel h3{margin-top:0;text-align:center;font-size:var(--font-size-base);border-bottom:1px solid var(--border-color);padding-bottom:4px;margin-bottom:8px;color:var(--text-color-primary)}
        #instructionsPanel ul{list-style:none;padding:0;margin:0 0 10px}
        #instructionsPanel li{margin-bottom:4px}
        #instructionsPanel kbd{background-color:var(--bg-color-light);border-radius:2px;padding:1px 3px;border:1px solid var(--border-color);font-family:Consolas,Monaco,'Andale Mono','Ubuntu Mono',monospace;font-size:.95em;margin-right:4px;color:var(--text-color-primary)}
        #animationProps .coord-input-group{margin-bottom:6px}
        #animationProps label,#textureProps label{margin-top:6px;margin-bottom:2px;font-weight:normal;font-size:var(--font-size-small);color:var(--text-color-muted)}
        #animationProps select{margin-bottom:10px}
        #animationTargetFields{margin-top:5px}
        #textureProps .half-input-group{margin-bottom:4px}
        #faceSelector{display:grid;grid-template-columns:repeat(3,1fr);gap:4px;margin-bottom:10px}
        #faceSelector label{grid-column:1 / -1;margin-bottom:2px}
        #faceSelector button{padding:3px;font-size:10px;margin:0;line-height:1.2}
        small.unit{margin-left:3px;font-size:.9em;color:var(--text-color-muted)}
        #applyTextureContainer,#applyTextureContainerSprite{display:flex;gap:5px;margin-top:5px}
        #applyTextureContainer button,#applyTextureContainerSprite button{flex:1;margin:0}
        .modal-overlay{position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,.6);display:flex;justify-content:center;align-items:center;z-index:100}
        .modal-content{background:var(--bg-color-dark);border:1px solid var(--border-color);border-radius:var(--border-radius);width:80%;max-width:500px;max-height:70vh;display:flex;flex-direction:column;box-shadow:0 5px 15px rgba(0,0,0,.5)}
        .modal-header{display:flex;justify-content:space-between;align-items:center;padding:var(--padding-small) var(--padding-base);border-bottom:1px solid var(--border-color);background-color:var(--bg-color-light)}
        .modal-header h3{margin:0;border-bottom:none;font-size:var(--font-size-header)}
        .close-button{background:none;border:none;font-size:1.5em;color:var(--text-color-secondary);cursor:pointer;padding:0 5px;line-height:1;width:auto;display:inline;margin:0}
        .close-button:hover{color:var(--text-color-primary);background:none!important;border:none!important}
        .modal-body{padding:var(--padding-base);overflow-y:auto;flex-grow:1}
        .modal-body::-webkit-scrollbar{width:6px}
        .modal-body::-webkit-scrollbar-track{background:var(--bg-color-medium)}
        .modal-body::-webkit-scrollbar-thumb{background:var(--bg-color-light);border-radius:3px}
        .modal-body::-webkit-scrollbar-thumb:hover{background:var(--border-color)}
        .model-item{display:flex;align-items:center;background:var(--bg-color-light);border:1px solid var(--border-color);border-radius:var(--border-radius);padding:var(--padding-small) var(--padding-base);margin-bottom:var(--padding-small);cursor:pointer;transition:background-color .15s,border-color .15s}
        .model-item:hover{background-color:var(--border-color);border-color:#5a5a5a}
        .model-item img{width:40px;height:40px;margin-right:var(--padding-base);object-fit:contain;background-color:var(--bg-color-medium);border-radius:2px;border:1px solid var(--bg-color-darkest)}
        .model-item span{flex-grow:1;font-size:var(--font-size-base)}
        #planeTransparencyProps { margin-top: 8px; }
    </style>
</head>
<body>
    <div id=ui>
        <div id=ui-header>Map Editor Rebuild v3.5.1</div>
        <div id=ui-content>
            <div class=section><h3>Add Geometry</h3><button id=addBox>Add Box</button><button id=addPlane>Add Plane</button><button id=addSprite>Add Sprite</button><button id=addModel>Add Model</button><button id=addDecalPlane>Add Decal Plane</button></div>
            <div class=section><h3>Add Spawner/Trigger</h3><button id=addPlayerStart>Add Player Start</button><button id=addItemSpawn>Add Item Spawn</button><button id=addEnemySpawn>Add Enemy Spawn</button><button id=addLevelTrigger>Add Level Trigger</button><button id=addDoorTrigger>Add Door Trigger</button><button id=addProximityTrigger>Add Proximity Trigger</button></div>
            <div class=section>
                <h3>Manipulation Mode</h3>
                <div class=mode-button-group><button id=modeTranslate>Translate (G)</button><button id=modeRotate disabled>Rotate (R)</button><button id=modeScale disabled>Scale (S)</button></div>
                <div id=currentModeInfo></div>
            </div>
            <div class=section>
                 <h3>View & Selection</h3>
                 <button id=deleteObject class=danger disabled>Delete (Del)</button><button id=cloneObject disabled>Clone (Ctrl+D)</button>
                 <label for=snapToGrid><input type=checkbox id=snapToGrid checked> Snap To Grid</label>
                 <label for=toggleWireframe><input type=checkbox id=toggleWireframe> Show Wireframe</label>
                 <label for=toggleGrid><input type=checkbox id=toggleGrid checked> Show Grid</label>
                 <button id=resetView>Reset View</button>
            </div>
            <div class=section><h3>Textures</h3><label>Select Texture:</label><div id=textureGrid></div></div>
            <div class=section id=selectedObjectInfo>
                <h3>Selected Properties</h3>
                <div><label for=selectedName>Name:</label><input type=text id=selectedName placeholder="Optional name..."></div>
                <div id=selectedObjectType>Type: -</div>
                <div>
                     <label for=selectedIsVisible><input type=checkbox id=selectedIsVisible checked> Visible</label>
                     <label for=selectedIsLocked><input type=checkbox id=selectedIsLocked> Locked (Prevents Selection/Edit)</label>
                </div>
                <div class=prop-section><label>Position:</label> <div class=coord-input-group><span class=coord-label>X</span><input type=number step=.1 class=coord-input id=selectedPosX><span class=coord-label>Y</span><input type=number step=.1 class=coord-input id=selectedPosY><span class=coord-label>Z</span><input type=number step=.1 class=coord-input id=selectedPosZ></div></div>
                <div class=prop-section id=rotationSection><label>Rotation:</label> <div class=coord-input-group><span class=coord-label>X</span><input type=number step=1 class=coord-input id=selectedRotX><span class=coord-label>Y</span><input type=number step=1 class=coord-input id=selectedRotY><span class=coord-label>Z</span><input type=number step=1 class=coord-input id=selectedRotZ><small class=unit>deg</small></div></div>
                <div class=prop-section id=scaleSection><label>Scale:</label> <div class=coord-input-group><span class=coord-label>X</span><input type=number step=.1 min=.01 class=coord-input id=selectedScaleX><span class=coord-label>Y</span><input type=number step=.1 min=.01 class=coord-input id=selectedScaleY><span class=coord-label>Z</span><input type=number step=.1 min=.01 class=coord-input id=selectedScaleZ></div></div>
                <div class=prop-section id=geometryProps>
                     <h4>Geometry Properties</h4><label for=selectedIsCollider><input type=checkbox id=selectedIsCollider> Is Collider?</label>
                     <div id=faceSelector><label>Active Face:</label><button data-face-index=0>+X</button><button data-face-index=1>-X</button><button data-face-index=2>+Y</button><button data-face-index=3>-Y</button><button data-face-index=4>+Z</button><button data-face-index=5>-Z</button></div>
                     <div id=applyTextureContainer><button id=applyTexture>Apply to Face</button><button id=applyTextureAll>Apply to All</button></div>
                     <div id=textureProps><label>Texture Scale:</label><div class=half-input-group><span class=coord-label>U</span><input type=number step=.1 value=1 class=half-input id=texScaleU><span class=coord-label>V</span><input type=number step=.1 value=1 class=half-input id=texScaleV></div><label>Texture Offset:</label><div class=half-input-group><span class=coord-label>U</span><input type=number step=.1 value=0 class=half-input id=texOffsetU><span class=coord-label>V</span><input type=number step=.1 value=0 class=half-input id=texOffsetV></div></div>
                     <div id=planeTransparencyProps style="display: none;">
                         <label for=selectedIsTransparent><input type=checkbox id=selectedIsTransparent> Transparent Material</label>
                         <label for=selectedPlaneAlphaTest>Alpha Test Threshold (0-1):</label><input type=number step=.01 min=0 max=1 value=0.1 id=selectedPlaneAlphaTest>
                     </div>
                </div>
                <div class=prop-section id=spriteProps>
                     <h4>Sprite Properties</h4>
                     <div id=applyTextureContainerSprite><button id=applyTextureSprite>Apply Texture</button></div>
                     <div><label for=selectedFixedRotation><input type=checkbox id=selectedFixedRotation> Fixed Rotation (vs Billboard)</label></div>
                     <div><label for=selectedSizeAttenuation><input type=checkbox id=selectedSizeAttenuation> Scale with Distance</label></div>
                     <div><label for=selectedDepthWrite><input type=checkbox id=selectedDepthWrite> Write to Depth Buffer</label></div>
                     <div><label for=selectedAlphaTest>Alpha Test Threshold (0-1):</label><input type=number step=.01 min=0 max=1 id=selectedAlphaTest></div>
                     <div><label>Pivot Point (0-1):</label><div class=half-input-group><span class=coord-label>X</span><input type=number step=.1 min=0 max=1 class=half-input id=selectedCenterX><span class=coord-label>Y</span><input type=number step=.1 min=0 max=1 class=half-input id=selectedCenterY></div></div>
                     <div><label for=selectedTintColor>Tint Color:</label><input type=color id=selectedTintColor></div>
                </div>
                <div class=prop-section id=animationProps>
                    <h4>Animation</h4>
                    <label for=animType>Animation Type:</label> <select id=animType><option value=translate>Translate</option><option value=rotate>Rotate</option></select>
                    <div id=animationTargetFields>
                        <div id=animTargetPos><label>Target Position Offset:</label><div class=coord-input-group><span class=coord-label>X</span><input type=number step=.1 class=coord-input id=animTargetPosX><span class=coord-label>Y</span><input type=number step=.1 class=coord-input id=animTargetPosY><span class=coord-label>Z</span><input type=number step=.1 class=coord-input id=animTargetPosZ></div></div>
                        <div id=animTargetRot><label>Target Rotation:</label><div class=coord-input-group><span class=coord-label>X</span><input type=number step=1 class=coord-input id=animTargetRotX><span class=coord-label>Y</span><input type=number step=1 class=coord-input id=animTargetRotY><span class=coord-label>Z</span><input type=number step=1 class=coord-input id=animTargetRotZ><small class=unit>deg</small></div></div>
                    </div>
                    <button id=setAnimTarget class=secondary>Set Current Transform as Target</button>
                    <label for=animDuration>Duration (seconds):</label><input type=number step=.1 min=0.1 id=animDuration>
                    <label for=animLoop>Loop Behaviour:</label><select id=animLoop><option value=once>Play Once</option><option value=loop>Loop</option><option value=pingpong>Ping-Pong</option></select>
                    <label for=animAutoStart><input type=checkbox id=animAutoStart> Auto Start on Load</label>
                    <label for=animTriggerId>Trigger ID (Optional):</label><input type=text id=animTriggerId placeholder="e.g., door_button_1">
                    <button id=previewAnim class=secondary>Preview Animation</button> <button id=clearAnim class=danger>Clear Animation Data</button>
                </div>
                <div class=prop-section id=selectedPrefabProps></div>
                <div class=prop-section id=selectedSpawnerProps></div>
            </div>
            <div class=section><h3>File</h3><button id=exportMap class=primary>Export JSON</button><button id=loadMap>Load JSON</button><input type=file id=loadInput accept=.json style="display: none;"></div>
        </div>
        <div id=statusBar>-</div>
    </div>
    <div id="modelMenu" class="modal-overlay" style="display: none;">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Select Model</h3>
                <button id="closeModelMenu" class="close-button">&times;</button>
            </div>
            <div id="modelList" class="modal-body">
                 <p>Loading models...</p>
            </div>
        </div>
    </div>
    <div id=instructionsPanel>
        <h3>Controls</h3><ul><li><kbd>LMB Drag</kbd> Orbit View</li><li><kbd>MMB Drag</kbd> / <kbd>Shift+LMB Drag</kbd> Pan View</li><li><kbd>Scroll</kbd> Zoom View</li><li><kbd>LMB Click</kbd> Select / Deselect</li><li><kbd>LMB Click (Gizmo Center)</kbd> Cycle Mode (R/S)</li></ul>
        <h3>Manipulation</h3><ul><li><kbd>G</kbd> / <kbd>Button</kbd> Translate Mode</li><li><kbd>R</kbd> / <kbd>Button</kbd> Rotate Mode</li><li><kbd>S</kbd> / <kbd>Button</kbd> Scale Mode</li><li><kbd>Space</kbd> Cycle Rotate/Scale</li><li><kbd>Q</kbd> Toggle Local/World Space</li><li><kbd>Shift (Hold)</kbd> Uniform Scaling</li><li><kbd>Snap Checkbox</kbd> Enable Snapping</li></ul>
        <h3>View</h3><ul><li><kbd>Wireframe Checkbox</kbd> Toggle Wireframe</li></ul>
        <h3>Animation</h3><ul><li>Define target, duration etc. in UI</li><li><kbd>Set Target</kbd> Records current transform</li><li><kbd>Preview</kbd> Plays animation</li></ul>
        <h3>Texturing</h3><ul><li>Box: Select face, then apply</li><li><kbd>Apply to Face</kbd> Applies to active face</li><li><kbd>Apply to All</kbd> Applies to all faces/obj</li><li>Adjust UV Scale/Offset per face</li></ul>
        <h3>Decal Placement</h3><ul><li>Click <kbd>Add Decal</kbd> to enter mode</li><li>Click on geometry to place decal</li><li>Select decal plane to adjust properties</li><li>Click <kbd>Add Decal</kbd> again to exit mode</li></ul>
        <h3>Editing</h3><ul><li><kbd>Del</kbd> / <kbd>Backspace</kbd> Delete</li><li><kbd>Ctrl+D</kbd> Clone</li><li><kbd>Esc</kbd> Deselect / Exit Decal Mode</li></ul>
        <h3>File</h3><ul><li>Use UI Buttons for Export/Load</li></ul>
    </div>
    <canvas id=editorCanvas></canvas>
    <script src=https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js></script>
    <script src=https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js></script>
    <script src=https://unpkg.com/three@0.128.0/examples/js/controls/TransformControls.js></script>
    <script src=https://unpkg.com/three@0.128.0/examples/js/postprocessing/EffectComposer.js></script>
    <script src=https://unpkg.com/three@0.128.0/examples/js/postprocessing/RenderPass.js></script>
    <script src=https://unpkg.com/three@0.128.0/examples/js/postprocessing/ShaderPass.js></script>
    <script src=https://unpkg.com/three@0.128.0/examples/js/shaders/CopyShader.js></script>
    <script src=https://unpkg.com/three@0.128.0/examples/js/postprocessing/OutlinePass.js></script>
    <script>

        const PLACE_DISTANCE=5, SNAP_TRANSLATION=1.0, SNAP_ROTATION_DEG=15, SNAP_SCALE=0.5, STATUS_MESSAGE_DURATION=3000, DEFAULT_TEX_SCALE=[1,1], DEFAULT_TEX_OFFSET=[0,0], MIN_SCALE=0.01, IMG_PREFIX='images/';
        const MODEL_PATH_PREFIX = 'models/';
        const AVAILABLE_MODELS = ['crate1', 'crate2', 'crate3', 'elevator', 'blast_door', 'office_chair', 'tape_drive', 'cryo_pod'];
        const texturePathString="BRICK_1A.png|BRICK_2B.png|BRICK_3B.png|BRICK_3D.png|BRICK_4A.png|BRICK_6D.png|Bigdoor_left.png|Bigdoor_right.png|BluePanel.png|CONCRETE_3C.png|CONCRETE_4A.png|CONSOLE_1B.png|Cryoback.png|Cryofront.png|Cryoleft.png|Cryoright.png|Cryotop.png|DIRT_1A.png|DOORTRIM_1A.png|DOOR_1A.png|DOOR_1C.png|DOOR_1E.png|DOOR_4A.png|Door.png|FLOOR_1A.png|FLOOR_3A.png|FLOOR_4A.png|GRASS_1A.png|GRID_1A.png|GRID_2B.png|HEDGE_1A.png|LAB_2B.png|LIGHT_1B.png|LockerPanel.png|Lorenote1.png|PAPER_1B.png|PAPER_1E.png|PAPER_1F.png|PIPES_1A.PNG|PIPES_2B.PNG|RIVET_1A.PNG|SAND_1A.PNG|WARN_1A.png|WOOD_1C.png|ammo.png|ammocrate.png|bigdoor23.png|blood.png|blood1.png|bullet.png|bullethole.png|bush1.png|bush2.png|bush3.png|bush4.png|bush5.png|ceiling_tiles_damaged.png|concrete_stained.png|concretewall.png|crate1.png|crate2.png|crate3.png|crate4.png|darkbricks.png|darktiles.png|desk_metal.png|dirt.png|door_barricaded.png|door_security_heavy.png|doorbord.png|elecPanel.png|elecbox.png|elevator_ceiling.png|elevator_door.png|elevator_floor.png|elevator_shaft.png|elevator_wall.png|floor_tiles_dirty.png|foresta1.png|foresta2.png|foresta3.png|foresta4.png|foresta5.png|foresta6.png|grass1.png|grass2.png|grass3.png|grass4.png|gun.gif|hazard.png|health_pack.png|iron.png|irondoor.png|ja987.png|jasdf7.png|jkdsa8j.png|key.png|keycardreader.png|level-2-keycard.png|level-3-keycard.png|level-4-keycard.png|level-5-keycard.png|level1keycard.png|lite1.png|lkhj58.png|locker.png|lockerSlim.png|medkit.png|n_gr_0_02.png|n_grass_diff_0_01.png|n_grass_diff_0_02.png|n_grass_diff_0_03.png|n_grass_diff_0_04.png|n_grass_diff_0_05.png|n_grass_diff_0_06.png|n_grass_diff_0_07.png|n_grass_diff_0_08.png|n_grass_diff_0_13.png|n_grass_diff_0_14.png|n_grass_diff_0_15.png|n_grass_diff_0_16.png|n_grass_diff_0_17.png|n_grass_diff_0_18.png|n_grass_diff_0_19.png|n_grass_diff_0_20.png|n_grass_diff_0_21.png|n_grass_diff_0_22.png|n_grass_diff_0_23.png|n_grass_diff_0_24.png|n_grass_diff_0_25.png|n_grass_diff_0_26.png|n_grass_diff_0_27.png|n_grass_diff_0_28.png|n_grass_diff_0_29.png|n_grass_diff_0_30.png|n_grass_diff_0_31.png|n_grass_diff_0_32.png|n_grass_diff_0_33.png|n_grass_diff_0_34.png|n_grass_diff_0_35.png|n_grass_diff_0_36.png|n_grass_diff_0_37.png|n_grass_diff_0_38.png|n_grass_diff_0_39.png|n_grass_diff_0_40.png|n_grass_diff_0_41.png|n_grass_diff_0_42.png|n_grass_diff_0_44.png|n_grass_diff_0_45.png|n_grass_diff_0_46.png|n_grass_diff_0_47.png|n_grass_diff_0_48.png|n_grass_diff_0_49.png|n_grass_diff_0_50.png|n_grass_diff_0_51.png|n_grass_diff_0_52.png|n_grass_diff_0_53.png|n_grass_diff_0_54.png|n_grass_diff_0_55.png|n_grass_diff_0_56.png|n_grass_diff_0_57.png|n_grass_diff_0_58.png|n_grass_diff_0_59.png|n_grass_diff_0_60.png|n_grass_diff_0_61.png|n_grass_diff_0_62.png|n_grass_diff_0_63.png|n_grass_diff_0_64.png|pistol_ammo.png|railing.png|ramp1.png|shortgrass1.png|shortgrass2.png|shortgrass3.png|sky.png|stepbot.png|steplight.png|stepsid.png|steptop.png|sun.png|suprt1.png|suprt2.png|suprt3.png|terminal_screen_off.png|tree.png|tree1.png|tree2.png|tree3.png|trim1.png|trim2.png|vdoor.png|wall_office_basic.png|wall_panel_damaged.png|water.png|xcrate11a.png|xcrate11b.png|office_chair_back_front.png|office_chair_back_rear.png|office_chair_seat_top.png|office_chair_seat_bottom.png|office_chair_stem.png|tapedrive_right.png|tapedrive_left.png|tapedrive_top.png|tapedrive_bottom.png|tapedrive_front.png|tapedrive_back.png|Cryoright.png|Cryoleft.png|Cryotop.png|Cryofront.png|Cryoback.png";
        const texturePaths = texturePathString.split('|').map(p => IMG_PREFIX + p);
        const raycaster = new THREE.Raycaster(), mouse = new THREE.Vector2(), clock = new THREE.Clock(), textureLoader = new THREE.TextureLoader();
        const markerGeo = new THREE.SphereGeometry(0.15,16,8), markerMats = { player_start:new THREE.MeshBasicMaterial({color:0x00ff00,wireframe:!0}),item:new THREE.MeshBasicMaterial({color:0xff00ff,wireframe:!0}),enemy:new THREE.MeshBasicMaterial({color:0xff0000,wireframe:!0}),level_trigger:new THREE.MeshBasicMaterial({color:0x00ffff,wireframe:!0}),door_trigger:new THREE.MeshBasicMaterial({color:0xffa500,wireframe:!0}),proximity_trigger:new THREE.MeshBasicMaterial({color:0x800080,wireframe:!0})};
        const prefabTypes=[], spawnerTypes=["player_start","enemy","item","level_trigger","door_trigger","proximity_trigger"], itemTypes=["keycard_security","keycard_office","healthpack","ammo_pistol","ammo_heavy","weapon_biggun"], enemyTypes=["guard_easy","guard_heavy","turret"];
        const _camPos=new THREE.Vector3(), _spritePos=new THREE.Vector3(), _targetDir=new THREE.Vector3(), _spriteQuaternion=new THREE.Quaternion(), _yAxis=new THREE.Vector3(0,1,0), _tempEuler=new THREE.Euler(), _identityQuaternion=new THREE.Quaternion(), _decalOffset = 0.01;
        let scene, camera, renderer, orbitControls, transformControls, composer, outlinePass, gridHelper;
        let levelData = { geometry: [], prefabs: [], spawners: [], sprites: [], modelInstances: [] };
        let selectedObjectData = null, selectedMesh = null, selectedFaceIndex = 0;
        let loadedTextures = {}, loadedMaterials = {}, loadedSpriteMaterials = {}, loadedModelDefinitions = {};
        let isShiftPressed = false, lastGizmoMode = 'translate', selectedTexturePath = "";
        let isPlacingDecal = false;
        let statusTimeout = null, animationPreviewState = { isPlaying: false, mesh: null, startTime: 0, duration: 1, startPos: null, targetPos: null, startRot: null, targetRot: null, type: 'translate', loop: 'once', direction: 1 };
        const dom = {};

        function cacheDOMElements() {
            const ids=['ui','ui-header','ui-content','editorCanvas','textureGrid','selectedObjectInfo','statusBar','instructionsPanel','addBox','addPlane','addSprite','addModel','addDecalPlane','addPlayerStart','addItemSpawn','addEnemySpawn','addLevelTrigger','addDoorTrigger','addProximityTrigger','modeTranslate','modeRotate','modeScale','currentModeInfo','deleteObject','cloneObject','snapToGrid','toggleWireframe','toggleGrid','resetView','applyTexture','applyTextureAll','applyTextureSprite','exportMap','loadMap','loadInput','selectedObjectType','selectedName','selectedIsVisible','selectedIsLocked','rotationSection','scaleSection','faceSelector','geometryProps','spriteProps','animationProps','selectedPosX','selectedPosY','selectedPosZ','selectedRotX','selectedRotY','selectedRotZ','selectedScaleX','selectedScaleY','selectedScaleZ','selectedIsCollider','texScaleU','texScaleV','texOffsetU','texOffsetV','textureProps','planeTransparencyProps','selectedIsTransparent','selectedPlaneAlphaTest','applyTextureContainer','applyTextureContainerSprite','selectedFixedRotation','selectedSizeAttenuation','selectedDepthWrite','selectedAlphaTest','selectedCenterX','selectedCenterY','selectedTintColor','animType','animationTargetFields','animTargetPos','animTargetRot','animTargetPosX','animTargetPosY','animTargetPosZ','animTargetRotX','animTargetRotY','animTargetRotZ','setAnimTarget','animDuration','animLoop','animAutoStart','animTriggerId','previewAnim','clearAnim','selectedPrefabProps','selectedSpawnerProps','modelMenu','modelList','closeModelMenu'];
            ids.forEach(id => dom[id] = document.getElementById(id));
        }

        function init() {
            cacheDOMElements();
            scene = new THREE.Scene(); scene.background = new THREE.Color(0x303030);
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000); camera.position.set(8, 8, 8);
            renderer = new THREE.WebGLRenderer({ canvas: dom.editorCanvas, antialias: true }); renderer.setSize(window.innerWidth, window.innerHeight);
            orbitControls = new THREE.OrbitControls(camera, renderer.domElement); orbitControls.enableDamping = true; orbitControls.target.set(0, 1, 0);
            transformControls = new THREE.TransformControls(camera, renderer.domElement);
            transformControls.addEventListener('change', render);
            transformControls.addEventListener('dragging-changed', event => { orbitControls.enabled = !event.value; if (animationPreviewState.isPlaying && event.value && animationPreviewState.mesh === transformControls.object) { resetToInitialTransform(animationPreviewState.mesh); animationPreviewState.isPlaying = false; showStatus("Animation preview stopped by dragging."); } });
            transformControls.addEventListener('objectChange', onObjectTransform); scene.add(transformControls);
            scene.add(new THREE.AmbientLight(0x888888)); const dirLight = new THREE.DirectionalLight(0xffffff, 0.8); dirLight.position.set(5, 10, 7); scene.add(dirLight);
            gridHelper = new THREE.GridHelper(50, 50, 0x555555, 0x444444); scene.add(gridHelper);
            composer = new THREE.EffectComposer(renderer); const renderPass = new THREE.RenderPass(scene, camera); composer.addPass(renderPass);
            outlinePass = new THREE.OutlinePass(new THREE.Vector2(window.innerWidth, window.innerHeight), scene, camera);
            outlinePass.edgeStrength = 2.5; outlinePass.edgeGlow = 0.2; outlinePass.edgeThickness = 0.8; outlinePass.pulsePeriod = 0; outlinePass.visibleEdgeColor.set('#00aaff'); outlinePass.hiddenEdgeColor.set('#094771'); composer.addPass(outlinePass);
            const copyPass = new THREE.ShaderPass(THREE.CopyShader); copyPass.renderToScreen = true; composer.addPass(copyPass);

            dom.snapToGrid.checked = localStorage.getItem('editor_snap') === 'true';
            dom.toggleWireframe.checked = localStorage.getItem('editor_wireframe') === 'true';
            dom.toggleGrid.checked = localStorage.getItem('editor_grid') !== 'false';

            populateTextureUI(); setupEventListeners();

            dom.snapToGrid.dispatchEvent(new Event('change'));
            dom.toggleWireframe.dispatchEvent(new Event('change'));
            dom.toggleGrid.dispatchEvent(new Event('change'));

            updateModeInfoUI(transformControls.mode); populateModelMenu(); showStatus("Editor Ready."); animate();
        }

        function getTexture(texturePath) {
            if (!texturePath || loadedTextures[texturePath] === null) return null; if (loadedTextures[texturePath]) return loadedTextures[texturePath];
            try { const texture = textureLoader.load( texturePath, ()=>{render();}, undefined, (err)=>{ console.error(`Failed texture load: ${texturePath}`, err); loadedTextures[texturePath] = null; showStatus(`Error loading texture: ${texturePath.split('/').pop()}`, 5000); render(); }); texture.wrapS = texture.wrapT = THREE.RepeatWrapping; texture.magFilter = THREE.NearestFilter; texture.minFilter = THREE.NearestMipmapLinearFilter; loadedTextures[texturePath] = texture; return texture; } catch (error) { console.error(`Exception during texture loading: ${texturePath}`, error); loadedTextures[texturePath] = null; showStatus(`Error loading texture: ${texturePath.split('/').pop()}`, 5000); return null; }
        }

        function getMaterial(texturePath, forSprite=false, spriteData=null, materialProps={}) {
            const effectivePath = texturePath || 'FALLBACK'; const isWireframeActive = dom.toggleWireframe.checked;
            if (forSprite) { const props={tint:spriteData?.tintColor||'#ffffff',sizeAtt:spriteData?.sizeAttenuation??!1,alphaTest:spriteData?.alphaTest??.5,depthWrite:spriteData?.depthWrite??!1}; const cacheKey=`${effectivePath}_SPRITE`; if (loadedSpriteMaterials[cacheKey] && loadedSpriteMaterials[cacheKey].map?.image) { const mat=loadedSpriteMaterials[cacheKey]; mat.color.set(props.tint); mat.sizeAttenuation = props.sizeAtt; mat.alphaTest = props.alphaTest; mat.depthWrite = props.depthWrite; mat.transparent = (props.alphaTest < 1.0); mat.needsUpdate = true; return mat; } const texture = getTexture(texturePath); const material = new THREE.SpriteMaterial({ map: texture, color: new THREE.Color(props.tint), sizeAttenuation: props.sizeAtt, alphaTest: props.alphaTest, depthWrite: props.depthWrite, transparent: (props.alphaTest < 1.0) }); loadedSpriteMaterials[cacheKey] = material; return material; } else { const cacheKey = `${effectivePath}_MESH_${isWireframeActive}_${JSON.stringify(materialProps)}`; if (loadedMaterials[cacheKey] && loadedMaterials[cacheKey].map?.image) return loadedMaterials[cacheKey]; const texture = getTexture(texturePath); const defaultProps = { map: texture, color: texture ? 0xffffff : 0xcccccc, roughness: 0.8, metalness: 0.1, side: THREE.DoubleSide, wireframe: isWireframeActive, transparent: false, alphaTest: 0, depthWrite: true, polygonOffset: false, polygonOffsetFactor: 0, polygonOffsetUnits: 0 }; const finalProps = { ...defaultProps, ...materialProps }; const material = new THREE.MeshStandardMaterial(finalProps); loadedMaterials[cacheKey] = material; return material; }
        }

        function updateMaterialTextureTransform(material, scale, offset) { if (!material || !material.map) return; let needsClone = material.isMeshStandardMaterial && Array.isArray(selectedMesh?.material); if (needsClone && !material.userData.mapCloned) { material.map = material.map.clone(); material.map.needsUpdate = true; material.userData.mapCloned = true; } else if (!needsClone) material.userData.mapCloned = false; material.map.repeat.fromArray(scale || DEFAULT_TEX_SCALE); material.map.offset.fromArray(offset || DEFAULT_TEX_OFFSET); material.needsUpdate = true; }

        function populateTextureUI() { dom.textureGrid.innerHTML = ''; const noneItem = createTextureItem("", "None"); dom.textureGrid.appendChild(noneItem); texturePaths.forEach(path => { const filename = path.split('/').pop(); const item = createTextureItem(path, filename); dom.textureGrid.appendChild(item); }); selectTextureItem(noneItem); }

        function createTextureItem(path, label) { const item = document.createElement('div'); item.className = 'textureItem'; item.dataset.texturePath = path; item.style.backgroundImage = path ? `url(${path})` : 'none'; item.title = label; item.addEventListener('click', () => selectTextureItem(item)); return item; }

        function selectTextureItem(itemElement) { const currentSelected = dom.textureGrid.querySelector('.textureItem.selected'); if (currentSelected) currentSelected.classList.remove('selected'); itemElement.classList.add('selected'); selectedTexturePath = itemElement.dataset.texturePath; }

        function setupEventListeners() {
            window.addEventListener('resize', onWindowResize); renderer.domElement.addEventListener('pointerdown', onPointerDown); window.addEventListener('keydown', onKeyDown); window.addEventListener('keyup', onKeyUp);
            dom.addBox.addEventListener('click', () => addGeometry('box')); dom.addPlane.addEventListener('click', () => addGeometry('plane')); dom.addSprite.addEventListener('click', addSpriteObject); dom.addModel.addEventListener('click', showModelMenu);
            dom.addDecalPlane.addEventListener('click', toggleDecalMode);
            dom.addPlayerStart.addEventListener('click', () => addSpawner('player_start')); dom.addItemSpawn.addEventListener('click', () => addSpawner('item')); dom.addEnemySpawn.addEventListener('click', () => addSpawner('enemy')); dom.addLevelTrigger.addEventListener('click', () => addSpawner('level_trigger'));
            dom.addDoorTrigger.addEventListener('click', () => addSpawner('door_trigger')); dom.addProximityTrigger.addEventListener('click', () => addSpawner('proximity_trigger'));
            dom.deleteObject.addEventListener('click', () => { if (!selectedObjectData || !selectedMesh) return; if (confirm('Are you sure you want to delete this object?')) { deleteSelected(); } });
            dom.cloneObject.addEventListener('click', cloneSelected); dom.applyTexture.addEventListener('click', () => applyTextureToSelected(false)); dom.applyTextureAll.addEventListener('click', () => applyTextureToSelected(true)); dom.applyTextureSprite.addEventListener('click', () => applyTextureToSelected(false));
            dom.toggleWireframe.addEventListener('change', () => { toggleWireframeMode(); localStorage.setItem('editor_wireframe', dom.toggleWireframe.checked); });
            dom.toggleGrid.addEventListener('change', () => { gridHelper.visible = dom.toggleGrid.checked; localStorage.setItem('editor_grid', dom.toggleGrid.checked); render(); });
            dom.resetView.addEventListener('click', () => { camera.position.set(8, 8, 8); orbitControls.target.set(0, 1, 0); orbitControls.update(); render(); });
            dom.modeTranslate.addEventListener('click', () => setGizmoMode('translate', true)); dom.modeRotate.addEventListener('click', () => setGizmoMode('rotate', true)); dom.modeScale.addEventListener('click', () => setGizmoMode('scale', true));
            dom.snapToGrid.addEventListener('change', () => { const snap = dom.snapToGrid.checked; transformControls.setTranslationSnap(snap ? SNAP_TRANSLATION : null); transformControls.setRotationSnap(snap ? THREE.MathUtils.degToRad(SNAP_ROTATION_DEG) : null); transformControls.setScaleSnap((snap && !(isShiftPressed && transformControls.getMode() === 'scale')) ? SNAP_SCALE : null); localStorage.setItem('editor_snap', snap); render(); });
            dom.exportMap.addEventListener('click', exportLevelData); dom.loadMap.addEventListener('click', () => dom.loadInput.click()); dom.loadInput.addEventListener('change', loadLevelDataFromFile);
            const updateInputs = ['selectedName','selectedIsVisible','selectedIsLocked','selectedPosX','selectedPosY','selectedPosZ','selectedRotX','selectedRotY','selectedRotZ','selectedScaleX','selectedScaleY','selectedScaleZ','selectedIsCollider','texScaleU','texScaleV','texOffsetU','texOffsetV','selectedIsTransparent','selectedPlaneAlphaTest','selectedFixedRotation','selectedSizeAttenuation','selectedDepthWrite','selectedAlphaTest','selectedCenterX','selectedCenterY','selectedTintColor','animType','animTargetPosX','animTargetPosY','animTargetPosZ','animTargetRotX','animTargetRotY','animTargetRotZ','animDuration','animLoop','animAutoStart','animTriggerId'];
            updateInputs.forEach(id => { if(dom[id]) { dom[id].addEventListener(dom[id].type==='checkbox'?'change':'input', updateSelectedDataFromUI); } else { console.warn(`DOM element ${id} not found for event listener setup.`); } });
            dom.faceSelector.querySelectorAll('button').forEach(button => { button.addEventListener('click', (e) => { const index = parseInt(e.target.dataset.faceIndex, 10); if (!isNaN(index) && selectedObjectData?.type === 'box') { selectedFaceIndex = index; updateSelectedObjectUI(); } }); });
            dom.setAnimTarget.addEventListener('click', setAnimationTarget); dom.previewAnim.addEventListener('click', previewAnimation); dom.clearAnim.addEventListener('click', clearAnimationData);
            dom.closeModelMenu.addEventListener('click', hideModelMenu);
            dom.modelMenu.addEventListener('click', (event) => { if (event.target === dom.modelMenu) { hideModelMenu(); } });
        }
        function toggleDecalMode() { isPlacingDecal = !isPlacingDecal; dom.addDecalPlane.classList.toggle('active', isPlacingDecal); showStatus(isPlacingDecal ? 'Decal Placement Mode: Click on surface' : 'Exited Decal Placement Mode'); if (!isPlacingDecal && transformControls.object) { transformControls.enabled = true; } else if (isPlacingDecal) { deselectObject(); transformControls.enabled = false; } }
        function getPlacementPosition() { const direction = new THREE.Vector3(); camera.getWorldDirection(direction); const position = new THREE.Vector3(); position.copy(camera.position).addScaledVector(direction, PLACE_DISTANCE); const snap = dom.snapToGrid.checked; if (snap) { position.x = Math.round(position.x / SNAP_TRANSLATION) * SNAP_TRANSLATION; position.y = Math.round(position.y / SNAP_TRANSLATION) * SNAP_TRANSLATION; if (Math.abs(position.y) < SNAP_TRANSLATION / 2) position.y = 0; position.z = Math.round(position.z / SNAP_TRANSLATION) * SNAP_TRANSLATION; } if (position.y < 0.1) position.y = 0.1; return position.toArray(); }
        function createBaseData(type, position, isPlane=false) { const defaultSize = [1,1,isPlane?MIN_SCALE:1]; const defaultRotation = isPlane?[-Math.PI/2,0,0]:[0,0,0]; const data = { id: THREE.MathUtils.generateUUID(), type: type, name: "", isVisible: true, isLocked: false, position: position, rotation: defaultRotation, scale: defaultSize, isCollider: !isPlane, animation: null, userData: {} }; if (isPlane) { data.material = { ref: null, scale: [...DEFAULT_TEX_SCALE], offset: [...DEFAULT_TEX_OFFSET], materialProps: { transparent: false, alphaTest: 0.0 } }; } else if (type === 'box') { data.materials = Array(6).fill(null).map(() => ({ ref: null, scale: [...DEFAULT_TEX_SCALE], offset: [...DEFAULT_TEX_OFFSET] })); } return data; }
        function addGeometry(type) { const isPlane = type === 'plane'; const placementPos = getPlacementPosition(); if (isPlane) placementPos[1] = 0; const geoData = createBaseData(type, placementPos, isPlane); levelData.geometry.push(geoData); const mesh = createMeshFromData(geoData); if (mesh) { scene.add(mesh); selectObject(mesh, geoData); showStatus(`Added ${type}`); } else { showStatus(`Failed to create ${type}`, 4000); } }
        function addSpawner(type) { const placementPos = getPlacementPosition(); placementPos[1] = 0.1; const spawnerData = { id: THREE.MathUtils.generateUUID(), type: type, name: "", isVisible: true, isLocked: false, position: placementPos, userData: {} }; if (type === 'item') { spawnerData.itemType = itemTypes[0]; spawnerData.itemId = 'item_' + Math.random().toString(16).substring(2, 8); } else if (type === 'enemy') { spawnerData.enemyType = enemyTypes[0]; } else if (type === 'player_start') { spawnerData.lookDirection = [0, 0, -1]; spawnerData.rotationY = 0; } else if (type === 'level_trigger') { spawnerData.targetLevel = 'levelX.json'; spawnerData.boundingBox = { min: [-1, -0.1, -1], max: [1, 1, 1] }; } else if (type === 'door_trigger') { spawnerData.targetTriggerId = null; spawnerData.requiredKey = null; spawnerData.oneShot = false; } else if (type === 'proximity_trigger') { spawnerData.targetTriggerId = null; spawnerData.radius = 3.0; spawnerData.oneShot = false; } levelData.spawners.push(spawnerData); const marker = createMarkerMesh(spawnerData); if (marker) { scene.add(marker); selectObject(marker, spawnerData); showStatus(`Added ${type} marker`); } else { showStatus(`Failed to create ${type} marker`, 4000); } }
        function addSpriteObject() { const placementPos = getPlacementPosition(); const spriteData = { id: THREE.MathUtils.generateUUID(), type: 'sprite', name: "", isVisible: true, isLocked: false, position: placementPos, rotation: [0,0,0], scale: [1, 1, 1], materialRef: null, autoRotate: true, isCollider: false, center: [0.5, 0.0], sizeAttenuation: false, alphaTest: 0.5, depthWrite: false, tintColor: '#ffffff', userData: {} }; levelData.sprites.push(spriteData); const spriteMesh = createSpriteMesh(spriteData); if (spriteMesh) { scene.add(spriteMesh); selectObject(spriteMesh, spriteData); showStatus('Added sprite'); } else { showStatus('Failed to create sprite', 4000); } }
        function createMeshFromData(geoData) { let geometry; if (geoData.type === 'box') geometry = new THREE.BoxGeometry(1, 1, 1); else if (geoData.type === 'plane') geometry = new THREE.PlaneGeometry(1, 1); else { console.error("Unsupported geometry type:", geoData.type); return null; } let meshMaterial; const isWireframeActive = dom.toggleWireframe.checked; if (geoData.type === 'box') { if (!geoData.materials || !Array.isArray(geoData.materials) || geoData.materials.length !== 6) geoData.materials = Array(6).fill(null).map(() => ({ ref: null, scale: [...DEFAULT_TEX_SCALE], offset: [...DEFAULT_TEX_OFFSET] })); meshMaterial = []; for (let i = 0; i < 6; i++) { const matData = geoData.materials[i] || { ref: null, scale: [...DEFAULT_TEX_SCALE], offset: [...DEFAULT_TEX_OFFSET] }; const baseMaterial = getMaterial(matData.ref, false, null, geoData.materialProps || {}); const faceMaterial = baseMaterial.clone(); faceMaterial.wireframe = isWireframeActive; faceMaterial.userData.mapCloned = false; if (faceMaterial.map) updateMaterialTextureTransform(faceMaterial, matData.scale, matData.offset); meshMaterial.push(faceMaterial); } } else { if (!geoData.material || typeof geoData.material !== 'object') geoData.material = { ref: null, scale: [...DEFAULT_TEX_SCALE], offset: [...DEFAULT_TEX_OFFSET], materialProps: { transparent: false, alphaTest: 0.0 } }; const matData = geoData.material; meshMaterial = getMaterial(matData.ref, false, null, matData.materialProps || {}).clone(); meshMaterial.wireframe = isWireframeActive; if (meshMaterial.map) updateMaterialTextureTransform(meshMaterial, matData.scale, matData.offset); } const mesh = new THREE.Mesh(geometry, meshMaterial); mesh.position.fromArray(geoData.position); mesh.rotation.fromArray(geoData.rotation); mesh.scale.fromArray(geoData.scale); mesh.visible = geoData.isVisible ?? true; mesh.userData.dataId = geoData.id; mesh.userData.isCollider = geoData.isCollider; mesh.userData.isGeometry = true; mesh.userData.isPlane = (geoData.type === 'plane'); mesh.userData.initialPosition = mesh.position.clone(); mesh.userData.initialRotation = mesh.rotation.clone(); if (geoData.animation) mesh.userData.animationData = geoData.animation; if (geoData.userData) mesh.userData = {...mesh.userData, ...geoData.userData}; return mesh; }
        function createMarkerMesh(markerData) { const mat = markerMats[markerData.type]; if (!mat) { console.error("Could not find material for marker type:", markerData.type); return null; } const mesh = new THREE.Mesh(markerGeo, mat); mesh.position.fromArray(markerData.position); if (markerData.rotationY !== undefined) mesh.rotation.y = markerData.rotationY; else if (markerData.lookDirection && markerData.type === 'player_start') { const lookDir = new THREE.Vector3().fromArray(markerData.lookDirection); mesh.lookAt(mesh.position.clone().add(lookDir)); markerData.rotationY = mesh.rotation.y; } mesh.visible = markerData.isVisible ?? true; mesh.userData.dataId = markerData.id; mesh.userData.isMarker = true; mesh.userData.markerType = markerData.type; mesh.userData.initialPosition = mesh.position.clone(); mesh.userData.initialRotation = mesh.rotation.clone(); return mesh; }
        function createSpriteMesh(spriteData) { const material = getMaterial(spriteData.materialRef, true, spriteData); if (!material) { console.error("Failed to create material for sprite:", spriteData.id); return null; } const sprite = new THREE.Sprite(material); sprite.position.fromArray(spriteData.position); sprite.scale.set(spriteData.scale[0], spriteData.scale[1], 1); sprite.center.set(spriteData.center[0] ?? 0.5, spriteData.center[1] ?? 0.0); sprite.visible = spriteData.isVisible ?? true; sprite.userData.dataId = spriteData.id; sprite.userData.isSprite = true; sprite.userData.autoRotate = spriteData.autoRotate ?? true; sprite.userData.initialPosition = sprite.position.clone(); if (!sprite.userData.autoRotate && spriteData.rotation) { _tempEuler.fromArray(spriteData.rotation); sprite.quaternion.setFromEuler(_tempEuler); } return sprite; }
        function showModelMenu() { if (!dom.modelMenu) return; if (Object.keys(loadedModelDefinitions).length === 0 || AVAILABLE_MODELS.length !== Object.keys(loadedModelDefinitions).length) { populateModelMenu(); } dom.modelMenu.style.display = 'flex'; }
        function hideModelMenu() { if (!dom.modelMenu) return; dom.modelMenu.style.display = 'none'; }
        async function loadModelDefinition(modelName) { if (loadedModelDefinitions[modelName]) { return loadedModelDefinitions[modelName]; } try { const response = await fetch(`${MODEL_PATH_PREFIX}${modelName}.json`); if (!response.ok) { throw new Error(`HTTP error! status: ${response.status}`); } const data = await response.json(); loadedModelDefinitions[modelName] = data; console.log(`Loaded model definition: ${modelName}`); return data; } catch (error) { console.error(`Failed to load model definition ${modelName}:`, error); showStatus(`Error loading model: ${modelName}`, 5000); return null; } }
        async function populateModelMenu() { if (!dom.modelList) return; dom.modelList.innerHTML = '<p>Loading models...</p>'; let itemsHtml = ''; for (const modelName of AVAILABLE_MODELS) { const definition = await loadModelDefinition(modelName); if (definition) { const previewFilename = definition.previewImage || ''; const previewSrc = previewFilename ? IMG_PREFIX + previewFilename : ''; const imgTag = previewSrc ? `<img src="${previewSrc}" alt="${definition.modelName || modelName}">` : ''; itemsHtml += ` <div class="model-item" data-model-name="${modelName}" title="Add ${definition.modelName || modelName}"> ${imgTag} <span>${definition.modelName || modelName}</span> </div>`; } else { itemsHtml += `<div class="model-item disabled" title="Failed to load ${modelName}"><span>${modelName} (Error)</span></div>`; } } if (itemsHtml === '') { dom.modelList.innerHTML = '<p>No models found or failed to load.</p>'; } else { dom.modelList.innerHTML = itemsHtml; dom.modelList.querySelectorAll('.model-item:not(.disabled)').forEach(item => { item.addEventListener('click', () => { const modelName = item.dataset.modelName; if (modelName) { addModelInstance(modelName); } }); }); } }
        async function addModelInstance(modelName) { hideModelMenu(); const definition = loadedModelDefinitions[modelName]; if (!definition) { showStatus(`Model definition "${modelName}" not loaded.`, 4000); console.error(`Attempted to add instance of unloaded model: ${modelName}`); return; } const placementPos = getPlacementPosition(); if (placementPos[1] < 0.5) placementPos[1] = 0.5; const instanceData = { id: THREE.MathUtils.generateUUID(), type: 'model_instance', name: "", isVisible: true, isLocked: false, modelName: modelName, position: placementPos, rotation: [0, 0, 0], scale: [1, 1, 1], animation: null, userData: {} }; levelData.modelInstances.push(instanceData); const modelGroup = createModelGroup(instanceData, definition); if (modelGroup) { scene.add(modelGroup); selectObject(modelGroup, instanceData); showStatus(`Added model: ${definition.modelName || modelName}`); render(); } else { showStatus(`Failed to create model instance: ${modelName}`, 4000); const index = levelData.modelInstances.findIndex(item => item.id === instanceData.id); if (index > -1) levelData.modelInstances.splice(index, 1); } }
        function createModelGroup(instanceData, definition) { const group = new THREE.Group(); group.position.fromArray(instanceData.position); group.rotation.fromArray(instanceData.rotation); group.scale.fromArray(instanceData.scale); group.visible = instanceData.isVisible ?? true; group.userData = { dataId: instanceData.id, isModelInstance: true, modelName: instanceData.modelName, initialPosition: group.position.clone(), initialRotation: group.rotation.clone(), initialScale: group.scale.clone(), }; if (instanceData.animation) group.userData.animationData = instanceData.animation; if (!definition.geometry || !Array.isArray(definition.geometry)) { console.error(`Model definition ${definition.modelName} has no valid geometry array.`); return null; } const textureMap = definition.textures || {}; const isWireframeActive = dom.toggleWireframe.checked; for (const geoDef of definition.geometry) { const childGeoData = { id: THREE.MathUtils.generateUUID(), type: geoDef.type || 'box', position: geoDef.position || [0, 0, 0], rotation: geoDef.rotation || [0, 0, 0], scale: geoDef.scale || [1, 1, 1], isCollider: geoDef.isCollider !== undefined ? geoDef.isCollider : true, materialProps: geoDef.materialProps || {}, userData: geoDef.userData || {} }; const resolveTextureRef = (matDef) => { let texturePath = null; if (matDef && matDef.ref && textureMap[matDef.ref]) { texturePath = IMG_PREFIX + textureMap[matDef.ref]; } return { ref: texturePath, scale: matDef?.scale || [...DEFAULT_TEX_SCALE], offset: matDef?.offset || [...DEFAULT_TEX_OFFSET] }; }; if (geoDef.type === 'box' && geoDef.materials) { childGeoData.materials = geoDef.materials.map(resolveTextureRef); } else if (geoDef.type === 'plane' && geoDef.material) { childGeoData.material = resolveTextureRef(geoDef.material); childGeoData.material.materialProps = geoDef.material.materialProps || { transparent: false, alphaTest: 0.0 }; } else { if (geoDef.type === 'box') { childGeoData.materials = Array(6).fill(null).map(()=>resolveTextureRef(null)); } else if (geoDef.type === 'plane') { childGeoData.material = resolveTextureRef(null); childGeoData.material.materialProps = { transparent: false, alphaTest: 0.0 }; } } const childMesh = createMeshFromData(childGeoData); if (childMesh) { childMesh.position.fromArray(childGeoData.position); childMesh.rotation.fromArray(childGeoData.rotation); childMesh.scale.fromArray(childGeoData.scale); childMesh.userData.parentGroupDataId = instanceData.id; childMesh.userData.isModelPart = true; if (geoDef.animation) { childMesh.userData.animationData = geoDef.animation; } group.add(childMesh); } else { console.warn("Failed to create child mesh for model:", definition.modelName, geoDef); } } return group; }
        function applyTextureToSelected(applyToAll=false) { if (!selectedMesh || !selectedObjectData) { showStatus("Select an object first.", 4000); return; } const textureToApply = selectedTexturePath; const isWireframeActive = dom.toggleWireframe.checked; const isSprite = selectedMesh.userData.isSprite; const isModelInstance = selectedMesh.userData.isModelInstance; if (isModelInstance) { showStatus("Cannot apply texture directly to model instances. Edit the model definition.", 4000); return; } if (selectedMesh.userData.isGeometry) { const currentScale = [parseFloat(dom.texScaleU.value) || 1, parseFloat(dom.texScaleV.value) || 1]; const currentOffset = [parseFloat(dom.texOffsetU.value) || 0, parseFloat(dom.texOffsetV.value) || 0]; if (selectedObjectData.type === 'box') { const indicesToUpdate = applyToAll ? [0, 1, 2, 3, 4, 5] : [selectedFaceIndex]; if (selectedFaceIndex < 0 || selectedFaceIndex >= 6) { showStatus("Invalid face index selected.", 4000); return; } const newBaseMaterial = getMaterial(textureToApply, false); indicesToUpdate.forEach(index => { const matData = selectedObjectData.materials[index]; matData.ref = textureToApply || null; matData.scale = [...currentScale]; matData.offset = [...currentOffset]; if (selectedMesh.material[index]?.map) selectedMesh.material[index].map.dispose(); if (selectedMesh.material[index]) selectedMesh.material[index].dispose(); const newFaceMaterial = newBaseMaterial.clone(); newFaceMaterial.wireframe = isWireframeActive; newFaceMaterial.userData.mapCloned = false; if (newFaceMaterial.map) updateMaterialTextureTransform(newFaceMaterial, matData.scale, matData.offset); selectedMesh.material[index] = newFaceMaterial; }); showStatus(`Texture applied to ${applyToAll ? 'all faces' : 'face ' + selectedFaceIndex}.`); } else { const matData = selectedObjectData.material; matData.ref = textureToApply || null; matData.scale = [...currentScale]; matData.offset = [...currentOffset]; if (selectedMesh.material?.map) selectedMesh.material.map.dispose(); if (selectedMesh.material) selectedMesh.material.dispose(); const materialProps = matData.materialProps || {}; const newBaseMaterial = getMaterial(matData.ref, false, null, materialProps); selectedMesh.material = newBaseMaterial.clone(); selectedMesh.material.wireframe = isWireframeActive; if (selectedMesh.material.map) updateMaterialTextureTransform(selectedMesh.material, matData.scale, matData.offset); showStatus(`Texture applied to plane.`); } } else if (isSprite) { selectedObjectData.materialRef = textureToApply || null; const newMaterial = getMaterial(selectedObjectData.materialRef, true, selectedObjectData); if (selectedMesh.material !== newMaterial) { if (selectedMesh.material?.map) selectedMesh.material.map.dispose(); if (selectedMesh.material) selectedMesh.material.dispose(); selectedMesh.material = newMaterial; } else selectedMesh.material.needsUpdate = true; showStatus(`Texture applied to sprite.`); } else { showStatus("Cannot apply texture to this object type.", 4000); return; } updateSelectedObjectUI(); render(); }
        function toggleWireframeMode() { const isChecked = dom.toggleWireframe.checked; loadedMaterials = {}; scene.traverse(child => { if (child.isMesh && (child.userData.isGeometry || child.userData.isModelPart ) ) { const parentData = findObjectDataById(child.userData.parentGroupDataId); const objData = findObjectDataById(child.userData.dataId); let matData = null; let texturePath = null; let materialProps = {}; if (child.userData.isModelPart && parentData?.type === 'model_instance') { materialProps = { metalness: child.material?.metalness || 0.1, roughness: child.material?.roughness || 0.8, side: child.material?.side || THREE.DoubleSide, ...child.userData.materialProps }; texturePath = child.material?.map?.userData?.texturePath || child.material?.map?.image?.src || null; if(texturePath && !texturePath.startsWith(IMG_PREFIX)) texturePath = IMG_PREFIX + texturePath.split('/').pop(); } else if (child.userData.isGeometry && objData?.type === 'box') { } else if (child.userData.isGeometry && objData?.type === 'plane') { matData = objData.material; texturePath = matData?.ref; materialProps = matData?.materialProps || {}; } else { return; } const applyWireframe = (material) => { if (!material || !material.isMeshStandardMaterial) return material; const texPath = material.map?.userData?.texturePath || material.map?.image?.src || texturePath || null; const baseMat = getMaterial(texPath, false, null, { metalness: material.metalness, roughness: material.roughness, side: material.side, transparent: material.transparent, alphaTest: material.alphaTest, polygonOffset: material.polygonOffset, polygonOffsetFactor: material.polygonOffsetFactor, polygonOffsetUnits: material.polygonOffsetUnits, ...materialProps }); const newMat = baseMat.clone(); newMat.wireframe = isChecked; newMat.userData.mapCloned = false; if (newMat.map && material.map) { newMat.map.repeat.copy(material.map.repeat); newMat.map.offset.copy(material.map.offset); if (material.userData.mapCloned) newMat.userData.mapCloned = true; } return newMat; }; const disposeMaterial = (material) => { if (material?.map && !material.userData.mapCloned) material.map.dispose(); if (material && material.dispose) material.dispose(); }; if (Array.isArray(child.material)) { const newMaterials = []; for(let i=0; i < child.material.length; i++) { const oldMat = child.material[i]; const newMat = applyWireframe(oldMat); newMaterials.push(newMat); disposeMaterial(oldMat); } child.material = newMaterials; } else if (child.material && !Array.isArray(child.material)) { const newMaterial = applyWireframe(child.material); disposeMaterial(child.material); child.material = newMaterial; } } }); showStatus(`Wireframe ${isChecked ? 'ON' : 'OFF'}`); render(); }
        function deleteSelected() { if (!selectedObjectData || !selectedMesh) return; const idToDelete = selectedObjectData.id; const type = selectedObjectData.type; let list; let objectToRemove = selectedMesh; if (type === 'sprite') list = levelData.sprites; else if (type === 'plane' || type === 'box') list = levelData.geometry; else if (spawnerTypes.includes(type)) list = levelData.spawners; else if (type === 'model_instance') list = levelData.modelInstances; if (list) { const index = list.findIndex(item => item.id === idToDelete); if (index > -1) { list.splice(index, 1); transformControls.detach(); outlinePass.selectedObjects = []; const dispose = (obj) => { if (obj.geometry) obj.geometry.dispose(); if (obj.material) { if (Array.isArray(obj.material)) obj.material.forEach(mat => { if (mat?.map) mat.map.dispose(); if(mat) mat.dispose(); }); else { if (obj.material.map) obj.material.map.dispose(); if (obj.material.dispose) obj.material.dispose(); } } }; if (objectToRemove.isGroup) { objectToRemove.traverse(child => { if (child.isMesh) dispose(child); }); } else { dispose(objectToRemove); } scene.remove(objectToRemove); selectedObjectData = null; selectedMesh = null; updateSelectedObjectUI(); showStatus(`Deleted ${type}`); render(); return; } } console.error("Could not find data or list to delete for object:", idToDelete, type); showStatus("Error: Could not delete object data.", 5000); }
        function cloneSelected() { if (!selectedObjectData || !selectedMesh) return; const clonedData = JSON.parse(JSON.stringify(selectedObjectData)); clonedData.id = THREE.MathUtils.generateUUID(); const offsetAmount = (dom.snapToGrid.checked ? SNAP_TRANSLATION : 1.0) || 1.0; clonedData.position[0] += offsetAmount; clonedData.position[2] += offsetAmount; if (clonedData.position[1] < 0.1 && !selectedMesh.userData.isPlane ) { clonedData.position[1] = (selectedMesh.userData.isPlane) ? 0 : (selectedMesh.userData.isModelInstance ? 0.5 : 0.6); } else if (clonedData.position[1] < 0) { clonedData.position[1] = 0; } let newMesh; let success = false; let list; let creatorFunc; if (selectedMesh.userData.isGeometry) { list = levelData.geometry; creatorFunc = createMeshFromData; } else if (selectedMesh.userData.isSprite) { list = levelData.sprites; creatorFunc = createSpriteMesh; } else if (selectedMesh.userData.isMarker) { if (spawnerTypes.includes(clonedData.type)) { list = levelData.spawners; creatorFunc = createMarkerMesh; } else { } } else if (selectedMesh.userData.isModelInstance) { list = levelData.modelInstances; const definition = loadedModelDefinitions[clonedData.modelName]; if (!definition) { console.error("Cannot clone model instance, definition not loaded:", clonedData.modelName); showStatus(`Error cloning: Model definition ${clonedData.modelName} not found.`, 5000); return; } creatorFunc = (instanceData) => createModelGroup(instanceData, definition); } if (!list || !creatorFunc) { console.error("Unknown object type to clone:", selectedObjectData.type, selectedMesh.userData); showStatus("Error: Cannot clone this object type.", 5000); return; } list.push(clonedData); newMesh = creatorFunc(clonedData); if (newMesh) { success = true; scene.add(newMesh); selectObject(newMesh, clonedData); showStatus(`Cloned ${clonedData.type}`); render(); } else { const index = list.findIndex(item => item.id === clonedData.id); if (index > -1) list.splice(index, 1); console.error(`Failed to create cloned mesh for ${clonedData.type}`); showStatus(`Error cloning ${clonedData.type}`, 5000); } }

        function placeDecalPlane(intersect) {
            if (!selectedTexturePath) {
                showStatus("Select a texture for the decal first.", 3000);
                return;
            }
            const pos = intersect.point.clone();
            const normal = intersect.face.normal.clone();
            const targetObject = intersect.object;
            const worldNormal = normal.transformDirection(targetObject.matrixWorld).normalize();
            pos.addScaledVector(worldNormal, _decalOffset);
            const decalSize = 0.5;
            const decalScale = [decalSize, decalSize, MIN_SCALE];
            const tempObject = new THREE.Object3D();
            tempObject.position.copy(pos);
            tempObject.lookAt(pos.clone().add(worldNormal));
            tempObject.updateMatrixWorld();
            const decalRotation = tempObject.rotation.toArray().slice(0, 3);
            const decalMatProps = {
                transparent: true,
                alphaTest: 0.1,
                depthWrite: false,
                polygonOffset: true,
                polygonOffsetFactor: -1,
                polygonOffsetUnits: -1
            };
            const geoData = {
                id: THREE.MathUtils.generateUUID(),
                type: 'plane',
                name: "", isVisible: true, isLocked: false,
                position: pos.toArray(),
                rotation: decalRotation,
                scale: decalScale,
                isCollider: false,
                material: {
                    ref: selectedTexturePath,
                    scale: [1,1],
                    offset: [0,0],
                    materialProps: decalMatProps
                },
                userData: { isDecal: true }
            };
            levelData.geometry.push(geoData);
            const mesh = createMeshFromData(geoData);
            if (mesh) {
                scene.add(mesh);
                selectObject(mesh, geoData);
                showStatus(`Placed decal plane`);
            } else {
                showStatus(`Failed to create decal plane`, 4000);
                const index = levelData.geometry.findIndex(item => item.id === geoData.id);
                if (index > -1) levelData.geometry.splice(index, 1);
            }
        }

        function onPointerDown(event) {
            if (dom.ui.contains(event.target) || dom.instructionsPanel.contains(event.target) || dom.modelMenu.contains(event.target) || transformControls.dragging) return;
            mouse.set((event.clientX / window.innerWidth) * 2 - 1, -(event.clientY / window.innerHeight) * 2 + 1);
            raycaster.setFromCamera(mouse, camera);
            if (isPlacingDecal) {
                const objectsToIntersect = scene.children.filter(c =>
                    c.isMesh && c.visible && (c.userData.isGeometry || c.userData.isModelPart)
                );
                 if (objectsToIntersect.length === 0) return;
                const intersects = raycaster.intersectObjects(objectsToIntersect, true);
                if (intersects.length > 0) {
                     const validIntersect = intersects.find(intersect =>
                         intersect.object.isMesh &&
                         !intersect.object.userData.isMarker &&
                         !intersect.object.userData.isDecal
                     );
                     if (validIntersect) {
                         placeDecalPlane(validIntersect);
                     }
                }
                return;
            }
            let clickedGizmo = false;
            if (transformControls.object && transformControls.visible) {
                const gizmoParts = [];
                transformControls.traverseVisible(child => {
                    if ((child.isMesh || child.isLine) && child.parent?.name && ['X','Y','Z', 'XYZE', 'E', 'Translate', 'Rotate', 'Scale', 'XYZ'].includes(child.parent.name)) {
                        gizmoParts.push(child);
                    }
                });
                const gizmoIntersects = raycaster.intersectObjects(gizmoParts, false);
                if (gizmoIntersects.length > 0) {
                    clickedGizmo = true;
                    if (gizmoIntersects[0].object.name === 'XYZ') {
                        cycleTransformMode(['rotate', 'scale']);
                        event.stopPropagation();
                    }
                }
            }
            if (!clickedGizmo) {
                 const objectsToIntersect = scene.children.filter(c => c !== transformControls && c.type !== 'GridHelper' && (c.isMesh || c.isSprite || c.isGroup) && c.visible && (c.userData.dataId || c.userData.parentGroupDataId) );
                const intersects = raycaster.intersectObjects(objectsToIntersect, true);
                if (intersects.length > 0) {
                    let clickedObj = intersects[0].object;
                    let potentialGroup = clickedObj;
                    while (potentialGroup.userData.isModelPart && potentialGroup.parent && potentialGroup.parent.isGroup) {
                        potentialGroup = potentialGroup.parent;
                        if (potentialGroup.userData.isModelInstance) {
                            clickedObj = potentialGroup;
                            break;
                        }
                    }
                     while (clickedObj.userData.parentGroupDataId && !clickedObj.userData.isModelInstance && clickedObj.parent) {
                         if (clickedObj.parent.userData?.dataId === clickedObj.userData.parentGroupDataId) {
                             clickedObj = clickedObj.parent;
                             break;
                         }
                         clickedObj = clickedObj.parent;
                    }
                    if (clickedObj.userData.dataId) {
                        const dataObject = findObjectDataById(clickedObj.userData.dataId);
                        if (dataObject) {
                            if (dataObject.isLocked) {
                                showStatus("Object is locked.", 2000);
                                deselectObject();
                            } else if ((clickedObj.isGroup && dataObject.type === 'model_instance') || (clickedObj.isMesh && (dataObject.type === 'box' || dataObject.type === 'plane')) || (clickedObj.isSprite && dataObject.type === 'sprite') || (clickedObj.isMesh && spawnerTypes.includes(dataObject.type)) ) {
                                selectObject(clickedObj, dataObject);
                             } else {
                                 console.warn("Clicked object type mismatch with found data:", clickedObj, dataObject);
                                 deselectObject();
                            }
                        } else {
                             console.warn("Clicked mesh has dataId but no corresponding data found:", clickedObj.userData.dataId);
                             deselectObject();
                        }
                    } else {
                        deselectObject();
                    }
                } else {
                    deselectObject();
                }
            }
        }
        function findObjectDataById(id) { if (!id) return null; return levelData.geometry.find(item => item.id === id) || levelData.prefabs.find(item => item.id === id) || levelData.spawners.find(item => item.id === id) || levelData.sprites.find(item => item.id === id) || levelData.modelInstances.find(item => item.id === id); }
        function setGizmoMode(newMode, isUserAction = false) { if (!transformControls) return; let canTranslate = !!selectedMesh; let canRotate = selectedMesh && ( selectedMesh.userData.isGeometry || selectedMesh.userData.isModelInstance || (selectedMesh.userData.isSprite && !(selectedObjectData?.autoRotate ?? true)) || (selectedMesh.userData.isMarker && selectedObjectData?.type !== 'level_trigger') ); let canScale = selectedMesh && ( selectedMesh.userData.isGeometry || selectedMesh.userData.isModelInstance || selectedMesh.userData.isSprite ); let allowed = (newMode === 'translate' && canTranslate) || (newMode === 'rotate' && canRotate) || (newMode === 'scale' && canScale); let targetMode = transformControls.getMode(); if (selectedObjectData?.isLocked) allowed = false; if (allowed) { targetMode = newMode; } else if (isUserAction) { if (canTranslate) targetMode = 'translate'; else if (canRotate) targetMode = 'rotate'; else if (canScale) targetMode = 'scale'; else targetMode = null; if (selectedObjectData?.isLocked) targetMode = 'translate'; if (targetMode && targetMode !== newMode) { showStatus(`Mode '${newMode}' not available${selectedObjectData?.isLocked ? ' (Locked)' : ''}. Switched to '${targetMode}'.`, 3000); } else if (!targetMode) { showStatus(`Mode '${newMode}' not available${selectedObjectData?.isLocked ? ' (Locked)' : ''}. No manipulation possible.`, 3000); } } else { if (transformControls.mode === 'rotate' && !canRotate) targetMode = canTranslate ? 'translate' : (canScale ? 'scale' : null); else if (transformControls.mode === 'scale' && !canScale) targetMode = canTranslate ? 'translate' : (canRotate ? 'rotate' : null); else if (!canTranslate && !canRotate && !canScale) targetMode = null; else if (!allowed) { targetMode = canTranslate ? 'translate' : (canRotate ? 'rotate' : (canScale ? 'scale' : null)); } if (selectedObjectData?.isLocked) targetMode = 'translate'; } if (transformControls.object && targetMode) { transformControls.setMode(targetMode); transformControls.showX = true; transformControls.showY = true; transformControls.showZ = true; transformControls.enabled = !(selectedObjectData?.isLocked); } else if (!selectedMesh) { transformControls.setMode('translate'); transformControls.detach(); targetMode = 'translate'; } updateModeInfoUI(targetMode || 'translate'); if (isUserAction && allowed) { lastGizmoMode = newMode; } }
        function selectObject(obj, data) { if (selectedMesh === obj || data?.isLocked) { if(data?.isLocked) showStatus("Object is locked.", 2000); return; } if (animationPreviewState.isPlaying && animationPreviewState.mesh !== obj) { resetToInitialTransform(animationPreviewState.mesh); animationPreviewState.isPlaying = false; showStatus("Animation preview stopped due to new selection."); } deselectObject(false); selectedMesh = obj; selectedObjectData = data; transformControls.attach(obj); if (data.isLocked) { transformControls.detach(); } outlinePass.selectedObjects = [obj]; selectedFaceIndex = 0; let initialMode = 'translate'; let canRotate = (!obj.userData.isMarker && (!obj.userData.isSprite || !(data?.autoRotate ?? true))) || (obj.userData.isMarker && data?.type !== 'level_trigger') || obj.userData.isModelInstance; let canScale = (obj.userData.isGeometry || obj.userData.isSprite || obj.userData.isModelInstance) && !obj.userData.isMarker; if (lastGizmoMode === 'rotate' && canRotate) initialMode = 'rotate'; else if (lastGizmoMode === 'scale' && canScale) initialMode = 'scale'; else initialMode = 'translate'; setGizmoMode(initialMode, false); updateSelectedObjectUI(); dom.deleteObject.disabled = !!data.isLocked; dom.cloneObject.disabled = false; const canApplyTex = obj.userData.isGeometry; dom.applyTexture.disabled = !canApplyTex || data.isLocked; dom.applyTextureAll.disabled = !(canApplyTex && data?.type === 'box') || data.isLocked; dom.applyTextureSprite.disabled = !obj.userData.isSprite || data.isLocked; render(); }
        function deselectObject(renderUpdate=true) { if (!selectedMesh) return; if (animationPreviewState.isPlaying && animationPreviewState.mesh === selectedMesh) { resetToInitialTransform(animationPreviewState.mesh); animationPreviewState.isPlaying = false; showStatus("Animation preview stopped due to deselection."); } transformControls.detach(); outlinePass.selectedObjects = []; selectedMesh = null; selectedObjectData = null; selectedFaceIndex = 0; updateSelectedObjectUI(); dom.deleteObject.disabled = true; dom.cloneObject.disabled = true; dom.applyTexture.disabled = true; dom.applyTextureAll.disabled = true; dom.applyTextureSprite.disabled = true; setGizmoMode('translate', false); if (renderUpdate) render(); }
        function cycleTransformMode(modes=['rotate','scale']) { if (!selectedMesh || selectedObjectData?.isLocked) return; let availableModes = []; let canRotate = (!selectedMesh.userData.isMarker && (!selectedMesh.userData.isSprite || !(selectedObjectData?.autoRotate ?? true))) || (selectedMesh.userData.isMarker && selectedObjectData?.type !== 'level_trigger') || selectedMesh.userData.isModelInstance; let canScale = (selectedMesh.userData.isGeometry || selectedMesh.userData.isSprite || selectedMesh.userData.isModelInstance) && !selectedMesh.userData.isMarker; if (modes.includes('rotate') && canRotate) availableModes.push('rotate'); if (modes.includes('scale') && canScale) availableModes.push('scale'); if (availableModes.length === 0) return; const currentMode = transformControls.getMode(); let nextMode = availableModes[0]; const currentIndex = availableModes.indexOf(currentMode); if (currentIndex !== -1) nextMode = availableModes[(currentIndex + 1) % availableModes.length]; setGizmoMode(nextMode, true); }
        function updateModeInfoUI(activeMode) { const buttons = { translate: dom.modeTranslate, rotate: dom.modeRotate, scale: dom.modeScale }; let canTranslate = !!selectedMesh; let canRotate = selectedMesh && ( selectedMesh.userData.isGeometry || selectedMesh.userData.isModelInstance || (selectedMesh.userData.isSprite && !(selectedObjectData?.autoRotate ?? true)) || (selectedMesh.userData.isMarker && selectedObjectData?.type !== 'level_trigger') ); let canScale = selectedMesh && ( selectedMesh.userData.isGeometry || selectedMesh.userData.isModelInstance || selectedMesh.userData.isSprite ); if (selectedObjectData?.isLocked) { canRotate = false; canScale = false; } buttons.translate.disabled = !canTranslate; buttons.rotate.disabled = !canRotate; buttons.scale.disabled = !canScale; for (const mode in buttons) { if (buttons[mode]) buttons[mode].classList.toggle('active', mode === activeMode && !buttons[mode].disabled); } if (dom.currentModeInfo) { dom.currentModeInfo.style.display = selectedMesh ? 'block' : 'none'; dom.currentModeInfo.textContent = selectedMesh && activeMode ? `Mode: ${activeMode.charAt(0).toUpperCase() + activeMode.slice(1)}${selectedObjectData?.isLocked ? ' (Locked)' : ''}` : ''; } }
        function onObjectTransform() { if (!selectedObjectData || !selectedMesh || selectedObjectData.isLocked) return; selectedObjectData.position = selectedMesh.position.toArray(); if (selectedMesh.userData.isSprite) { const isFixedRotation = !(selectedObjectData?.autoRotate ?? true); if (isFixedRotation && transformControls.getMode() === 'rotate') selectedObjectData.rotation = selectedMesh.rotation.toArray().slice(0, 3); const currentScale = selectedMesh.scale; let newScaleX = Math.max(MIN_SCALE, Math.abs(currentScale.x)) * Math.sign(currentScale.x || 1); let newScaleY = Math.max(MIN_SCALE, Math.abs(currentScale.y)) * Math.sign(currentScale.y || 1); selectedObjectData.scale = [newScaleX, newScaleY, 1.0]; selectedMesh.scale.set(newScaleX, newScaleY, 1.0); } else if (selectedMesh.userData.isMarker) { selectedObjectData.rotationY = selectedMesh.rotation.y; if(Math.abs(selectedMesh.rotation.x) > 0.001 || Math.abs(selectedMesh.rotation.z) > 0.001) { selectedMesh.rotation.x = 0; selectedMesh.rotation.z = 0; } selectedMesh.scale.set(1, 1, 1); if(selectedObjectData.scale) selectedObjectData.scale = [1, 1, 1]; } else if (selectedMesh.userData.isGeometry || selectedMesh.userData.isModelInstance) { selectedObjectData.rotation = selectedMesh.rotation.toArray().slice(0, 3); const currentScale = selectedMesh.scale; let newScaleX = Math.max(MIN_SCALE, Math.abs(currentScale.x)) * Math.sign(currentScale.x || 1); let newScaleY = Math.max(MIN_SCALE, Math.abs(currentScale.y)) * Math.sign(currentScale.y || 1); let newScaleZ = 1.0; const isPlane = selectedObjectData?.type === 'plane'; if (selectedMesh.userData.isGeometry && isPlane) { newScaleZ = selectedObjectData.scale[2] || MIN_SCALE; } else { newScaleZ = Math.max(MIN_SCALE, Math.abs(currentScale.z)) * Math.sign(currentScale.z || 1); } if (transformControls.getMode() === 'scale' && isShiftPressed && !isPlane && !selectedMesh.userData.isSprite) { const uniformScale = Math.max(MIN_SCALE, Math.max(Math.abs(newScaleX), Math.abs(newScaleY), Math.abs(newScaleZ))); newScaleX = uniformScale * Math.sign(currentScale.x || 1); newScaleY = uniformScale * Math.sign(currentScale.y || 1); newScaleZ = uniformScale * Math.sign(currentScale.z || 1); } selectedObjectData.scale = [newScaleX, newScaleY, newScaleZ]; selectedMesh.scale.set(newScaleX, newScaleY, newScaleZ); } updateSelectedObjectUI(false); }
        function updateSelectedObjectUI(fullUpdate=true) { const show = (elem, display='block') => elem.style.display = display; const hide = (elem) => elem.style.display = 'none'; if (fullUpdate) { dom.selectedPrefabProps.innerHTML = ''; dom.selectedSpawnerProps.innerHTML = ''; } hide(dom.selectedPrefabProps); hide(dom.selectedSpawnerProps); hide(dom.geometryProps); hide(dom.spriteProps); hide(dom.animationProps); hide(dom.rotationSection); hide(dom.scaleSection); hide(dom.faceSelector); hide(dom.textureProps); hide(dom.applyTextureContainer); hide(dom.applyTextureContainerSprite); hide(dom.planeTransparencyProps); if (selectedObjectData && selectedMesh) { const isLocked = selectedObjectData.isLocked ?? false; show(dom.selectedObjectInfo); dom.selectedName.value = selectedObjectData.name || ''; dom.selectedIsVisible.checked = selectedObjectData.isVisible ?? true; dom.selectedIsLocked.checked = isLocked; let objectTypeName = selectedObjectData.type || 'Unknown'; if (selectedObjectData.type === 'model_instance') { objectTypeName = `Model Instance (${selectedObjectData.modelName || 'Unknown'})`; } else if (selectedObjectData.userData?.isDecal) { objectTypeName = 'Decal Plane'; } dom.selectedObjectType.textContent = `Type: ${objectTypeName}`; dom.selectedPosX.value = selectedObjectData.position[0].toFixed(2); dom.selectedPosY.value = selectedObjectData.position[1].toFixed(2); dom.selectedPosZ.value = selectedObjectData.position[2].toFixed(2); const isGeometry = selectedMesh.userData.isGeometry; const isSprite = selectedMesh.userData.isSprite; const isMarker = selectedMesh.userData.isMarker; const isModelInstance = selectedMesh.userData.isModelInstance; const isPlane = selectedObjectData?.type === 'plane'; const isBox = selectedObjectData?.type === 'box'; const isFixedRotation = isSprite && !(selectedObjectData.autoRotate ?? true); const showRotation = isGeometry || isMarker || isSprite || isModelInstance; if(showRotation) show(dom.rotationSection); if (showRotation) { let rotX=0, rotY=0, rotZ=0; if (isMarker) { rotY = selectedObjectData.rotationY || 0; } else { const rotSource = selectedObjectData.rotation || [0,0,0]; rotX = rotSource[0]; rotY = rotSource[1]; rotZ = rotSource[2]; } dom.selectedRotX.value = THREE.MathUtils.radToDeg(rotX).toFixed(1); dom.selectedRotY.value = THREE.MathUtils.radToDeg(rotY).toFixed(1); dom.selectedRotZ.value = THREE.MathUtils.radToDeg(rotZ).toFixed(1); dom.selectedRotX.disabled = isLocked || isMarker || (isSprite && !dom.selectedFixedRotation.checked); dom.selectedRotY.disabled = isLocked || (isSprite && !dom.selectedFixedRotation.checked); dom.selectedRotZ.disabled = isLocked || isMarker || (isSprite && !dom.selectedFixedRotation.checked); } const showScale = isGeometry || isSprite || isModelInstance; if(showScale) show(dom.scaleSection); if (showScale) { const scaleSource = selectedObjectData.scale || [1,1,1]; dom.selectedScaleX.value = scaleSource[0].toFixed(2); dom.selectedScaleY.value = scaleSource[1].toFixed(2); dom.selectedScaleZ.value = isSprite ? (1.0).toFixed(2) : scaleSource[2].toFixed(2); const disableScale = isMarker || isLocked; dom.selectedScaleX.disabled = disableScale; dom.selectedScaleY.disabled = disableScale; dom.selectedScaleZ.disabled = disableScale || isSprite; } if (isGeometry) { show(dom.geometryProps); show(dom.applyTextureContainer,'flex'); show(dom.textureProps); dom.selectedIsCollider.checked = selectedObjectData.isCollider ?? !isPlane; dom.selectedIsCollider.disabled = isLocked; dom.applyTextureAll.disabled = isLocked || !isBox; dom.applyTexture.textContent = isBox ? "Apply to Face" : "Apply Texture"; let currentMatData = null; let currentTexPath = ""; if (isBox) { show(dom.faceSelector,'grid'); dom.faceSelector.querySelectorAll('button').forEach((btn, index) => btn.classList.toggle('active', index === selectedFaceIndex)); currentMatData = selectedObjectData.materials?.[selectedFaceIndex]; } else { currentMatData = selectedObjectData.material; show(dom.planeTransparencyProps); dom.selectedIsTransparent.checked = currentMatData?.materialProps?.transparent ?? false; dom.selectedPlaneAlphaTest.value = (currentMatData?.materialProps?.alphaTest ?? 0.1).toFixed(2); dom.selectedPlaneAlphaTest.disabled = isLocked || !dom.selectedIsTransparent.checked; dom.selectedIsTransparent.disabled = isLocked; } dom.texScaleU.value = currentMatData?.scale?.[0] ?? DEFAULT_TEX_SCALE[0]; dom.texScaleV.value = currentMatData?.scale?.[1] ?? DEFAULT_TEX_SCALE[1]; dom.texOffsetU.value = currentMatData?.offset?.[0] ?? DEFAULT_TEX_OFFSET[0]; dom.texOffsetV.value = currentMatData?.offset?.[1] ?? DEFAULT_TEX_OFFSET[1]; currentTexPath = currentMatData?.ref || ""; const textureItem = dom.textureGrid.querySelector(`.textureItem[data-texture-path="${CSS.escape(currentTexPath)}"]`); if (textureItem && !textureItem.classList.contains('selected')) selectTextureItem(textureItem); else if (!textureItem && currentTexPath !== selectedTexturePath) { const noneItem = dom.textureGrid.querySelector('.textureItem[data-texture-path=""]'); if (noneItem && !noneItem.classList.contains('selected')) selectTextureItem(noneItem); } show(dom.animationProps); const anim = selectedObjectData.animation; const animType = anim?.type || 'translate'; dom.animType.value = animType; dom.animTargetPosX.value = anim?.targetPosition?.[0]?.toFixed(2) ?? ''; dom.animTargetPosY.value = anim?.targetPosition?.[1]?.toFixed(2) ?? ''; dom.animTargetPosZ.value = anim?.targetPosition?.[2]?.toFixed(2) ?? ''; dom.animTargetRotX.value = THREE.MathUtils.radToDeg(anim?.targetRotation?.[0] ?? 0).toFixed(1); dom.animTargetRotY.value = THREE.MathUtils.radToDeg(anim?.targetRotation?.[1] ?? 0).toFixed(1); dom.animTargetRotZ.value = THREE.MathUtils.radToDeg(anim?.targetRotation?.[2] ?? 0).toFixed(1); dom.animDuration.value = anim?.duration ?? 1.0; dom.animLoop.value = anim?.loop || 'once'; dom.animAutoStart.checked = anim?.autoStart ?? false; dom.animTriggerId.value = anim?.triggerId || ''; updateAnimationUIFields(animType); } else if (isSprite) { show(dom.spriteProps); show(dom.applyTextureContainerSprite,'flex'); dom.selectedFixedRotation.checked = !selectedObjectData.autoRotate; dom.selectedSizeAttenuation.checked = selectedObjectData.sizeAttenuation ?? false; dom.selectedDepthWrite.checked = selectedObjectData.depthWrite ?? false; dom.selectedAlphaTest.value = (selectedObjectData.alphaTest ?? 0.5).toFixed(2); dom.selectedCenterX.value = (selectedObjectData.center?.[0] ?? 0.5).toFixed(1); dom.selectedCenterY.value = (selectedObjectData.center?.[1] ?? 0.0).toFixed(1); dom.selectedTintColor.value = selectedObjectData.tintColor || '#ffffff'; const spriteTexPath = selectedObjectData.materialRef || ""; const spriteTextureItem = dom.textureGrid.querySelector(`.textureItem[data-texture-path="${CSS.escape(spriteTexPath)}"]`); if (spriteTextureItem && !spriteTextureItem.classList.contains('selected')) selectTextureItem(spriteTextureItem); else if (!spriteTextureItem && spriteTexPath !== selectedTexturePath) { const noneItem = dom.textureGrid.querySelector('.textureItem[data-texture-path=""]'); if (noneItem && !noneItem.classList.contains('selected')) selectTextureItem(noneItem); } } else if (isModelInstance) { hide(dom.geometryProps); hide(dom.spriteProps); show(dom.animationProps); show(dom.rotationSection); show(dom.scaleSection); dom.selectedIsCollider.checked = false; dom.selectedIsCollider.disabled = true; const anim = selectedObjectData.animation; const animType = anim?.type || 'translate'; dom.animType.value = animType; dom.animTargetPosX.value = anim?.targetPosition?.[0]?.toFixed(2) ?? ''; dom.animTargetPosY.value = anim?.targetPosition?.[1]?.toFixed(2) ?? ''; dom.animTargetPosZ.value = anim?.targetPosition?.[2]?.toFixed(2) ?? ''; dom.animTargetRotX.value = THREE.MathUtils.radToDeg(anim?.targetRotation?.[0] ?? 0).toFixed(1); dom.animTargetRotY.value = THREE.MathUtils.radToDeg(anim?.targetRotation?.[1] ?? 0).toFixed(1); dom.animTargetRotZ.value = THREE.MathUtils.radToDeg(anim?.targetRotation?.[2] ?? 0).toFixed(1); dom.animDuration.value = anim?.duration ?? 1.0; dom.animLoop.value = anim?.loop || 'once'; dom.animAutoStart.checked = anim?.autoStart ?? false; dom.animTriggerId.value = anim?.triggerId || ''; updateAnimationUIFields(animType); } else if (isMarker && fullUpdate) { show(dom.selectedSpawnerProps); dom.selectedSpawnerProps.innerHTML = '<h4>Spawner/Trigger Properties</h4>'; const updatePropInput = (id, prop) => { const el = document.getElementById(id); if(el) { el.disabled = isLocked; el.addEventListener('input', (e) => { if(selectedObjectData) selectedObjectData[prop] = e.target.value || null; }); }}; const updatePropSelect = (id, prop, statusMsg) => { const el = document.getElementById(id); if(el) { el.disabled = isLocked; el.addEventListener('change', (e) => { if(selectedObjectData) { selectedObjectData[prop] = e.target.value; if(statusMsg) showStatus(statusMsg); } }); }}; const updatePropCheckbox = (id, prop) => { const el = document.getElementById(id); if(el) { el.disabled = isLocked; el.addEventListener('change', (e) => { if(selectedObjectData) selectedObjectData[prop] = e.target.checked; }); }}; const updatePropNumber = (id, prop) => { const el = document.getElementById(id); if(el) { el.disabled = isLocked; el.addEventListener('input', (e) => { if(selectedObjectData) selectedObjectData[prop] = parseFloat(e.target.value) || 0; }); }}; if (selectedObjectData.type === 'item') { dom.selectedSpawnerProps.innerHTML += `<label for=prop_itemType>Item Type:</label><select id=prop_itemType>${itemTypes.map(t => `<option value="${t}" ${selectedObjectData.itemType === t ? 'selected' : ''}>${t}</option>`).join('')}</select><label for=prop_itemId>Unique Item ID:</label><input type=text id=prop_itemId value="${selectedObjectData.itemId || ''}">`; setTimeout(() => { updatePropSelect('prop_itemType', 'itemType', "Item type updated."); updatePropInput('prop_itemId', 'itemId'); }, 0); } else if (selectedObjectData.type === 'enemy') { dom.selectedSpawnerProps.innerHTML += `<label for=prop_enemyType>Enemy Type:</label><select id=prop_enemyType>${enemyTypes.map(t => `<option value="${t}" ${selectedObjectData.enemyType === t ? 'selected' : ''}>${t}</option>`).join('')}</select>`; setTimeout(() => updatePropSelect('prop_enemyType', 'enemyType', "Enemy type updated."), 0); } else if (selectedObjectData.type === 'level_trigger') { dom.selectedSpawnerProps.innerHTML += `<label for=prop_targetLevel>Target Level File:</label><input type=text id=prop_targetLevel value="${selectedObjectData.targetLevel || ''}"><div><label>Trigger Area:</label><small>Defined by game logic.</small></div>`; setTimeout(() => updatePropInput('prop_targetLevel', 'targetLevel'), 0); } else if (selectedObjectData.type === 'player_start') { dom.selectedSpawnerProps.innerHTML += `<div><label>Facing Direction:</label><small>Set by marker Y rotation.</small></div>`; } else if (selectedObjectData.type === 'door_trigger') { dom.selectedSpawnerProps.innerHTML += `<label for=prop_targetTriggerId>Target Trigger ID:</label><input type=text id=prop_targetTriggerId value="${selectedObjectData.targetTriggerId || ''}" placeholder="e.g., door_1_anim"><label for=prop_requiredKey>Required Key ID (optional):</label><input type=text id=prop_requiredKey value="${selectedObjectData.requiredKey || ''}" placeholder="e.g., keycard_office"><label for=prop_oneShot><input type=checkbox id=prop_oneShot ${selectedObjectData.oneShot ? 'checked' : ''}> One Shot Trigger</label>`; setTimeout(() => { updatePropInput('prop_targetTriggerId', 'targetTriggerId'); updatePropInput('prop_requiredKey', 'requiredKey'); updatePropCheckbox('prop_oneShot', 'oneShot'); }, 0); } else if (selectedObjectData.type === 'proximity_trigger') { dom.selectedSpawnerProps.innerHTML += `<label for=prop_targetTriggerId>Target Trigger ID:</label><input type=text id=prop_targetTriggerId value="${selectedObjectData.targetTriggerId || ''}" placeholder="e.g., trap_door_anim"><label for=prop_radius>Trigger Radius:</label><input type=number step=0.1 min=0.1 id=prop_radius value="${selectedObjectData.radius || 3.0}"><label for=prop_oneShot><input type=checkbox id=prop_oneShot ${selectedObjectData.oneShot ? 'checked' : ''}> One Shot Trigger</label>`; setTimeout(() => { updatePropInput('prop_targetTriggerId', 'targetTriggerId'); updatePropNumber('prop_radius', 'radius'); updatePropCheckbox('prop_oneShot', 'oneShot'); }, 0); } } const elementsToDisableIfLocked = [dom.selectedName, dom.selectedPosX, dom.selectedPosY, dom.selectedPosZ, dom.selectedRotX, dom.selectedRotY, dom.selectedRotZ, dom.selectedScaleX, dom.selectedScaleY, dom.selectedScaleZ, dom.selectedIsCollider, dom.texScaleU, dom.texScaleV, dom.texOffsetU, dom.texOffsetV, dom.selectedIsTransparent, dom.selectedPlaneAlphaTest, dom.applyTexture, dom.applyTextureAll, dom.applyTextureSprite, dom.selectedFixedRotation, dom.selectedSizeAttenuation, dom.selectedDepthWrite, dom.selectedAlphaTest, dom.selectedCenterX, dom.selectedCenterY, dom.selectedTintColor, dom.animType, dom.animTargetPosX, dom.animTargetPosY, dom.animTargetPosZ, dom.animTargetRotX, dom.animTargetRotY, dom.animTargetRotZ, dom.setAnimTarget, dom.animDuration, dom.animLoop, dom.animAutoStart, dom.animTriggerId, dom.previewAnim, dom.clearAnim]; dom.faceSelector.querySelectorAll('button').forEach(btn => btn.disabled = isLocked); elementsToDisableIfLocked.forEach(el => { if(el) el.disabled = isLocked; }); } else { hide(dom.selectedObjectInfo); updateModeInfoUI('translate'); } }
        function updateSelectedDataFromUI(event) { if (!selectedObjectData || !selectedMesh) return; const sourceElementId = event?.target?.id; if (sourceElementId === 'selectedIsLocked') { selectedObjectData.isLocked = dom.selectedIsLocked.checked; if (selectedObjectData.isLocked) { transformControls.detach(); } else { transformControls.attach(selectedMesh); } updateSelectedObjectUI(false); setGizmoMode(transformControls.getMode(), false); render(); return; } if (selectedObjectData.isLocked) return; selectedObjectData.name = dom.selectedName.value.trim(); selectedObjectData.isVisible = dom.selectedIsVisible.checked; selectedMesh.visible = selectedObjectData.isVisible; const isGeometry = selectedMesh.userData.isGeometry; const isSprite = selectedMesh.userData.isSprite; const isMarker = selectedMesh.userData.isMarker; const isModelInstance = selectedMesh.userData.isModelInstance; const isPlane = selectedObjectData?.type === 'plane'; const isBox = selectedObjectData?.type === 'box'; const getFloat = (id) => parseFloat(dom[id].value) || 0; const getClamp = (id, min, max, def) => Math.max(min, Math.min(max, parseFloat(dom[id].value) || def)); const getDeg = (id) => THREE.MathUtils.degToRad(getFloat(id)); selectedObjectData.position = [getFloat('selectedPosX'), getFloat('selectedPosY'), getFloat('selectedPosZ')]; selectedMesh.position.fromArray(selectedObjectData.position); if (isSprite) { const isFixedRotation = dom.selectedFixedRotation.checked; selectedObjectData.autoRotate = !isFixedRotation; if (sourceElementId === 'selectedFixedRotation' || (sourceElementId?.startsWith('selectedRot') && isFixedRotation)) { selectedObjectData.rotation = [getDeg('selectedRotX'), getDeg('selectedRotY'), getDeg('selectedRotZ')]; _tempEuler.fromArray(selectedObjectData.rotation); selectedMesh.quaternion.setFromEuler(_tempEuler); } else if (!isFixedRotation) { selectedObjectData.rotation = [0, getDeg('selectedRotY'), 0]; selectedMesh.rotation.y = selectedObjectData.rotation[1]; selectedMesh.rotation.x = 0; selectedMesh.rotation.z = 0; } else { selectedMesh.quaternion.identity(); } } else if (isGeometry || isModelInstance) { selectedObjectData.rotation = [getDeg('selectedRotX'), getDeg('selectedRotY'), getDeg('selectedRotZ')]; selectedMesh.rotation.fromArray(selectedObjectData.rotation); selectedMesh.quaternion.setFromEuler(selectedMesh.rotation); } else if (isMarker) { const newRotY = getDeg('selectedRotY'); selectedObjectData.rotationY = newRotY; selectedMesh.rotation.y = newRotY; selectedMesh.rotation.x = 0; selectedMesh.rotation.z = 0; } if (isGeometry || isSprite || isModelInstance) { let scaleX = Math.max(MIN_SCALE, getFloat('selectedScaleX') || MIN_SCALE); let scaleY = Math.max(MIN_SCALE, getFloat('selectedScaleY') || MIN_SCALE); let scaleZ = 1.0; if (isGeometry) { scaleZ = isPlane ? (selectedObjectData.scale[2] || MIN_SCALE) : Math.max(MIN_SCALE, getFloat('selectedScaleZ') || MIN_SCALE); } else if (isModelInstance) { scaleZ = Math.max(MIN_SCALE, getFloat('selectedScaleZ') || MIN_SCALE); } selectedObjectData.scale = [scaleX, scaleY, scaleZ]; selectedMesh.scale.set(scaleX, scaleY, scaleZ); } else if (isMarker) { selectedObjectData.scale = [1, 1, 1]; selectedMesh.scale.set(1, 1, 1); } if (isGeometry || isModelInstance) { const animType = dom.animType.value; const hasTargetPos = dom.animTargetPosX.value.trim() !== ''; const hasTargetRot = dom.animTargetRotX.value.trim() !== ''; if (hasTargetPos || hasTargetRot) { if (!selectedObjectData.animation) selectedObjectData.animation = {}; selectedObjectData.animation.type = animType; if (animType === 'translate' && hasTargetPos) { selectedObjectData.animation.targetPosition = [getFloat('animTargetPosX'), getFloat('animTargetPosY'), getFloat('animTargetPosZ')]; delete selectedObjectData.animation.targetRotation; } else if (animType === 'rotate' && hasTargetRot) { selectedObjectData.animation.targetRotation = [getDeg('animTargetRotX'), getDeg('animTargetRotY'), getDeg('animTargetRotZ')]; delete selectedObjectData.animation.targetPosition; } else { delete selectedObjectData.animation.targetPosition; delete selectedObjectData.animation.targetRotation; } selectedObjectData.animation.duration = Math.max(0.1, getFloat('animDuration') || 1.0); selectedObjectData.animation.loop = dom.animLoop.value; selectedObjectData.animation.autoStart = dom.animAutoStart.checked; selectedObjectData.animation.triggerId = dom.animTriggerId.value.trim() || null; } else selectedObjectData.animation = null; updateAnimationUIFields(animType); } if (isGeometry) { selectedObjectData.isCollider = dom.selectedIsCollider.checked; selectedMesh.userData.isCollider = selectedObjectData.isCollider; const scaleU = getFloat('texScaleU') || 1; const scaleV = getFloat('texScaleV') || 1; const offsetU = getFloat('texOffsetU'); const offsetV = getFloat('texOffsetV'); let targetMaterial; let targetMatData; let materialNeedsUpdate = false; if (isBox && selectedFaceIndex >= 0 && selectedFaceIndex < 6 && selectedObjectData.materials) { targetMatData = selectedObjectData.materials[selectedFaceIndex]; targetMaterial = selectedMesh.material[selectedFaceIndex]; } else if (isPlane) { targetMatData = selectedObjectData.material; targetMaterial = selectedMesh.material; if (sourceElementId === 'selectedIsTransparent' || sourceElementId === 'selectedPlaneAlphaTest') { const isTransparent = dom.selectedIsTransparent.checked; const alphaTest = getClamp('selectedPlaneAlphaTest', 0, 1, 0.1); if (!targetMatData.materialProps) targetMatData.materialProps = {}; targetMatData.materialProps.transparent = isTransparent; targetMatData.materialProps.alphaTest = isTransparent ? alphaTest : 0.0; materialNeedsUpdate = true; dom.selectedPlaneAlphaTest.disabled = !isTransparent; } } if (targetMatData) { targetMatData.scale = [scaleU, scaleV]; targetMatData.offset = [offsetU, offsetV]; } if (targetMaterial) updateMaterialTextureTransform(targetMaterial, [scaleU, scaleV], [offsetU, offsetV]); if (materialNeedsUpdate && isPlane) { if (selectedMesh.material?.map) selectedMesh.material.map.dispose(); if (selectedMesh.material) selectedMesh.material.dispose(); const newMaterial = getMaterial(targetMatData.ref, false, null, targetMatData.materialProps || {}).clone(); newMaterial.wireframe = dom.toggleWireframe.checked; if (newMaterial.map) updateMaterialTextureTransform(newMaterial, targetMatData.scale, targetMatData.offset); selectedMesh.material = newMaterial; } } if (isSprite) { selectedObjectData.sizeAttenuation = dom.selectedSizeAttenuation.checked; selectedObjectData.depthWrite = dom.selectedDepthWrite.checked; selectedObjectData.alphaTest = getClamp('selectedAlphaTest', 0, 1, 0.5); selectedObjectData.center = [getClamp('selectedCenterX', 0, 1, 0.5), getClamp('selectedCenterY', 0, 1, 0.0)]; selectedObjectData.tintColor = dom.selectedTintColor.value || '#ffffff'; selectedMesh.center.fromArray(selectedObjectData.center); if (selectedMesh.material && selectedMesh.material.isSpriteMaterial) { selectedMesh.material.color.set(selectedObjectData.tintColor); selectedMesh.material.sizeAttenuation = selectedObjectData.sizeAttenuation; selectedMesh.material.depthWrite = selectedObjectData.depthWrite; selectedMesh.material.alphaTest = selectedObjectData.alphaTest; selectedMesh.material.transparent = (selectedObjectData.alphaTest < 1.0); selectedMesh.material.needsUpdate = true; } else selectedMesh.material = getMaterial(selectedObjectData.materialRef, true, selectedObjectData); if (sourceElementId === 'selectedFixedRotation' || sourceElementId?.startsWith('selectedRot')) { updateSelectedObjectUI(false); setGizmoMode(transformControls.getMode(), false); } } render(); }
        function updateAnimationUIFields(animType) { dom.animTargetPos.style.display = animType==='translate'?'block':'none'; dom.animTargetRot.style.display = animType==='rotate'?'block':'none'; }
        function setAnimationTarget() { if (!selectedMesh || !selectedObjectData || selectedObjectData.isLocked || (!selectedMesh.userData.isGeometry && !selectedMesh.userData.isModelInstance)) return; if (!selectedObjectData.animation) selectedObjectData.animation = {}; const animType = dom.animType.value; selectedObjectData.animation.type = animType; const initialPos = selectedMesh.userData.initialPosition; const initialRot = selectedMesh.userData.initialRotation; const currentPos = selectedMesh.position; const currentRot = selectedMesh.rotation; if (animType === 'translate') { const targetPosOffset = currentPos.clone().sub(initialPos); selectedObjectData.animation.targetPosition = targetPosOffset.toArray(); delete selectedObjectData.animation.targetRotation; showStatus("Target position offset set."); } else if (animType === 'rotate') { selectedObjectData.animation.targetRotation = [currentRot.x, currentRot.y, currentRot.z]; delete selectedObjectData.animation.targetPosition; showStatus("Target absolute rotation set."); } selectedObjectData.animation.duration = Math.max(0.1, parseFloat(dom.animDuration.value) || 1.0); selectedObjectData.animation.loop = dom.animLoop.value; selectedObjectData.animation.autoStart = dom.animAutoStart.checked; selectedObjectData.animation.triggerId = dom.animTriggerId.value.trim() || null; updateSelectedObjectUI(); }
        function clearAnimationData() { if (!selectedObjectData || selectedObjectData.isLocked || (!selectedMesh.userData.isGeometry && !selectedMesh.userData.isModelInstance)) return; if (animationPreviewState.isPlaying && animationPreviewState.mesh === selectedMesh) { resetToInitialTransform(selectedMesh); animationPreviewState.isPlaying = false; transformControls.attach(selectedMesh); } selectedObjectData.animation = null; updateSelectedObjectUI(); showStatus("Animation data cleared."); }
        function resetToInitialTransform(mesh) { if (!mesh || !mesh.userData.initialPosition) return; mesh.position.copy(mesh.userData.initialPosition); if ((mesh.userData.isGeometry || mesh.userData.isModelInstance) && mesh.userData.initialRotation) { mesh.rotation.copy(mesh.userData.initialRotation); mesh.quaternion.setFromEuler(mesh.rotation); } else if (mesh.userData.isMarker) { const objData = findObjectDataById(mesh.userData.dataId); mesh.rotation.y = objData?.rotationY || 0; mesh.rotation.x = 0; mesh.rotation.z = 0; } else if (mesh.isSprite) { const spriteData = findObjectDataById(mesh.userData.dataId); if (spriteData) { if (spriteData.autoRotate) { mesh.quaternion.identity(); } else if (spriteData.rotation) { _tempEuler.fromArray(spriteData.rotation); mesh.quaternion.setFromEuler(_tempEuler); } else { mesh.quaternion.identity(); } } } if (mesh.userData.isModelInstance && mesh.userData.initialScale) { mesh.scale.copy(mesh.userData.initialScale); } render(); }
        function previewAnimation() { if (animationPreviewState.isPlaying) { if (animationPreviewState.mesh) { resetToInitialTransform(animationPreviewState.mesh); if(selectedMesh === animationPreviewState.mesh && !(selectedObjectData?.isLocked)) transformControls.attach(animationPreviewState.mesh); } animationPreviewState.isPlaying = false; showStatus("Preview stopped."); return; } if (!selectedMesh || !selectedObjectData?.animation || selectedObjectData.isLocked || (!selectedMesh.userData.isGeometry && !selectedMesh.userData.isModelInstance)) { showStatus("Select unlocked object with valid animation data.", 4000); return; } const anim = selectedObjectData.animation; const mesh = selectedMesh; resetToInitialTransform(mesh); animationPreviewState.mesh = mesh; animationPreviewState.isPlaying = true; animationPreviewState.startTime = performance.now(); animationPreviewState.duration = (anim.duration || 1.0) * 1000; animationPreviewState.type = anim.type; animationPreviewState.loop = anim.loop || 'once'; animationPreviewState.direction = 1; if (anim.type === 'translate' && anim.targetPosition) { animationPreviewState.startPos = mesh.userData.initialPosition.clone(); animationPreviewState.targetPos = mesh.userData.initialPosition.clone().add(new THREE.Vector3().fromArray(anim.targetPosition)); animationPreviewState.startRot = null; animationPreviewState.targetRot = null; } else if (anim.type === 'rotate' && anim.targetRotation) { animationPreviewState.startPos = null; animationPreviewState.targetPos = null; animationPreviewState.startRot = new THREE.Quaternion().setFromEuler(mesh.userData.initialRotation); animationPreviewState.targetRot = new THREE.Quaternion().setFromEuler(new THREE.Euler().fromArray(anim.targetRotation)); } else { showStatus("Invalid animation data for preview.", 4000); animationPreviewState.isPlaying = false; return; } transformControls.detach(); showStatus("Playing animation preview..."); }
        function onKeyDown(event) { const activeElement=document.activeElement,isInputFocused=activeElement&&(activeElement.tagName==='INPUT'||activeElement.tagName==='SELECT'||activeElement.tagName==='TEXTAREA'); if((isInputFocused || dom.modelMenu.style.display === 'flex') && event.key!=='Escape') return; let targetMode = null; switch (event.key.toLowerCase()) { case 'g': targetMode='translate'; break; case 'r': targetMode='rotate'; break; case 's': targetMode='scale'; break; case ' ': event.preventDefault(); if (selectedMesh && !isPlacingDecal) cycleTransformMode(['rotate','scale']); return; case 'q': if (transformControls.object && !isPlacingDecal && !selectedObjectData?.isLocked) { transformControls.setSpace(transformControls.space==="local"?"world":"local"); showStatus(`Gizmo space: ${transformControls.space}`, 1500); render(); } break; case 'delete': case 'backspace': if (!isInputFocused && !isPlacingDecal && selectedMesh && !selectedObjectData?.isLocked) { if (confirm('Are you sure you want to delete this object?')) { deleteSelected(); } } break; case 'd': if ((event.ctrlKey||event.metaKey) && !isPlacingDecal && selectedMesh) { event.preventDefault(); cloneSelected(); } break; case 'shift': isShiftPressed=true; if (transformControls.getMode()==='scale'&&transformControls.dragging) transformControls.setScaleSnap(null); break; case 'escape': if (dom.modelMenu.style.display === 'flex') hideModelMenu(); else if (isPlacingDecal) toggleDecalMode(); else deselectObject(); break; default: return; } if (targetMode && !isPlacingDecal) { event.preventDefault(); setGizmoMode(targetMode, true); } }
        function onKeyUp(event) { switch (event.key.toLowerCase()) { case 'shift': isShiftPressed=false; if (transformControls.getMode()==='scale') { const snap=dom.snapToGrid.checked; transformControls.setScaleSnap(snap?SNAP_SCALE:null); if (!transformControls.dragging && !selectedObjectData?.isLocked) onObjectTransform(); } break; } }

        function exportLevelData() {
            const exportData = {
                levelName: "Custom Level",
                textures: {},
                modelDefinitions: {},
                geometry: [],
                prefabs: [],
                spawners: [],
                sprites: [],
                modelInstances: []
            };
            const usedTextures = new Set();
            const usedModelNames = new Set();
            levelData.geometry.forEach(geo => {
                const copy = JSON.parse(JSON.stringify(geo));
                if (copy.type === 'box' && copy.materials) {
                    copy.materials.forEach(mat => { if (mat?.ref) usedTextures.add(mat.ref); });
                } else if (copy.material?.ref) {
                    usedTextures.add(copy.material.ref);
                }
                exportData.geometry.push(copy);
            });
            levelData.sprites.forEach(sprite => {
                const copy = JSON.parse(JSON.stringify(sprite));
                if (copy.materialRef) {
                    usedTextures.add(copy.materialRef);
                }
                exportData.sprites.push(copy);
            });
            levelData.prefabs.forEach(prefab => {
                 exportData.prefabs.push(JSON.parse(JSON.stringify(prefab)));
            });
            levelData.spawners.forEach(spawner => {
                 exportData.spawners.push(JSON.parse(JSON.stringify(spawner)));
            });
            levelData.modelInstances.forEach(instanceData => {
                exportData.modelInstances.push(JSON.parse(JSON.stringify(instanceData)));
                usedModelNames.add(instanceData.modelName);
                const definition = loadedModelDefinitions[instanceData.modelName];
                if (definition && definition.textures) {
                    Object.values(definition.textures).forEach(textureFilename => {
                        if (textureFilename) {
                             usedTextures.add(IMG_PREFIX + textureFilename);
                        }
                    });
                }
            });
            usedModelNames.forEach(modelName => {
                if (loadedModelDefinitions[modelName]) {
                    exportData.modelDefinitions[modelName] = JSON.parse(JSON.stringify(loadedModelDefinitions[modelName]));
                }
            });
            let textureCounter = 1;
            const texturePathToKeyMap = {};
            usedTextures.forEach(path => {
                if (path){
                     const key = `tex${textureCounter.toString().padStart(2, '0')}`;
                     exportData.textures[key] = path;
                     texturePathToKeyMap[path] = key;
                     textureCounter++;
                }
            });
            const resolveRef = (refPath) => texturePathToKeyMap[refPath] || null;
            exportData.geometry.forEach(geo => {
                if (geo.type === 'box' && geo.materials) {
                    geo.materials.forEach(mat => { if (mat) mat.ref = resolveRef(mat.ref); });
                } else if (geo.material) {
                    geo.material.ref = resolveRef(geo.material.ref);
                }
            });
            exportData.sprites.forEach(sprite => {
                sprite.materialRef = resolveRef(sprite.materialRef);
            });
            try {
                const jsonString = JSON.stringify(exportData, null, 2);
                const blob = new Blob([jsonString], { type: 'application/json' });
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                const fileName = `${exportData.levelName.replace(/\s+/g, '_') || 'level'}_export.json`;
                link.download = fileName;
                link.click();
                URL.revokeObjectURL(link.href);
                showStatus("Map exported successfully.");
            } catch (error) {
                console.error("Error during JSON export:", error);
                showStatus("Error exporting map!", 5000);
            }
        }
        function loadLevelDataFromFile(event) { const file = event.target.files[0]; if (!file) return; const reader = new FileReader(); reader.onload = async (e) => { try { const jsonData = JSON.parse(e.target.result); await clearScene(); if (!jsonData || typeof jsonData !== 'object') throw new Error("Invalid JSON structure."); levelData.geometry = jsonData.geometry || []; levelData.prefabs = jsonData.prefabs || []; levelData.spawners = jsonData.spawners || []; levelData.sprites = jsonData.sprites || []; levelData.modelInstances = jsonData.modelInstances || []; const textureMap = jsonData.textures || {}; const embeddedModelDefinitions = jsonData.modelDefinitions || {}; for (const modelName in embeddedModelDefinitions) { if (!loadedModelDefinitions[modelName]) { loadedModelDefinitions[modelName] = embeddedModelDefinitions[modelName]; console.log(`Loaded embedded model definition: ${modelName}`); } } const resolveMaterialRef = (refKey) => textureMap[refKey] || null; for (const geoData of levelData.geometry) { if (geoData.type === 'box' && geoData.materials) geoData.materials.forEach(mat => { if (mat) mat.ref = resolveMaterialRef(mat.ref); }); else if (geoData.material) { geoData.material.ref = resolveMaterialRef(geoData.material.ref); if (!geoData.material.materialProps) geoData.material.materialProps = { transparent: false, alphaTest: 0.0 }; } if (geoData.isVisible === undefined) geoData.isVisible = true; if (geoData.isLocked === undefined) geoData.isLocked = false; const mesh = createMeshFromData(geoData); if (mesh) scene.add(mesh); } for (const prefabData of levelData.prefabs) { if (prefabData.isVisible === undefined) prefabData.isVisible = true; if (prefabData.isLocked === undefined) prefabData.isLocked = false; let prefabObject = createMarkerMesh(prefabData); if (prefabObject) scene.add(prefabObject); } for (const spawnerData of levelData.spawners) { if (spawnerData.isVisible === undefined) spawnerData.isVisible = true; if (spawnerData.isLocked === undefined) spawnerData.isLocked = false; const marker = createMarkerMesh(spawnerData); if (marker) scene.add(marker); } for (const spriteData of levelData.sprites) { spriteData.materialRef = resolveMaterialRef(spriteData.materialRef); if (spriteData.autoRotate === undefined) spriteData.autoRotate = true; if (spriteData.isVisible === undefined) spriteData.isVisible = true; if (spriteData.isLocked === undefined) spriteData.isLocked = false; const sprite = createSpriteMesh(spriteData); if (sprite) scene.add(sprite); } if (levelData.modelInstances.length > 0) { showStatus("Loading model instances...", 2000); for (const instanceData of levelData.modelInstances) { if (instanceData.isVisible === undefined) instanceData.isVisible = true; if (instanceData.isLocked === undefined) instanceData.isLocked = false; const definition = await loadModelDefinition(instanceData.modelName); if (definition) { const modelGroup = createModelGroup(instanceData, definition); if (modelGroup) { scene.add(modelGroup); } else { console.warn(`Failed to recreate model instance on load: ${instanceData.modelName}`); } } else { console.warn(`Model definition ${instanceData.modelName} not found during load (embedded or fetched).`); } } } render(); showStatus("Map loaded successfully."); } catch (error) { console.error("Error loading map file:", error); alert(`Failed to load map file:\n${error.message}`); showStatus("Error loading map!", 5000); await clearScene(); } finally { event.target.value = null; } }; reader.onerror = (e) => { console.error("Error reading file:", e); alert("Failed to read map file."); showStatus("Error reading file!", 5000); event.target.value = null; }; reader.readAsText(file); }
        async function clearScene() { deselectObject(false); const objectsToRemove = scene.children.filter(child => child.userData.dataId && (findObjectDataById(child.userData.dataId) || child.userData.isModelInstance) ); objectsToRemove.forEach(obj => { const dispose = (o) => { if (o.geometry) o.geometry.dispose(); if (o.material) { if (Array.isArray(o.material)) o.material.forEach(mat => { if (mat?.map && !mat.userData.mapCloned) mat.map.dispose(); if(mat) mat.dispose(); }); else { if (o.material.map && !o.material.userData.mapCloned) o.material.map.dispose(); if (o.material.dispose) o.material.dispose(); } } }; if (obj.isGroup) { obj.traverse(child => { if (child.isMesh) dispose(child); }); } else { dispose(obj); } scene.remove(obj); }); levelData = { geometry: [], prefabs: [], spawners: [], sprites: [], modelInstances: [] }; loadedTextures = {}; loadedMaterials = {}; loadedSpriteMaterials = {}; dom.toggleWireframe.checked = localStorage.getItem('editor_wireframe') === 'true'; dom.toggleGrid.checked = localStorage.getItem('editor_grid') !== 'false'; gridHelper.visible = dom.toggleGrid.checked; populateTextureUI(); await Promise.resolve(); render(); showStatus("Scene cleared."); }
        function showStatus(message, duration=STATUS_MESSAGE_DURATION) { if (!dom.statusBar) return; dom.statusBar.textContent = message; if (statusTimeout) clearTimeout(statusTimeout); statusTimeout = setTimeout(() => { if (dom.statusBar.textContent === message) dom.statusBar.textContent = '-'; statusTimeout = null; }, duration); }
        function animate() { requestAnimationFrame(animate); const delta = clock.getDelta(); orbitControls.update(); if (animationPreviewState.isPlaying && animationPreviewState.mesh) { const now = performance.now(); let elapsed = (now - animationPreviewState.startTime); let progress = 0; let finished = false; if (animationPreviewState.loop === 'once') { progress = Math.min(elapsed / animationPreviewState.duration, 1.0); if (progress >= 1.0) finished = true; } else if (animationPreviewState.loop === 'loop') { elapsed = elapsed % animationPreviewState.duration; progress = elapsed / animationPreviewState.duration; } else if (animationPreviewState.loop === 'pingpong') { const cycleTime = animationPreviewState.duration * 2; elapsed = elapsed % cycleTime; if (elapsed > animationPreviewState.duration) { progress = 1.0 - ((elapsed - animationPreviewState.duration) / animationPreviewState.duration); animationPreviewState.direction = -1; } else { progress = elapsed / animationPreviewState.duration; animationPreviewState.direction = 1; } } const easedProgress = 0.5 - 0.5 * Math.cos(progress * Math.PI); const mesh = animationPreviewState.mesh; if (animationPreviewState.type === 'translate' && animationPreviewState.startPos && animationPreviewState.targetPos) mesh.position.lerpVectors(animationPreviewState.startPos, animationPreviewState.targetPos, easedProgress); else if (animationPreviewState.type === 'rotate' && animationPreviewState.startRot && animationPreviewState.targetRot) { THREE.Quaternion.slerp(animationPreviewState.startRot, animationPreviewState.targetRot, mesh.quaternion, easedProgress); mesh.rotation.setFromQuaternion(mesh.quaternion, mesh.rotation.order); } if (finished) { animationPreviewState.isPlaying = false; resetToInitialTransform(animationPreviewState.mesh); if (selectedMesh === animationPreviewState.mesh && !(selectedObjectData?.isLocked)) transformControls.attach(animationPreviewState.mesh); showStatus("Preview finished."); } } render(delta); }
        function render(delta) { scene.traverse(obj => { if (obj.isSprite && obj.userData.isSprite && camera) { const spriteData = findObjectDataById(obj.userData.dataId); if (!spriteData) return; const autoRotate = spriteData.autoRotate ?? true; if (autoRotate) { camera.getWorldPosition(_camPos); obj.getWorldPosition(_spritePos); _targetDir.set(_camPos.x - _spritePos.x, 0, _camPos.z - _spritePos.z).normalize(); let angleY = Math.atan2(_targetDir.x, _targetDir.z); _spriteQuaternion.setFromAxisAngle(_yAxis, angleY); if (!obj.quaternion.equals(_spriteQuaternion)) obj.quaternion.copy(_spriteQuaternion); } else { if (spriteData.rotation && Array.isArray(spriteData.rotation)) { _tempEuler.fromArray(spriteData.rotation); _spriteQuaternion.setFromEuler(_tempEuler); if (!obj.quaternion.equals(_spriteQuaternion)) obj.quaternion.copy(_spriteQuaternion); } else { if (!obj.quaternion.equals(_identityQuaternion)) obj.quaternion.identity(); } } } }); if (composer) composer.render(delta); else renderer.render(scene, camera); }
        function onWindowResize() { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); composer.setSize(window.innerWidth, window.innerHeight); outlinePass.resolution.set(window.innerWidth, window.innerHeight); render(); }
        init();

    </script>
</body>
</html>
