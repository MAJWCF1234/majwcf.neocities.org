<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Elevator Min Fixed Reduced</title>
    <style>body{margin:0;overflow:hidden;background:#222}canvas{display:block}</style>
</head>
<body>
    <canvas id="c"></canvas>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script>
const S=new THREE.Scene(),C=new THREE.PerspectiveCamera(75,innerWidth/innerHeight,.1,100),R=new THREE.WebGLRenderer({canvas:document.getElementById('c'),antialias:true});R.setSize(innerWidth,innerHeight);R.setClearColor(0x111111);const CW=2,CH=2.5,CD=2.2,WT=.05,DW=CW/2,DT=.04,FT=.06,FW=.1,DSP=.8,DWT=3;const AL=new THREE.AmbientLight(0xcccccc,.6),HL=new THREE.HemisphereLight(0xddddff,0x666688,.3),PL=new THREE.PointLight(0xffffff,.6,15);PL.position.set(0,CH*.85,0);S.add(AL,HL);const O=new THREE.OrbitControls(C,R.domElement);Object.assign(O,{enablePan:1,enableZoom:1,minDistance:.5,maxDistance:8});O.target.set(0,CH*.5,-CD*.2);O.update();const TL=new THREE.TextureLoader(),M={},TF={d:'images/elevator_door.png',w:'images/elevator_wall.png',f:'images/elevator_floor.png',c:'images/elevator_ceiling.png'};const L=(k,fc)=>new Promise(rs=>{let s=k=='d'?THREE.DoubleSide:THREE.FrontSide;TL.load(TF[k],t=>{t.wrapS=t.wrapT=THREE.RepeatWrapping;const rv=k=='f'||k=='c'||k=='w'?2:1;t.repeat.set(rv,rv);M[k]=new THREE.MeshStandardMaterial({map:t,side:s,metalness:k=='d'?.6:.3,roughness:k=='d'?.4:.7});rs()},0,()=>{M[k]=new THREE.MeshStandardMaterial({color:fc,side:s,metalness:.3,roughness:.7});rs()})});let E,LD,RD,DS=0,P=0,DTW=DWT;function B(){if(!M.d||!M.w||!M.f||!M.c)return;E=new THREE.Group();S.add(E);E.add(PL);const hw=CW/2,hh=CH/2,hd=CD/2,wm=M.w;const fl=new THREE.Mesh(new THREE.PlaneGeometry(CW,CD),M.f);fl.rotation.x=-Math.PI/2;const ce=new THREE.Mesh(new THREE.PlaneGeometry(CW,CD),M.c);ce.rotation.x=Math.PI/2;ce.position.y=CH;const bwm=wm.clone();if(bwm.map)bwm.map.repeat.set(CW,CH);const bw=new THREE.Mesh(new THREE.BoxGeometry(CW,CH,WT),bwm);bw.position.set(0,hh,hd-WT/2);const swm=wm.clone();if(swm.map)swm.map.repeat.set(CD,CH);const lw=new THREE.Mesh(new THREE.BoxGeometry(WT,CH,CD),swm);lw.position.set(-hw+WT/2,hh,0);const rw=new THREE.Mesh(new THREE.BoxGeometry(WT,CH,CD),swm.clone());rw.position.set(hw-WT/2,hh,0);const fm=wm.clone();if(fm.map)fm.map.repeat.set(.5,.5);const fto=new THREE.Mesh(new THREE.BoxGeometry(CW,FW,FT),fm);fto.position.set(0,CH-FW/2,-hd-FT/2);const fsg=new THREE.BoxGeometry(FW,CH-FW,FT);const fle=new THREE.Mesh(fsg,fm.clone());fle.position.set(-hw+FW/2,hh-FW/2,-hd-FT/2);const fri=new THREE.Mesh(fsg,fm.clone());fri.position.set(hw-FW/2,hh-FW/2,-hd-FT/2);const dg=new THREE.BoxGeometry(DW,CH,DT);LD=new THREE.Mesh(dg,M.d);RD=new THREE.Mesh(dg,M.d.clone());const dz=-hd-FT/2+DT/2;LD.position.set(-DW/2,hh,dz);RD.position.set(DW/2,hh,dz);E.add(fl,ce,bw,lw,rw,fto,fle,fri,LD,RD);C.position.set(0,hh,CD);C.lookAt(0,hh,0);O.target.set(0,hh,0);}const CL=new THREE.Clock();function A(){requestAnimationFrame(A);const d=CL.getDelta();DTW-=d;if(DS===0&&DTW<=0){DS=1;DTW=DWT}else if(DS===2&&DTW<=0){DS=3;DTW=DWT}if(DS===1){P=Math.min(1,P+DSP*d);if(P===1)DS=2}else if(DS===3){P=Math.max(0,P-DSP*d);if(P===0)DS=0}if(LD&&RD){const sl=P*(DW*.95);LD.position.x=-DW/2-sl;RD.position.x=DW/2+sl}O.update();R.render(S,C)}window.addEventListener('resize',()=>{C.aspect=innerWidth/innerHeight;C.updateProjectionMatrix();R.setSize(innerWidth,innerHeight)},!1);Promise.all([L('d',0x999999),L('w',0xcccccc),L('f',0x665544),L('c',0xeeeeff)]).then(()=>{B();A()}).catch(e=>{console.error(e);B();A()});
    </script>
</body>
</html>