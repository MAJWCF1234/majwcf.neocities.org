<!DOCTYPE html>
<html lang=en>
<head>
    <meta charset=utf8>
    <title>Engine Rebuild v3.5.8</title>
    <meta name=viewport content=width=device-width,initial-scale=1>
    <style>
        :root{--bg-color-darkest:#1e1e1e;--bg-color-dark:#252526;--bg-color-medium:#333;--bg-color-light:#3c3c3c;--border-color:#4a4a4a;--text-color-primary:#d4d4d4;--text-color-secondary:#ccc;--text-color-muted:#999;--accent-color-primary:#007acc;--accent-color-secondary:#6c757d;--accent-color-danger:#cd3131;--selection-color:#094771;--highlight-color:#00aaff;--font-size-base:12px;--font-size-small:11px;--font-size-header:14px;--border-radius:3px;--padding-base:8px;--padding-small:4px}
        body{margin:0;overflow:hidden;font-family:Segoe UI,Frutiger,Frutiger Linotype,Dejavu Sans,Helvetica Neue,Arial,sans-serif;background-color:var(--bg-color-darkest);color:var(--text-color-primary);font-size:var(--font-size-base)}
        canvas{display:block}
        #ui{position:absolute;top:0;left:0;background:var(--bg-color-dark);padding:0;border-right:1px solid var(--border-color);color:var(--text-color-primary);z-index:10;width:260px;height:100vh;display:flex;flex-direction:column;box-shadow:2px 0 5px rgba(0,0,0,.3)}
        #ui-header{background-color:var(--bg-color-light);padding:var(--padding-small) var(--padding-base);border-bottom:1px solid var(--border-color);text-align:center;font-size:var(--font-size-header);font-weight:bold;flex-shrink:0;user-select:none}
        #ui-content{overflow-y:auto;flex-grow:1;padding:var(--padding-base)}
        #ui-content::-webkit-scrollbar{width:8px}
        #ui-content::-webkit-scrollbar-track{background:var(--bg-color-dark)}
        #ui-content::-webkit-scrollbar-thumb{background:var(--bg-color-light);border-radius:4px}
        #ui-content::-webkit-scrollbar-thumb:hover{background:var(--border-color)}
        #ui h3{font-size:var(--font-size-base);font-weight:bold;margin:12px 0 8px;padding-bottom:4px;border-bottom:1px solid var(--border-color);color:var(--text-color-secondary)}
        #ui h3:first-child{margin-top:0}
        #ui h4{font-size:var(--font-size-small);font-weight:bold;margin:10px 0 5px;color:var(--text-color-muted);text-transform:uppercase}
        #ui button{display:block;margin:5px 0;width:100%;padding:6px var(--padding-base);border:1px solid var(--border-color);border-radius:var(--border-radius);font-size:var(--font-size-base);cursor:pointer;background-color:var(--bg-color-light);color:var(--text-color-primary);transition:background-color .15s,border-color .15s;box-sizing:border-box;text-align:center}
        #ui button:hover:not(:disabled){background-color:var(--border-color);border-color:#5a5a5a}
        #ui button:active:not(:disabled){background-color:var(--selection-color);border-color:var(--accent-color-primary)}
        #ui button.primary{background-color:var(--accent-color-primary);border-color:var(--accent-color-primary);color:white}
        #ui button.primary:hover:not(:disabled){background-color:#005a9e;border-color:#005a9e}
        #ui button.secondary{background-color:var(--accent-color-secondary);border-color:var(--accent-color-secondary);color:white}
        #ui button.secondary:hover:not(:disabled){background-color:#5a6268;border-color:#545b62}
        #ui button.danger{background-color:var(--accent-color-danger);border-color:var(--accent-color-danger);color:white}
        #ui button.danger:hover:not(:disabled){background-color:#a71d1d;border-color:#a71d1d}
        #ui button:disabled{background-color:var(--bg-color-medium);border-color:var(--border-color);color:var(--text-color-muted);cursor:not-allowed;opacity:.6}
        #ui .section{margin-bottom:12px}
        #ui label{display:block;margin:8px 0 3px;font-size:var(--font-size-small);color:var(--text-color-muted)}
        #ui input[type=checkbox]{margin-right:5px;vertical-align:middle;accent-color:var(--accent-color-primary)}
        #ui label input[type=checkbox]{margin-top:-2px}
        #ui input[type=text],#ui input[type=number],#ui input[type=color],#ui select{width:100%;padding:4px 6px;margin-bottom:6px;background:var(--bg-color-darkest);color:var(--text-color-primary);border:1px solid var(--border-color);border-radius:var(--border-radius);font-size:var(--font-size-base);box-sizing:border-box;line-height:1.4}
        #ui input:focus,#ui select:focus{outline:none;border-color:var(--accent-color-primary);box-shadow:0 0 0 1px var(--accent-color-primary)}
        #ui input:disabled,#ui select:disabled{background-color:var(--bg-color-medium);color:var(--text-color-muted);cursor:not-allowed;opacity:.7}
        #ui input[type=color]{height:26px;padding:2px}
        #ui select{padding-right:20px;appearance:none;background:url('data:image/svg+xml;charset=US-ASCII,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 292.4 292.4%22%3E%3Cpath fill=%22%23ccc%22 d=%22M287 69.4a17.6 17.6 0 00-13-5.4H18.4c-5 0-9.3 1.8-12.9 5.4A17.6 17.6 0 000 82.2c0 5 1.8 9.3 5.4 12.9l128 127.9c3.6 3.6 7.8 5.4 12.8 5.4s9.2-1.8 12.8-5.4L287 95c3.5-3.5 5.4-7.8 5.4-12.8 0-5-1.9-9.2-5.4-12.8z%22/%3E%3C/svg%3E') no-repeat right 6px top 50%/8px auto var(--bg-color-darkest)}
        #textureGrid, #textureGridToony {display:grid;grid-template-columns:repeat(auto-fill,minmax(45px,1fr));gap:4px;margin-top:5px;max-height:145px;overflow-y:auto;background:var(--bg-color-darkest);padding:var(--padding-small);border-radius:var(--border-radius);border:1px solid var(--border-color)}
        .textureItem{width:45px;height:45px;background-color:var(--bg-color-medium);border:1px solid transparent;border-radius:var(--border-radius);cursor:pointer;background-size:cover;background-position:center;position:relative;display:inline-flex;justify-content:center;align-items:center;overflow:hidden;transition:border-color .15s}
        .textureItem:hover{border-color:var(--text-color-muted)}
        .textureItem.selected{border-color:var(--highlight-color);box-shadow:0 0 0 1px var(--highlight-color) inset}
        .textureItem[data-texture-path=""]{background:var(--bg-color-medium) none !important;border:1px dashed var(--border-color)}
        .textureItem[data-texture-path=""]::after{content:"None";color:var(--text-color-muted);font-size:10px;text-align:center}
        #selectedObjectInfo{margin-top:15px;border-top:1px solid var(--border-color);padding-top:10px;font-size:var(--font-size-base)}
        #selectedObjectInfo div{margin-bottom:4px}
        .coord-input-group,.half-input-group{display:flex;gap:4px;align-items:center}
        .coord-label{display:inline-block;width:10px;text-align:center;color:var(--text-color-muted);font-size:var(--font-size-small)}
        .coord-input,.half-input{flex:1;min-width:0;margin:0}
        .prop-section{margin-top:10px;padding-top:10px;border-top:1px solid var(--bg-color-light)}
        #currentModeInfo{margin-top:5px;font-style:italic;color:var(--text-color-muted);font-size:var(--font-size-small);text-align:center}
        #statusBar{padding:var(--padding-small) var(--padding-base);background-color:var(--bg-color-light);border-top:1px solid var(--border-color);font-size:var(--font-size-small);color:var(--text-color-muted);min-height:1.5em;line-height:1.5em;flex-shrink:0;user-select:none}
        .mode-button-group{display:flex;gap:4px;margin-bottom:10px}
        .mode-button-group button{flex:1;padding:5px;margin:0}
        .mode-button-group button.active,#faceSelector button.active, #addDecalPlane.active, .terrain-tool-buttons button.active, .paintSlot.active-paint {background-color:var(--selection-color);border-color:var(--accent-color-primary);color:var(--text-color-primary);box-shadow:inset 0 0 0 1px var(--accent-color-primary)}
        #instructionsPanel{position:fixed;top:5px;right:5px;width:200px;max-height:calc(100vh - 10px);background:rgba(37,37,38,.85);padding:0;border-radius:var(--border-radius);border:1px solid var(--border-color);color:var(--text-color-secondary);z-index:9;font-size:var(--font-size-small);overflow:hidden;box-shadow:0 2px 5px rgba(0,0,0,.3);transition:max-height .3s ease-out, padding .3s ease-out;}
        #instructionsPanel.collapsed{max-height:30px;padding-top:0;padding-bottom:0;}
        #instructionsPanel h3{margin:0;text-align:center;font-size:var(--font-size-base);border-bottom:1px solid var(--border-color);padding:6px 10px;margin-bottom:0;color:var(--text-color-primary);cursor:pointer;user-select:none;position:relative;}
        #instructionsPanel h3::after {content:'▲';position:absolute;right:10px;top:50%;transform:translateY(-50%);font-size:0.8em;transition:transform .3s ease-out;}
        #instructionsPanel.collapsed h3::after {transform:translateY(-50%) rotate(180deg);}
        #instructionsPanel-content {padding: 10px; overflow-y: auto; max-height: calc(100vh - 45px);}
        #instructionsPanel.collapsed #instructionsPanel-content {display: none;}
        #instructionsPanel ul{list-style:none;padding:0;margin:0 0 10px}
        #instructionsPanel li{margin-bottom:4px}
        #instructionsPanel kbd{background-color:var(--bg-color-light);border-radius:2px;padding:1px 3px;border:1px solid var(--border-color);font-family:Consolas,Monaco,'Andale Mono','Ubuntu Mono',monospace;font-size:.95em;margin-right:4px;color:var(--text-color-primary)}
        #animationProps .coord-input-group{margin-bottom:6px}
        #animationProps label,#textureProps label, #terrainEditingTools label {margin-top:6px;margin-bottom:2px;font-weight:normal;font-size:var(--font-size-small);color:var(--text-color-muted)}
        #animationProps select{margin-bottom:10px}
        #animationTargetFields{margin-top:5px}
        #textureProps .half-input-group{margin-bottom:4px}
        #terrainEditingTools .half-input-group {margin-bottom: 8px;}
        #faceSelector{display:grid;grid-template-columns:repeat(3,1fr);gap:4px;margin-bottom:10px}
        #faceSelector label{grid-column:1 / -1;margin-bottom:2px}
        #faceSelector button{padding:3px;font-size:10px;margin:0;line-height:1.2}
        small.unit{margin-left:3px;font-size:.9em;color:var(--text-color-muted)}
        #applyTextureContainer,#applyTextureContainerSprite{display:flex;gap:5px;margin-top:5px}
        #applyTextureContainer button,#applyTextureContainerSprite button{flex:1;margin:0}
        .modal-overlay{position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,.6);display:flex;justify-content:center;align-items:center;z-index:100}
        .modal-content{background:var(--bg-color-dark);border:1px solid var(--border-color);border-radius:var(--border-radius);width:80%;max-width:500px;max-height:70vh;display:flex;flex-direction:column;box-shadow:0 5px 15px rgba(0,0,0,.5)}
        .modal-header{display:flex;justify-content:space-between;align-items:center;padding:var(--padding-small) var(--padding-base);border-bottom:1px solid var(--border-color);background-color:var(--bg-color-light)}
        .modal-header h3{margin:0;border-bottom:none;font-size:var(--font-size-header);cursor: default;}
        .modal-header h3::after { content: ''; }
        .close-button{background:none;border:none;font-size:1.5em;color:var(--text-color-secondary);cursor:pointer;padding:0 5px;line-height:1;width:auto;display:inline;margin:0}
        .close-button:hover{color:var(--text-color-primary);background:none!important;border:none!important}
        .modal-body{padding:var(--padding-base);overflow-y:auto;flex-grow:1}
        .modal-body::-webkit-scrollbar{width:6px}
        .modal-body::-webkit-scrollbar-track{background:var(--bg-color-medium)}
        .modal-body::-webkit-scrollbar-thumb{background:var(--bg-color-light);border-radius:3px}
        .modal-body::-webkit-scrollbar-thumb:hover{background:var(--border-color)}
        .model-item{display:flex;align-items:center;background:var(--bg-color-light);border:1px solid var(--border-color);border-radius:var(--border-radius);padding:var(--padding-small) var(--padding-base);margin-bottom:var(--padding-small);cursor:pointer;transition:background-color .15s,border-color .15s}
        .model-item:hover{background-color:var(--border-color);border-color:#5a5a5a}
        .model-item img{width:40px;height:40px;margin-right:var(--padding-base);object-fit:contain;background-color:var(--bg-color-medium);border-radius:2px;border:1px solid var(--bg-color-darkest)}
        .model-item span{flex-grow:1;font-size:var(--font-size-base)}
        #planeTransparencyProps { margin-top: 8px; }
        #terrainEditingTools span { display: inline-block; margin-left: 5px; min-width: 25px; }
        #waterControls { display: flex; gap: 5px; align-items: center; }
        #waterControls input { flex-grow: 1; margin-bottom: 0 !important; }
        #waterControls button { width: auto; padding: 4px 8px; margin: 0 !important; }
        .history-buttons { display: flex; gap: 4px; }
        .history-buttons button { flex: 1; }
        details { border: 1px solid var(--border-color); border-radius: var(--border-radius); margin-bottom: 8px; background-color: var(--bg-color-medium); }
        details > summary { list-style: none; cursor: pointer; padding: 4px var(--padding-base); background-color: var(--bg-color-light); border-radius: var(--border-radius) var(--border-radius) 0 0; position: relative; font-weight: bold; color: var(--text-color-secondary); }
        details > summary::-webkit-details-marker { display: none; }
        details > summary::before { content: '▶'; display: inline-block; margin-right: 5px; transition: transform 0.2s; font-size: 0.8em; }
        details[open] > summary::before { transform: rotate(90deg); }
        details[open] > summary { border-bottom: 1px solid var(--border-color); border-radius: var(--border-radius) var(--border-radius) 0 0; }
        details > div { padding: var(--padding-small); border-top: none; }
        details > #textureGrid, details > #textureGridToony { border: none; background: none; padding: 0; margin-top: var(--padding-small); }
        #terrainPaintSlots { display: flex; gap: 4px; margin-top: 8px; justify-content: space-between; }
        .paintSlot { width: 38px; height: 38px; background-color: var(--bg-color-darkest); border: 1px solid var(--border-color); border-radius: var(--border-radius); cursor: pointer; background-size: cover; background-position: center; display: flex; align-items: center; justify-content: center; font-size: 9px; color: var(--text-color-muted); text-align: center; line-height: 1.1; overflow: hidden; }
        .paintSlot:hover { border-color: var(--text-color-muted); }
        .paintSlot.active-assign { border-color: var(--highlight-color); box-shadow: 0 0 0 2px var(--highlight-color); }
        .paintSlot[data-texture-path=""]::after { content: 'Empty'; }
    </style>
</head>
<body>
    <div id=ui>
        <div id=ui-header>Engine Rebuild v3.5.8</div>
        <div id=ui-content>
            <div class=section>
                <h3>History</h3>
                <div class="history-buttons">
                    <button id="undoButton" disabled>Undo (Ctrl+Z)</button>
                    <button id="redoButton" disabled>Redo (Ctrl+Y)</button>
                </div>
            </div>
            <div class=section><h3>Add Geometry</h3><button id=addBox>Add Box</button><button id=addPlane>Add Plane</button><button id=addSprite>Add Sprite</button><button id=addModel>Add Model</button><button id=addDecalPlane>Add Decal Plane</button></div>
            <div class=section><h3>Add Spawner/Trigger</h3><button id=addPlayerStart>Add Player Start</button><button id=addItemSpawn>Add Item Spawn</button><button id=addEnemySpawn>Add Enemy Spawn</button><button id=addLevelTrigger>Add Level Trigger</button><button id=addDoorTrigger>Add Door Trigger</button><button id=addProximityTrigger>Add Proximity Trigger</button></div>
            <div class=section>
                <h3>Manipulation Mode</h3>
                <div class=mode-button-group><button id=modeTranslate>Translate (M)</button><button id=modeRotate disabled>Rotate (O)</button><button id=modeScale disabled>Scale (P)</button></div>
                <div id=currentModeInfo></div>
            </div>
             <div class="section">
                <h3>Terrain Tools</h3>
                <button id="addTerrain">Add Terrain Object</button>
                <div id="terrainEditingTools" style="display: none;">
                    <h4>Editing Mode</h4>
                    <div class="mode-button-group terrain-tool-buttons">
                        <button id="terrainToolRaise" data-tool="raise">Raise</button>
                        <button id="terrainToolLower" data-tool="lower">Lower</button>
                        <button id="terrainToolSmooth" data-tool="smooth">Smooth</button>
                        <button id="terrainToolFlatten" data-tool="flatten">Flatten</button>
                        <button id="terrainToolPaint" data-tool="paint">Paint</button>
                    </div>
                    <label for="terrainBrushSize">Brush Size:</label>
                    <input type="range" id="terrainBrushSize" min="0.5" max="15" step="0.1" value="3">
                    <span id="terrainBrushSizeValue">3.0</span>
                    <label for="terrainBrushStrength">Brush Strength:</label>
                    <input type="range" id="terrainBrushStrength" min="0.01" max="1.0" step="0.01" value="0.1">
                    <span id="terrainBrushStrengthValue">0.1</span>
                    <div id="terrainFlattenHeightContainer" style="display: none;">
                        <label for="terrainFlattenHeight">Flatten Height:</label>
                        <input type="number" id="terrainFlattenHeight" step="0.1" value="0">
                    </div>
                    <div id="terrainTextureContainer">
                        <label for="terrainBaseTextureSelect">Base Texture:</label>
                        <select id="terrainBaseTextureSelect"></select>
                        <div id="terrainTextureProps">
                            <label>Base Texture Scale (Tiling):</label>
                            <div class=half-input-group>
                                <span class=coord-label>U</span><input type=number step=.1 value=1 class=half-input id=terrainBaseTexScaleU>
                                <span class=coord-label>V</span><input type=number step=.1 value=1 class=half-input id=terrainBaseTexScaleV>
                            </div>
                        </div>
                         <button id="applyTerrainBaseTexture">Apply Base Texture</button>
                    </div>
                    <div id="terrainPaintContainer" style="display: none;">
                        <h4>Paint Textures (Click slot, then texture below)</h4>
                        <div id="terrainPaintSlots">
                            <div class="paintSlot" data-slot-index="0" data-texture-path=""></div>
                            <div class="paintSlot" data-slot-index="1" data-texture-path=""></div>
                            <div class="paintSlot" data-slot-index="2" data-texture-path=""></div>
                            <div class="paintSlot" data-slot-index="3" data-texture-path=""></div>
                            <div class="paintSlot" data-slot-index="4" data-texture-path=""></div>
                        </div>
                        <div id="terrainPaintTextureProps">
                             <label>Paint Texture Scale (Tiling):</label>
                             <div class=half-input-group>
                                 <span class=coord-label>U</span><input type=number step=.1 value=1 class=half-input id=terrainPaintTexScaleU>
                                 <span class=coord-label>V</span><input type=number step=.1 value=1 class=half-input id=terrainPaintTexScaleV>
                             </div>
                             <button id="applyTerrainPaintTextureScale">Apply Scale to Active Paint Texture</button>
                        </div>
                    </div>
                    <button id="finishTerrainEditing" class="secondary">Finish Terrain Editing</button>
                </div>
            </div>
            <div class="section">
                 <h3>Environment</h3>
                 <label for="skyboxSelect">Sky:</label>
                 <select id="skyboxSelect"></select>
                 <button id="applySkybox">Apply Sky</button>
                 <label for="waterLevelInput">Water Level (Y):</label>
                 <div id="waterControls">
                    <input type="number" id="waterLevelInput" step="0.1" value="0">
                    <button id="setWaterLevel">Set</button>
                    <button id="removeWaterLevel" class="danger">Remove</button>
                 </div>
             </div>
            <div class=section>
                 <h3>View & Selection</h3>
                 <button id=deleteObject class=danger disabled>Delete (Del)</button><button id=cloneObject disabled>Clone (Ctrl+D)</button>
                 <button id=groupObjects class=secondary disabled>Group (Ctrl+G)</button><button id=ungroupObjects class=secondary disabled>Ungroup (Ctrl+Shift+G)</button>
                 <label for=snapToGrid><input type=checkbox id=snapToGrid checked> Snap To Grid</label>
                 <label for=toggleWireframe><input type=checkbox id=toggleWireframe> Show Wireframe</label>
                 <label for=toggleGrid><input type=checkbox id=toggleGrid checked> Show Grid</label>
                 <button id=resetView>Reset View</button>
            </div>
            <div class=section>
                <h3>Textures</h3>
                <details open>
                    <summary>Gritty</summary>
                    <label>Select Texture:</label>
                    <div id=textureGrid></div>
                </details>
                <details>
                    <summary>Toony</summary>
                    <div id=textureGridToony>
                    </div>
                </details>
            </div>
            <div class=section id=selectedObjectInfo>
                <h3>Selected Properties</h3>
                <div><label for=selectedName>Name:</label><input type=text id=selectedName placeholder="Optional name..."></div>
                <div id=selectedObjectType>Type: -</div>
                <div>
                     <label for=selectedIsVisible><input type=checkbox id=selectedIsVisible checked> Visible</label>
                     <label for=selectedIsLocked><input type=checkbox id=selectedIsLocked> Locked (Triple-click obj to unlock)</label>
                </div>
                <div class=prop-section><label>Position:</label> <div class=coord-input-group><span class=coord-label>X</span><input type=number step=.1 class=coord-input id=selectedPosX><span class=coord-label>Y</span><input type=number step=.1 class=coord-input id=selectedPosY><span class=coord-label>Z</span><input type=number step=.1 class=coord-input id=selectedPosZ></div></div>
                <div class=prop-section id=rotationSection><label>Rotation:</label> <div class=coord-input-group><span class=coord-label>X</span><input type=number step=1 class=coord-input id=selectedRotX><span class=coord-label>Y</span><input type=number step=1 class=coord-input id=selectedRotY><span class=coord-label>Z</span><input type=number step=1 class=coord-input id=selectedRotZ><small class=unit>deg</small></div></div>
                <div class=prop-section id=scaleSection><label>Scale:</label> <div class=coord-input-group><span class=coord-label>X</span><input type=number step=.1 min=.01 class=coord-input id=selectedScaleX><span class=coord-label>Y</span><input type=number step=.1 min=.01 class=coord-input id=selectedScaleY><span class=coord-label>Z</span><input type=number step=.1 min=.01 class=coord-input id=selectedScaleZ></div></div>
                <div class=prop-section id=geometryProps>
                     <h4>Geometry Properties</h4><label for=selectedIsCollider><input type=checkbox id=selectedIsCollider> Is Collider?</label>
                     <div id=faceSelector><label>Active Face:</label><button data-face-index=0>+X</button><button data-face-index=1>-X</button><button data-face-index=2>+Y</button><button data-face-index=3>-Y</button><button data-face-index=4>+Z</button><button data-face-index=5>-Z</button></div>
                     <div id=applyTextureContainer><button id=applyTexture>Apply to Face</button><button id=applyTextureAll>Apply to All</button></div>
                     <div id=textureProps><label>Texture Scale:</label><div class=half-input-group><span class=coord-label>U</span><input type=number step=.1 value=1 class=half-input id=texScaleU><span class=coord-label>V</span><input type=number step=.1 value=1 class=half-input id=texScaleV></div><label>Texture Offset:</label><div class=half-input-group><span class=coord-label>U</span><input type=number step=.1 value=0 class=half-input id=texOffsetU><span class=coord-label>V</span><input type=number step=.1 value=0 class=half-input id=texOffsetV></div></div>
                     <div id=planeTransparencyProps style="display: none;">
                         <label for=selectedIsTransparent><input type=checkbox id=selectedIsTransparent> Transparent Material</label>
                         <label for=selectedPlaneAlphaTest>Alpha Test Threshold (0-1):</label><input type=number step=.01 min=0 max=1 value=0.1 id=selectedPlaneAlphaTest>
                     </div>
                </div>
                <div class=prop-section id=spriteProps>
                     <h4>Sprite Properties</h4>
                     <div id=applyTextureContainerSprite><button id=applyTextureSprite>Apply Texture</button></div>
                     <div><label for=selectedFixedRotation><input type=checkbox id=selectedFixedRotation> Fixed Rotation (vs Billboard)</label></div>
                     <div><label for=selectedSizeAttenuation><input type=checkbox id=selectedSizeAttenuation> Scale with Distance</label></div>
                     <div><label for=selectedDepthWrite><input type=checkbox id=selectedDepthWrite> Write to Depth Buffer</label></div>
                     <div><label for=selectedAlphaTest>Alpha Test Threshold (0-1):</label><input type=number step=.01 min=0 max=1 id=selectedAlphaTest></div>
                     <div><label>Pivot Point (0-1):</label><div class=half-input-group><span class=coord-label>X</span><input type=number step=.1 min=0 max=1 class=half-input id=selectedCenterX><span class=coord-label>Y</span><input type=number step=.1 min=0 max=1 class=half-input id=selectedCenterY></div></div>
                     <div><label for=selectedTintColor>Tint Color:</label><input type=color id=selectedTintColor></div>
                </div>
                <div class=prop-section id=animationProps>
                    <h4>Animation</h4>
                    <label for=animType>Animation Type:</label> <select id=animType><option value=translate>Translate</option><option value=rotate>Rotate</option></select>
                    <div id=animationTargetFields>
                        <div id=animTargetPos><label>Target Position Offset:</label><div class=coord-input-group><span class=coord-label>X</span><input type=number step=.1 class=coord-input id=animTargetPosX><span class=coord-label>Y</span><input type=number step=.1 class=coord-input id=animTargetPosY><span class=coord-label>Z</span><input type=number step=.1 class=coord-input id=animTargetPosZ></div></div>
                        <div id=animTargetRot><label>Target Rotation:</label><div class=coord-input-group><span class=coord-label>X</span><input type=number step=1 class=coord-input id=animTargetRotX><span class=coord-label>Y</span><input type=number step=1 class=coord-input id=animTargetRotY><span class=coord-label>Z</span><input type=number step=1 class=coord-input id=animTargetRotZ><small class=unit>deg</small></div></div>
                    </div>
                    <button id=setAnimTarget class=secondary>Set Current Transform as Target</button>
                    <label for=animDuration>Duration (seconds):</label><input type=number step=.1 min=0.1 id=animDuration>
                    <label for=animLoop>Loop Behaviour:</label><select id=animLoop><option value=once>Play Once</option><option value=loop>Loop</option><option value=pingpong>Ping-Pong</option></select>
                    <label for=animAutoStart><input type=checkbox id=animAutoStart> Auto Start on Load</label>
                    <label for=animTriggerId>Trigger ID (Optional):</label><input type=text id=animTriggerId placeholder="e.g., door_button_1">
                    <button id=previewAnim class=secondary>Preview Animation</button> <button id=clearAnim class=danger>Clear Animation Data</button>
                </div>
                <div class=prop-section id=selectedPrefabProps></div>
                <div class=prop-section id=selectedSpawnerProps></div>
            </div>
            <div class=section><h3>File</h3><button id=exportMap class=primary>Export JSON</button><button id=loadMap>Load JSON</button><input type=file id=loadInput accept=.json style="display: none;"></div>
        </div>
        <div id=statusBar>-</div>
    </div>
    <div id="modelMenu" class="modal-overlay" style="display: none;">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Select Model</h3>
                <button id="closeModelMenu" class="close-button">&times;</button>
            </div>
            <div id="modelList" class="modal-body">
                 <p>Loading models...</p>
            </div>
        </div>
    </div>
    <div id=instructionsPanel>
        <h3>Controls</h3>
        <div id="instructionsPanel-content">
            <ul><li><kbd>LMB Drag</kbd> Orbit View</li><li><kbd>MMB Drag</kbd> / <kbd>Shift+LMB Drag</kbd> Pan View</li><li><kbd>Scroll</kbd> Zoom View</li><li><kbd>LMB Click</kbd> Select / Deselect</li><li><kbd>Shift+LMB Click</kbd> Add/Remove from Selection</li><li><kbd>Triple Click</kbd> Unlock Locked Object</li><li><kbd>LMB Click (Gizmo Center)</kbd> Cycle Mode (O/P)</li><li><kbd>WASD</kbd> Enter Explore Mode (Move)</li><li><kbd>Arrows</kbd> Enter Explore Mode (Look)</li><li><kbd>Esc</kbd> Exit Explore Mode / Deselect</li></ul>
            <h4>Manipulation</h4><ul><li><kbd>M</kbd> / <kbd>Button</kbd> Translate Mode</li><li><kbd>O</kbd> / <kbd>Button</kbd> Rotate Mode</li><li><kbd>P</kbd> / <kbd>Button</kbd> Scale Mode</li><li><kbd>Space</kbd> Cycle Rotate/Scale</li><li><kbd>Q</kbd> Toggle Local/World Space</li><li><kbd>Shift (Hold)</kbd> Uniform Scaling</li><li><kbd>Snap Checkbox</kbd> Enable Snapping</li></ul>
            <h4>View</h4><ul><li><kbd>Wireframe Checkbox</kbd> Toggle Wireframe</li></ul>
            <h4>Animation</h4><ul><li>Define target, duration etc. in UI</li><li><kbd>Set Target</kbd> Records current transform</li><li><kbd>Preview</kbd> Plays animation</li></ul>
            <h4>Texturing</h4><ul><li>Box: Select face, then apply</li><li><kbd>Apply to Face</kbd> Applies to active face</li><li><kbd>Apply to All</kbd> Applies to all faces/obj</li><li>Adjust UV Scale/Offset per face</li></ul>
            <h4>Decal Placement</h4><ul><li>Click <kbd>Add Decal</kbd> to enter mode</li><li>Click on geometry to place decal</li><li>Select decal plane to adjust properties</li><li>Click <kbd>Add Decal</kbd> again to exit mode</li></ul>
            <h4>Editing</h4><ul><li><kbd>Del</kbd> / <kbd>Backspace</kbd> Delete Selected</li><li><kbd>Ctrl+D</kbd> Clone Selected</li><li><kbd>Ctrl+G</kbd> Group Selected</li><li><kbd>Ctrl+Shift+G</kbd> Ungroup Selected</li><li><kbd>Esc</kbd> Deselect / Exit Decal Mode</li><li><kbd>Ctrl+Z</kbd> Undo</li><li><kbd>Ctrl+Y</kbd> Redo</li></ul>
            <h4>File</h4><ul><li>Use UI Buttons for Export/Load</li></ul>
            <h4>Terrain Editing</h4><ul><li><kbd>Add Terrain</kbd> Creates terrain plane</li><li>Tools: Raise, Lower, Smooth, Flatten, Paint</li><li>Adjust Brush Size/Strength</li><li><kbd>LMB Drag</kbd> Sculpt/Paint terrain</li><li><kbd>Apply Base Texture</kbd> Set terrain base texture</li><li>Adjust Base Texture Scale (Tiling)</li><li>Paint Slots: Click to select for painting. Click slot, then texture in grid to assign.</li><li><kbd>Finish Editing</kbd> Exit terrain mode</li></ul>
            <h4>Environment</h4><ul><li>Select Sky from dropdown</li><li><kbd>Apply Sky</kbd> Set scene background</li><li>Enter Water Level Y</li><li><kbd>Set</kbd> Add/Update water plane</li><li><kbd>Remove</kbd> Remove water plane</li></ul>
        </div>
    </div>
    <canvas id=editorCanvas></canvas>
    <script src=https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js></script>
    <script src=https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js></script>
    <script src=https://unpkg.com/three@0.128.0/examples/js/controls/TransformControls.js></script>
    <script src=https://unpkg.com/three@0.128.0/examples/js/postprocessing/EffectComposer.js></script>
    <script src=https://unpkg.com/three@0.128.0/examples/js/postprocessing/RenderPass.js></script>
    <script src=https://unpkg.com/three@0.128.0/examples/js/postprocessing/ShaderPass.js></script>
    <script src=https://unpkg.com/three@0.128.0/examples/js/shaders/CopyShader.js></script>
    <script src=https://unpkg.com/three@0.128.0/examples/js/postprocessing/OutlinePass.js></script>
    <script>
        const PLACE_DISTANCE=5, SNAP_TRANSLATION=1.0, SNAP_ROTATION_DEG=15, SNAP_SCALE=0.5, STATUS_MESSAGE_DURATION=3000, DEFAULT_TEX_SCALE=[1,1], DEFAULT_TEX_OFFSET=[0,0], MIN_SCALE=0.01, IMG_PREFIX='images/', TRIPLE_CLICK_TIMEOUT = 500, MAX_UNDO_STEPS = 50;
        const EXPLORE_MOVE_SPEED = 5.0, EXPLORE_LOOK_SPEED = 2.0, EXPLORE_PITCH_LIMIT = Math.PI * 0.48;
        const MODEL_PATH_PREFIX = 'models/';
        const AVAILABLE_MODELS = ['crate1', 'crate2', 'crate3', 'elevator', 'blast_door', 'office_chair', 'tape_drive', 'cryo_pod', 'wood_desk'];
        const texturePathString="BRICK_1A.png|BRICK_2B.png|BRICK_3B.png|BRICK_3D.png|BRICK_4A.png|BRICK_6D.png|Bigdoor_left.png|Bigdoor_right.png|BluePanel.png|CONCRETE_3C.png|CONCRETE_4A.png|CONSOLE_1B.png|Cryoback.png|Cryofront.png|Cryoleft.png|Cryoright.png|Cryotop.png|DIRT_1A.png|DOORTRIM_1A.png|DOOR_1A.png|DOOR_1C.png|DOOR_1E.png|DOOR_4A.png|Door.png|FLOOR_1A.png|FLOOR_3A.png|FLOOR_4A.png|GRASS_1A.png|GRID_1A.png|GRID_2B.png|HEDGE_1A.png|LAB_2B.png|LIGHT_1B.png|LockerPanel.png|Lorenote1.png|PAPER_1B.png|PAPER_1E.png|PAPER_1F.png|PIPES_1A.PNG|PIPES_2B.PNG|RIVET_1A.PNG|SAND_1A.PNG|WARN_1A.png|WOOD_1C.png|ammo.png|ammocrate.png|bigdoor23.png|blood.png|blood1.png|bullet.png|bullethole.png|bush1.png|bush2.png|bush3.png|bush4.png|bush5.png|ceiling_tiles_damaged.png|concrete_stained.png|concretewall.png|crate1.png|crate2.png|crate3.png|crate4.png|darkbricks.png|darktiles.png|desk_metal.png|dirt.png|door_barricaded.png|door_security_heavy.png|doorbord.png|elecPanel.png|elecbox.png|elevator_ceiling.png|elevator_door.png|elevator_floor.png|elevator_shaft.png|elevator_wall.png|floor_tiles_dirty.png|foresta1.png|foresta2.png|foresta3.png|foresta4.png|foresta5.png|foresta6.png|grass1.png|grass2.png|grass3.png|grass4.png|gun.gif|hazard.png|health_pack.png|iron.png|irondoor.png|ja987.png|jasdf7.png|jkdsa8j.png|key.png|keycardreader.png|level-2-keycard.png|level-3-keycard.png|level-4-keycard.png|level-5-keycard.png|level1keycard.png|lite1.png|lkhj58.png|locker.png|lockerSlim.png|medkit.png|n_gr_0_02.png|n_grass_diff_0_01.png|n_grass_diff_0_02.png|n_grass_diff_0_03.png|n_grass_diff_0_04.png|n_grass_diff_0_05.png|n_grass_diff_0_06.png|n_grass_diff_0_07.png|n_grass_diff_0_08.png|n_grass_diff_0_13.png|n_grass_diff_0_14.png|n_grass_diff_0_15.png|n_grass_diff_0_16.png|n_grass_diff_0_17.png|n_grass_diff_0_18.png|n_grass_diff_0_19.png|n_grass_diff_0_20.png|n_grass_diff_0_21.png|n_grass_diff_0_22.png|n_grass_diff_0_23.png|n_grass_diff_0_24.png|n_grass_diff_0_25.png|n_grass_diff_0_26.png|n_grass_diff_0_27.png|n_grass_diff_0_28.png|n_grass_diff_0_29.png|n_grass_diff_0_30.png|n_grass_diff_0_31.png|n_grass_diff_0_32.png|n_grass_diff_0_33.png|n_grass_diff_0_34.png|n_grass_diff_0_35.png|n_grass_diff_0_36.png|n_grass_diff_0_37.png|n_grass_diff_0_38.png|n_grass_diff_0_39.png|n_grass_diff_0_40.png|n_grass_diff_0_41.png|n_grass_diff_0_42.png|n_grass_diff_0_44.png|n_grass_diff_0_45.png|n_grass_diff_0_46.png|n_grass_diff_0_47.png|n_grass_diff_0_48.png|n_grass_diff_0_49.png|n_grass_diff_0_50.png|n_grass_diff_0_51.png|n_grass_diff_0_52.png|n_grass_diff_0_53.png|n_grass_diff_0_54.png|n_grass_diff_0_55.png|n_grass_diff_0_56.png|n_grass_diff_0_57.png|n_grass_diff_0_58.png|n_grass_diff_0_59.png|n_grass_diff_0_60.png|n_grass_diff_0_61.png|n_grass_diff_0_62.png|n_grass_diff_0_63.png|n_grass_diff_0_64.png|pistol_ammo.png|railing.png|ramp1.png|shortgrass1.png|shortgrass2.png|shortgrass3.png|sky.png|stepbot.png|steplight.png|stepsid.png|steptop.png|sun.png|suprt1.png|suprt2.png|suprt3.png|terminal_screen_off.png|tree.png|tree1.png|tree2.png|tree3.png|trim1.png|trim2.png|vdoor.png|wall_office_basic.png|wall_panel_damaged.png|water.png|xcrate11a.png|xcrate11b.png|office_chair_back_front.png|office_chair_back_rear.png|office_chair_seat_top.png|office_chair_seat_bottom.png|office_chair_stem.png|tapedrive_right.png|tapedrive_left.png|tapedrive_top.png|tapedrive_bottom.png|tapedrive_front.png|tapedrive_back.png|Cryoright.png|Cryoleft.png|Cryotop.png|Cryofront.png|Cryoback.png|wooddesktop.png";
        const texturePaths = texturePathString.split('|').map(p => IMG_PREFIX + p);
        const toonTexturePathString = "toon_brick_red.png|toon_brick_grey.png|toon_brick_mossy.png|toon_cobblestone.png|toon_concrete_smooth.png|toon_concrete_cracked.png|toon_dirt_muddy.png|toon_dirt_grassy.png|toon_floor_wood_planks.png|toon_floor_tile_check.png|toon_floor_metal_plate.png|toon_grass_lush.png|toon_grass_patchy.png|toon_metal_rusty.png|toon_metal_clean.png|toon_rock_cliff.png|toon_sand_simple.png|toon_wall_plaster.png|toon_wood_log.png|toon_wood_painted.png";
        const toonTexturePaths = toonTexturePathString.split('|').map(p => IMG_PREFIX + p);
        const availableSkyboxes = ['sky.png', 'sky1.png', 'sky2.png', 'sky3.png', 'sky4.png', 'sky5.png', 'sky6.png', 'sky7.png', 'sky8.png', 'sky9.png', 'sky10.png', 'sky11.png', 'sky12.png', 'sky13.png'].map(p => IMG_PREFIX + p);
        const raycaster = new THREE.Raycaster(), mouse = new THREE.Vector2(), clock = new THREE.Clock(), textureLoader = new THREE.TextureLoader();
        const markerGeo = new THREE.SphereGeometry(0.15,16,8), markerMats = { player_start:new THREE.MeshBasicMaterial({color:0x00ff00,wireframe:!0}),item:new THREE.MeshBasicMaterial({color:0xff00ff,wireframe:!0}),enemy:new THREE.MeshBasicMaterial({color:0xff0000,wireframe:!0}),level_trigger:new THREE.MeshBasicMaterial({color:0x00ffff,wireframe:!0}),door_trigger:new THREE.MeshBasicMaterial({color:0xffa500,wireframe:!0}),proximity_trigger:new THREE.MeshBasicMaterial({color:0x800080,wireframe:!0})};
        const prefabTypes=[], spawnerTypes=["player_start","enemy","item","level_trigger","door_trigger","proximity_trigger"], itemTypes=["keycard_security","keycard_office","healthpack","ammo_pistol","ammo_heavy","weapon_biggun"], enemyTypes=["guard_easy","guard_heavy","turret"];
        const _camPos=new THREE.Vector3(), _spritePos=new THREE.Vector3(), _targetDir=new THREE.Vector3(), _spriteQuaternion=new THREE.Quaternion(), _yAxis=new THREE.Vector3(0,1,0), _tempEuler=new THREE.Euler(), _identityQuaternion=new THREE.Quaternion(), _decalOffset = 0.01, _vector = new THREE.Vector3(), _box = new THREE.Box3(), _center = new THREE.Vector3(), _worldPos = new THREE.Vector3(), _invMat = new THREE.Matrix4();
        const TERRAIN_DEFAULT_SIZE = 50, TERRAIN_DEFAULT_SEGMENTS = 50, DEFAULT_TERRAIN_BASE_TEX_SCALE = [8, 8], DEFAULT_TERRAIN_PAINT_TEX_SCALE = [4, 4];
        const DEFAULT_BG_COLOR = new THREE.Color(0x303030);
        let scene, camera, renderer, orbitControls, transformControls, composer, outlinePass, gridHelper;
        let levelData = { geometry: [], prefabs: [], spawners: [], sprites: [], modelInstances: [], terrain: null, groups: [], settings: { skybox: null, waterLevel: null } };
        let selectedMeshes = [], selectedObjectDatas = [];
        let selectedMesh = null, selectedObjectData = null, selectedFaceIndex = 0;
        let loadedTextures = {}, loadedMaterials = {}, loadedSpriteMaterials = {}, loadedModelDefinitions = {};
        let isShiftPressed = false, isCtrlPressed = false, lastGizmoMode = 'translate', selectedTexturePath = "";
        let isPlacingDecal = false;
        let statusTimeout = null, animationPreviewState = { isPlaying: false, mesh: null, startTime: 0, duration: 1, startPos: null, targetPos: null, startRot: null, targetRot: null, type: 'translate', loop: 'once', direction: 1 };
        let lastLockedClickId = null, lastLockedClickTimestamp = 0, lockedClickCount = 0;
        let terrainMesh = null, isTerrainEditing = false, activeTerrainTool = 'raise', terrainBrushSize = 3.0, terrainBrushStrength = 0.1, terrainFlattenHeight = 0.0, brushHelper = null, isSculpting = false;
        let activePaintSlotIndex = -1, activePaintTextureIndex = 0;
        let waterMesh = null;
        let undoStack = [], redoStack = [];
        let isExploreModeActive = false, keysPressed = {};
        let exploreCameraYaw = 0, exploreCameraPitch = 0;
        const dom = {};

        function deepClone(obj) { try { return JSON.parse(JSON.stringify(obj)); } catch (e) { console.error("Deep clone failed:", e); return null; } }
        function captureState(description = "Action") { const state = deepClone(levelData); if (state) { undoStack.push(state); if (undoStack.length > MAX_UNDO_STEPS) undoStack.shift(); redoStack = []; updateHistoryButtons(); } else { showStatus("Failed to capture state for undo.", 3000); } }
        function undo() { if (undoStack.length === 0) return; const currentState = deepClone(levelData); if (!currentState) { showStatus("Failed to capture current state for redo.", 3000); return; } redoStack.push(currentState); if (redoStack.length > MAX_UNDO_STEPS) redoStack.shift(); const prevState = undoStack.pop(); restoreState(prevState); showStatus("Undo successful."); updateHistoryButtons(); }
        function redo() { if (redoStack.length === 0) return; const currentState = deepClone(levelData); if (!currentState) { showStatus("Failed to capture current state for undo.", 3000); return; } undoStack.push(currentState); if (undoStack.length > MAX_UNDO_STEPS) undoStack.shift(); const nextState = redoStack.pop(); restoreState(nextState); showStatus("Redo successful."); updateHistoryButtons(); }
        async function restoreState(stateToRestore) { await clearScene(false); levelData = deepClone(stateToRestore); if (!levelData) { console.error("Failed to restore state: Invalid state data provided."); showStatus("Error restoring state!", 5000); levelData = { geometry: [], prefabs: [], spawners: [], sprites: [], modelInstances: [], terrain: null, groups: [], settings: { skybox: null, waterLevel: null } }; return; } try { await rebuildSceneFromData(); deselectObject(false); render(); } catch (error) { console.error("Error rebuilding scene after restore:", error); showStatus("Error applying restored state!", 5000); } }
        function updateHistoryButtons() { dom.undoButton.disabled = undoStack.length === 0; dom.redoButton.disabled = redoStack.length === 0; }

        function cacheDOMElements() {
            const ids=['ui','ui-header','ui-content','editorCanvas','textureGrid','textureGridToony','selectedObjectInfo','statusBar','instructionsPanel','addBox','addPlane','addSprite','addModel','addDecalPlane','addPlayerStart','addItemSpawn','addEnemySpawn','addLevelTrigger','addDoorTrigger','addProximityTrigger','modeTranslate','modeRotate','modeScale','currentModeInfo','deleteObject','cloneObject','snapToGrid','toggleWireframe','toggleGrid','resetView','applyTexture','applyTextureAll','applyTextureSprite','exportMap','loadMap','loadInput','selectedObjectType','selectedName','selectedIsVisible','selectedIsLocked','rotationSection','scaleSection','faceSelector','geometryProps','spriteProps','animationProps','selectedPosX','selectedPosY','selectedPosZ','selectedRotX','selectedRotY','selectedRotZ','selectedScaleX','selectedScaleY','selectedScaleZ','selectedIsCollider','texScaleU','texScaleV','texOffsetU','texOffsetV','textureProps','planeTransparencyProps','selectedIsTransparent','selectedPlaneAlphaTest','applyTextureContainer','applyTextureContainerSprite','selectedFixedRotation','selectedSizeAttenuation','selectedDepthWrite','selectedAlphaTest','selectedCenterX','selectedCenterY','selectedTintColor','animType','animationTargetFields','animTargetPos','animTargetRot','animTargetPosX','animTargetPosY','animTargetPosZ','animTargetRotX','animTargetRotY','animTargetRotZ','setAnimTarget','animDuration','animLoop','animAutoStart','animTriggerId','previewAnim','clearAnim','selectedPrefabProps','selectedSpawnerProps','modelMenu','modelList','closeModelMenu', 'addTerrain', 'terrainEditingTools', 'terrainToolRaise', 'terrainToolLower', 'terrainToolSmooth', 'terrainToolFlatten', 'terrainToolPaint', 'terrainBrushSize', 'terrainBrushSizeValue', 'terrainBrushStrength', 'terrainBrushStrengthValue', 'terrainFlattenHeightContainer', 'terrainFlattenHeight', 'terrainTextureContainer', 'terrainBaseTextureSelect', 'terrainTextureProps', 'terrainBaseTexScaleU', 'terrainBaseTexScaleV', 'applyTerrainBaseTexture', 'terrainPaintContainer', 'terrainPaintSlots', 'terrainPaintTextureProps', 'terrainPaintTexScaleU', 'terrainPaintTexScaleV', 'applyTerrainPaintTextureScale', 'finishTerrainEditing', 'skyboxSelect', 'applySkybox', 'waterLevelInput', 'setWaterLevel', 'removeWaterLevel', 'undoButton', 'redoButton', 'groupObjects', 'ungroupObjects'];
            ids.forEach(id => dom[id] = document.getElementById(id));
            dom['terrain-tool-buttons'] = document.querySelector('.terrain-tool-buttons');
            dom['paintSlots'] = dom.terrainPaintSlots ? dom.terrainPaintSlots.querySelectorAll('.paintSlot') : [];
            dom['instructionsHeader'] = dom.instructionsPanel?.querySelector('h3');
            ids.forEach(id => { if (!dom[id] && id !== 'terrain-tool-buttons' && id !== 'paintSlots' && id !== 'instructionsHeader') console.warn(`DOM element ${id} not found during caching.`); });
            if (!dom['terrain-tool-buttons']) console.warn(`DOM element .terrain-tool-buttons not found during caching.`);
            if (!dom.instructionsHeader) console.warn("DOM element #instructionsPanel > h3 not found during caching.");
            if (dom['paintSlots'].length !== 5) console.warn(`Expected 5 paint slots, found ${dom['paintSlots'].length}`);
        }

        function init() {
            cacheDOMElements();
            scene = new THREE.Scene(); scene.background = DEFAULT_BG_COLOR.clone();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000); camera.position.set(8, 8, 8); camera.lookAt(0,1,0);
            renderer = new THREE.WebGLRenderer({ canvas: dom.editorCanvas, antialias: true }); renderer.setSize(window.innerWidth, window.innerHeight);
            orbitControls = new THREE.OrbitControls(camera, renderer.domElement); orbitControls.enableDamping = true; orbitControls.target.set(0, 1, 0); orbitControls.enableKeys = false;
            transformControls = new THREE.TransformControls(camera, renderer.domElement);
            transformControls.addEventListener('change', render);
            transformControls.addEventListener('dragging-changed', event => { orbitControls.enabled = !event.value && !isExploreModeActive; if (animationPreviewState.isPlaying && event.value && selectedMeshes.includes(animationPreviewState.mesh)) { resetToInitialTransform(animationPreviewState.mesh); animationPreviewState.isPlaying = false; showStatus("Animation preview stopped by dragging."); } if(isTerrainEditing && event.value) orbitControls.enabled = false; if (!event.value && transformControls.object) { captureState("Transform Object"); } });
            transformControls.addEventListener('objectChange', onObjectTransform); scene.add(transformControls);
            scene.add(new THREE.AmbientLight(0x888888)); const dirLight = new THREE.DirectionalLight(0xffffff, 0.8); dirLight.position.set(5, 10, 7); scene.add(dirLight);
            gridHelper = new THREE.GridHelper(50, 50, 0x555555, 0x444444); scene.add(gridHelper);
            composer = new THREE.EffectComposer(renderer); const renderPass = new THREE.RenderPass(scene, camera); composer.addPass(renderPass);
            outlinePass = new THREE.OutlinePass(new THREE.Vector2(window.innerWidth, window.innerHeight), scene, camera);
            outlinePass.edgeStrength = 2.5; outlinePass.edgeGlow = 0.2; outlinePass.edgeThickness = 0.8; outlinePass.pulsePeriod = 0; outlinePass.visibleEdgeColor.set('#00aaff'); outlinePass.hiddenEdgeColor.set('#094771'); composer.addPass(outlinePass);
            const copyPass = new THREE.ShaderPass(THREE.CopyShader); copyPass.renderToScreen = true; composer.addPass(copyPass);
            const brushGeo = new THREE.CircleGeometry(1, 32); brushGeo.rotateX(-Math.PI / 2);
            const brushMat = new THREE.MeshBasicMaterial({ color: 0x00aaff, transparent: true, opacity: 0.3, side: THREE.DoubleSide, depthWrite: false });
            brushHelper = new THREE.Mesh(brushGeo, brushMat); brushHelper.visible = false; brushHelper.renderOrder = 1; scene.add(brushHelper);
            dom.snapToGrid.checked = localStorage.getItem('editor_snap') === 'true';
            dom.toggleWireframe.checked = localStorage.getItem('editor_wireframe') === 'true';
            dom.toggleGrid.checked = localStorage.getItem('editor_grid') !== 'false';
            populateTextureUI(); populateTerrainBaseTextureSelect(); populateSkyboxSelect(); setupEventListeners();
            const savedInstructionsState = localStorage.getItem('instructionsCollapsed') === 'true';
            if (savedInstructionsState) dom.instructionsPanel.classList.add('collapsed');
            dom.snapToGrid.dispatchEvent(new Event('change'));
            dom.toggleWireframe.dispatchEvent(new Event('change'));
            dom.toggleGrid.dispatchEvent(new Event('change'));
            updateModeInfoUI(transformControls.mode); populateModelMenu(); showStatus("Editor Ready."); captureState("Initial State"); animate();
        }

        function populateSkyboxSelect() { if (!dom.skyboxSelect) return; dom.skyboxSelect.innerHTML = '<option value="">None (Default Color)</option>'; availableSkyboxes.forEach(path => { const filename = path.split('/').pop(); const option = document.createElement('option'); option.value = path; option.textContent = filename; dom.skyboxSelect.appendChild(option); }); if (levelData.settings?.skybox) dom.skyboxSelect.value = levelData.settings.skybox; else dom.skyboxSelect.value = ""; }
         function applySkybox() { if (!dom.skyboxSelect) return; captureState("Apply Skybox"); const selectedPath = dom.skyboxSelect.value; levelData.settings.skybox = selectedPath || null; if (!selectedPath) { scene.background = DEFAULT_BG_COLOR.clone(); showStatus('Skybox removed (default color).'); render(); } else { showStatus(`Loading sky: ${selectedPath.split('/').pop()}...`); textureLoader.load( selectedPath, (texture) => { texture.mapping = THREE.EquirectangularReflectionMapping; scene.background = texture; showStatus('Skybox applied.'); render(); }, undefined, (err) => { console.error(`Failed to load skybox texture: ${selectedPath}`, err); showStatus(`Error loading skybox: ${selectedPath.split('/').pop()}`, 5000); scene.background = DEFAULT_BG_COLOR.clone(); levelData.settings.skybox = null; if(dom.skyboxSelect) dom.skyboxSelect.value = ""; render(); } ); } }
        function addOrUpdateWaterPlane() { if (!terrainMesh) { showStatus("Add Terrain first before adding water.", 3000); return; } const waterLevel = parseFloat(dom.waterLevelInput.value); if (isNaN(waterLevel)) { showStatus("Invalid water level value.", 3000); return; } captureState("Set Water Level"); levelData.settings.waterLevel = waterLevel; if (waterMesh) { waterMesh.position.y = waterLevel; showStatus(`Water level updated to Y=${waterLevel.toFixed(2)}`); } else { const size = terrainMesh.userData.size; const waterGeo = new THREE.PlaneGeometry(size[0], size[1], 1, 1); waterGeo.rotateX(-Math.PI / 2); const waterTexture = getTexture(IMG_PREFIX + 'water.png'); const waterMat = new THREE.MeshStandardMaterial({ color: waterTexture ? 0xffffff : 0x205080, map: waterTexture, opacity: 0.75, transparent: true, roughness: 0.2, metalness: 0.1, side: THREE.DoubleSide, }); if (waterMat.map) { waterMat.map.wrapS = THREE.RepeatWrapping; waterMat.map.wrapT = THREE.RepeatWrapping; const scaleFactor = 4; waterMat.map.repeat.set(size[0] / scaleFactor, size[1] / scaleFactor); } waterMesh = new THREE.Mesh(waterGeo, waterMat); waterMesh.position.y = waterLevel; waterMesh.userData.isWater = true; scene.add(waterMesh); showStatus(`Water plane added at Y=${waterLevel.toFixed(2)}`); } render(); }
         function removeWaterPlane() { if (waterMesh) { captureState("Remove Water"); scene.remove(waterMesh); waterMesh.geometry.dispose(); if (waterMesh.material.map) waterMesh.material.map.dispose(); waterMesh.material.dispose(); waterMesh = null; levelData.settings.waterLevel = null; if (dom.waterLevelInput) dom.waterLevelInput.value = ''; showStatus("Water plane removed."); render(); } else { showStatus("No water plane to remove."); } }
        function populateTerrainBaseTextureSelect() {
            if (!dom.terrainBaseTextureSelect) return;
            dom.terrainBaseTextureSelect.innerHTML = '<option value="">None</option>';
            const allTexturePaths = [...texturePaths, ...toonTexturePaths];
            allTexturePaths.forEach(path => {
                const filename = path.split('/').pop();
                const option = document.createElement('option');
                option.value = path;
                option.textContent = filename;
                dom.terrainBaseTextureSelect.appendChild(option);
            });
            if (terrainMesh && terrainMesh.userData.baseTexturePath) {
                dom.terrainBaseTextureSelect.value = terrainMesh.userData.baseTexturePath;
            }
        }
        function getTexture(texturePath) { if (!texturePath || loadedTextures[texturePath] === null) return null; if (loadedTextures[texturePath]) return loadedTextures[texturePath]; try { const texture = textureLoader.load( texturePath, ()=>{render();}, undefined, (err)=>{ console.error(`Failed texture load: ${texturePath}`, err); loadedTextures[texturePath] = null; showStatus(`Error loading texture: ${texturePath.split('/').pop()}`, 5000); render(); }); texture.wrapS = texture.wrapT = THREE.RepeatWrapping; texture.magFilter = THREE.NearestFilter; texture.minFilter = THREE.NearestMipmapLinearFilter; loadedTextures[texturePath] = texture; return texture; } catch (error) { console.error(`Exception during texture loading: ${texturePath}`, error); loadedTextures[texturePath] = null; showStatus(`Error loading texture: ${texturePath.split('/').pop()}`, 5000); return null; } }
        function getMaterial(texturePath, forSprite = false, spriteData = null, materialProps = {}) { const isWireframeActive = dom.toggleWireframe.checked; if (forSprite) { const props={tint:spriteData?.tintColor||'#ffffff',sizeAtt:spriteData?.sizeAttenuation??!1,alphaTest:spriteData?.alphaTest??.5,depthWrite:spriteData?.depthWrite??!1}; const cacheKey=`${texturePath || 'FALLBACK'}_SPRITE`; if (loadedSpriteMaterials[cacheKey] && loadedSpriteMaterials[cacheKey].map?.image) { const mat=loadedSpriteMaterials[cacheKey]; mat.color.set(props.tint); mat.sizeAttenuation = props.sizeAtt; mat.alphaTest = props.alphaTest; mat.depthWrite = props.depthWrite; mat.transparent = (props.alphaTest < 1.0); mat.needsUpdate = true; return mat; } const texture = getTexture(texturePath); const material = new THREE.SpriteMaterial({ map: texture, color: new THREE.Color(props.tint), sizeAttenuation: props.sizeAtt, alphaTest: props.alphaTest, depthWrite: props.depthWrite, transparent: (props.alphaTest < 1.0) }); loadedSpriteMaterials[cacheKey] = material; return material; } else { const cacheKey = `${texturePath || 'FALLBACK'}_MESH_${isWireframeActive}_${JSON.stringify(materialProps)}`; if (loadedMaterials[cacheKey] && loadedMaterials[cacheKey].map?.image) return loadedMaterials[cacheKey]; const texture = getTexture(texturePath); const defaultProps = { map: texture, color: texture ? 0xffffff : 0xcccccc, roughness: 0.8, metalness: 0.1, side: THREE.DoubleSide, wireframe: isWireframeActive, transparent: false, alphaTest: 0, depthWrite: true, polygonOffset: false, polygonOffsetFactor: 0, polygonOffsetUnits: 0 }; const finalProps = { ...defaultProps, ...materialProps }; const material = new THREE.MeshStandardMaterial(finalProps); loadedMaterials[cacheKey] = material; return material; } }
        function updateMaterialTextureTransform(material, scale, offset) { if (!material || !material.map) return; let needsClone = material.isMeshStandardMaterial && Array.isArray(selectedMeshes.length > 0 ? selectedMeshes[0].material : null); if (needsClone && !material.userData.mapCloned) { material.map = material.map.clone(); material.map.needsUpdate = true; material.userData.mapCloned = true; } else if (!needsClone) material.userData.mapCloned = false; material.map.repeat.fromArray(scale || DEFAULT_TEX_SCALE); material.map.offset.fromArray(offset || DEFAULT_TEX_OFFSET); material.needsUpdate = true; }
        function populateTextureUI() {
            dom.textureGrid.innerHTML = ''; dom.textureGridToony.innerHTML = '';
            const createAndAppend = (grid, path, label) => { const item = createTextureItem(path, label); grid.appendChild(item); return item; };
            const grittyNone = createAndAppend(dom.textureGrid, "", "None"); texturePaths.forEach(p => createAndAppend(dom.textureGrid, p, p.split('/').pop()));
            const toonyNone = createAndAppend(dom.textureGridToony, "", "None"); toonTexturePaths.forEach(p => createAndAppend(dom.textureGridToony, p, p.split('/').pop()));
            selectTextureItem(grittyNone);
        }
        function createTextureItem(path, label) { const item = document.createElement('div'); item.className = 'textureItem'; item.dataset.texturePath = path; item.style.backgroundImage = path ? `url(${path})` : 'none'; item.title = label; item.addEventListener('click', () => handleTextureItemClick(item)); return item; }
        function handleTextureItemClick(itemElement) { selectedTexturePath = itemElement.dataset.texturePath; if (isTerrainEditing && activeTerrainTool === 'paint' && activePaintSlotIndex !== -1) { assignTextureToPaintSlot(selectedTexturePath, activePaintSlotIndex); } else { document.querySelectorAll('.textureItem.selected').forEach(el => el.classList.remove('selected')); itemElement.classList.add('selected'); } }
        function selectTextureItem(itemElement) { document.querySelectorAll('.textureItem.selected').forEach(el => el.classList.remove('selected')); itemElement.classList.add('selected'); selectedTexturePath = itemElement.dataset.texturePath; }

        function setupEventListeners() {
            window.addEventListener('resize', onWindowResize);
            renderer.domElement.addEventListener('pointerdown', onPointerDown);
            renderer.domElement.addEventListener('pointermove', onPointerMove);
            renderer.domElement.addEventListener('pointerup', onPointerUp);
            window.addEventListener('keydown', onKeyDown); window.addEventListener('keyup', onKeyUp);
            dom.addBox.addEventListener('click', () => addGeometry('box')); dom.addPlane.addEventListener('click', () => addGeometry('plane')); dom.addSprite.addEventListener('click', addSpriteObject); dom.addModel.addEventListener('click', showModelMenu);
            dom.addDecalPlane.addEventListener('click', toggleDecalMode);
            dom.addPlayerStart.addEventListener('click', () => addSpawner('player_start')); dom.addItemSpawn.addEventListener('click', () => addSpawner('item')); dom.addEnemySpawn.addEventListener('click', () => addSpawner('enemy')); dom.addLevelTrigger.addEventListener('click', () => addSpawner('level_trigger'));
            dom.addDoorTrigger.addEventListener('click', () => addSpawner('door_trigger')); dom.addProximityTrigger.addEventListener('click', () => addSpawner('proximity_trigger'));
            dom.deleteObject.addEventListener('click', deleteSelected);
            dom.cloneObject.addEventListener('click', cloneSelected);
            dom.groupObjects.addEventListener('click', groupSelection);
            dom.ungroupObjects.addEventListener('click', ungroupSelection);
            dom.applyTexture.addEventListener('click', () => applyTextureToSelected(false)); dom.applyTextureAll.addEventListener('click', () => applyTextureToSelected(true)); dom.applyTextureSprite.addEventListener('click', () => applyTextureToSelected(false));
            dom.toggleWireframe.addEventListener('change', () => { toggleWireframeMode(); localStorage.setItem('editor_wireframe', dom.toggleWireframe.checked); });
            dom.toggleGrid.addEventListener('change', () => { gridHelper.visible = dom.toggleGrid.checked; localStorage.setItem('editor_grid', dom.toggleGrid.checked); render(); });
            dom.resetView.addEventListener('click', () => { camera.position.set(8, 8, 8); camera.lookAt(0,1,0); orbitControls.target.set(0, 1, 0); orbitControls.update(); render(); });
            dom.modeTranslate.addEventListener('click', () => setGizmoMode('translate', true)); dom.modeRotate.addEventListener('click', () => setGizmoMode('rotate', true)); dom.modeScale.addEventListener('click', () => setGizmoMode('scale', true));
            dom.snapToGrid.addEventListener('change', () => { const snap = dom.snapToGrid.checked; transformControls.setTranslationSnap(snap ? SNAP_TRANSLATION : null); transformControls.setRotationSnap(snap ? THREE.MathUtils.degToRad(SNAP_ROTATION_DEG) : null); transformControls.setScaleSnap((snap && !(isShiftPressed && transformControls.getMode() === 'scale')) ? SNAP_SCALE : null); localStorage.setItem('editor_snap', snap); render(); });
            dom.exportMap.addEventListener('click', exportLevelData); dom.loadMap.addEventListener('click', () => dom.loadInput.click()); dom.loadInput.addEventListener('change', loadLevelDataFromFile);
            const inputsToTrackForUndo = ['selectedName','selectedIsVisible','selectedIsLocked','selectedPosX','selectedPosY','selectedPosZ','selectedRotX','selectedRotY','selectedRotZ','selectedScaleX','selectedScaleY','selectedScaleZ','selectedIsCollider','texScaleU','texScaleV','texOffsetU','texOffsetV','selectedIsTransparent','selectedPlaneAlphaTest','selectedFixedRotation','selectedSizeAttenuation','selectedDepthWrite','selectedAlphaTest','selectedCenterX','selectedCenterY','selectedTintColor','animType','animTargetPosX','animTargetPosY','animTargetPosZ','animTargetRotX','animTargetRotY','animTargetRotZ','animDuration','animLoop','animAutoStart','animTriggerId'];
            inputsToTrackForUndo.forEach(id => { if(dom[id]) { const eventType = (dom[id].type === 'checkbox' || dom[id].tagName === 'SELECT') ? 'change' : 'change'; dom[id].addEventListener(eventType, (event) => { if(!event.detail?.skipUndo) { updateSelectedDataFromUI(event); captureState("Update Property"); } else { updateSelectedDataFromUI(event); } }); dom[id].addEventListener('input', (event) => { updateSelectedDataFromUI(event); }); } else { console.warn(`DOM element ${id} not found for event listener setup.`); } });
            dom.faceSelector.querySelectorAll('button').forEach(button => { button.addEventListener('click', (e) => { const index = parseInt(e.target.dataset.faceIndex, 10); if (!isNaN(index) && selectedObjectData?.type === 'box') { selectedFaceIndex = index; updateSelectedObjectUI(); } }); });
            dom.setAnimTarget.addEventListener('click', ()=>{ setAnimationTarget(); captureState("Set Anim Target"); }); dom.previewAnim.addEventListener('click', previewAnimation); dom.clearAnim.addEventListener('click', ()=>{ clearAnimationData(); captureState("Clear Anim Data"); });
            dom.closeModelMenu.addEventListener('click', hideModelMenu);
            dom.modelMenu.addEventListener('click', (event) => { if (event.target === dom.modelMenu) { hideModelMenu(); } });
            dom.addTerrain.addEventListener('click', addTerrain);
            if (dom['terrain-tool-buttons']) { dom['terrain-tool-buttons'].querySelectorAll('button').forEach(button => { button.addEventListener('click', (e) => { if (isTerrainEditing) activateTerrainTool(e.target.dataset.tool); }); }); } else { console.error("Terrain tool button container not found for event listeners."); }
            dom.terrainBrushSize.addEventListener('input', (e) => { terrainBrushSize = parseFloat(e.target.value); dom.terrainBrushSizeValue.textContent = terrainBrushSize.toFixed(1); updateBrushHelper(); });
            dom.terrainBrushStrength.addEventListener('input', (e) => { terrainBrushStrength = parseFloat(e.target.value); dom.terrainBrushStrengthValue.textContent = terrainBrushStrength.toFixed(2); });
            dom.terrainFlattenHeight.addEventListener('input', (e) => { terrainFlattenHeight = parseFloat(e.target.value) || 0; });
            dom.finishTerrainEditing.addEventListener('click', toggleTerrainEditing);
            dom.applyTerrainBaseTexture.addEventListener('click', applyTerrainBaseTexture);
            dom.terrainBaseTexScaleU.addEventListener('input', updateTerrainBaseTextureScale);
            dom.terrainBaseTexScaleV.addEventListener('input', updateTerrainBaseTextureScale);
            dom.terrainBaseTexScaleU.addEventListener('change', () => captureState("Update Terrain Base Tex Scale"));
            dom.terrainBaseTexScaleV.addEventListener('change', () => captureState("Update Terrain Base Tex Scale"));
            dom['paintSlots'].forEach(slot => slot.addEventListener('click', handlePaintSlotClick));
            dom.applyTerrainPaintTextureScale.addEventListener('click', applyTerrainPaintTextureScale);
            dom.applySkybox.addEventListener('click', applySkybox);
            dom.skyboxSelect.addEventListener('change', () => { levelData.settings.skybox = dom.skyboxSelect.value || null; captureState("Change Skybox Selection"); });
             dom.setWaterLevel.addEventListener('click', addOrUpdateWaterPlane);
             dom.removeWaterLevel.addEventListener('click', removeWaterPlane);
             dom.undoButton.addEventListener('click', undo);
             dom.redoButton.addEventListener('click', redo);
             if(dom.instructionsHeader) { dom.instructionsHeader.addEventListener('click', () => { dom.instructionsPanel.classList.toggle('collapsed'); localStorage.setItem('instructionsCollapsed', dom.instructionsPanel.classList.contains('collapsed')); }); }
        }

        function enterExploreMode() {
            if (isExploreModeActive) return;
            isExploreModeActive = true;
            orbitControls.enabled = false;
            transformControls.detach();
            deselectObject(false);
            const currentEuler = new THREE.Euler().setFromQuaternion(camera.quaternion, 'YXZ');
            exploreCameraYaw = currentEuler.y;
            exploreCameraPitch = currentEuler.x;
            showStatus("Explore Mode Activated (WASD + Arrows)", 2000);
        }

        function exitExploreMode() {
            if (!isExploreModeActive) return;
            const stillExploring = Object.values(keysPressed).some(v => v === true);
            if (!stillExploring) {
                isExploreModeActive = false;
                orbitControls.enabled = true;
                orbitControls.target.copy(camera.position).add(new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion));
                showStatus("Orbit Mode Activated", 2000);
            }
        }

        function updateExploreModeCamera(delta) {
            const moveSpeed = EXPLORE_MOVE_SPEED * delta;
            const lookSpeed = EXPLORE_LOOK_SPEED * delta;
            let yawDelta = 0;
            let pitchDelta = 0;
            if (keysPressed['arrowleft']) yawDelta += lookSpeed;
            if (keysPressed['arrowright']) yawDelta -= lookSpeed;
            if (keysPressed['arrowup']) pitchDelta += lookSpeed;
            if (keysPressed['arrowdown']) pitchDelta -= lookSpeed;
            exploreCameraYaw += yawDelta;
            exploreCameraPitch += pitchDelta;
            exploreCameraPitch = Math.max(-EXPLORE_PITCH_LIMIT, Math.min(EXPLORE_PITCH_LIMIT, exploreCameraPitch));
            const targetEuler = new THREE.Euler(exploreCameraPitch, exploreCameraYaw, 0, 'YXZ');
            camera.quaternion.setFromEuler(targetEuler);
            const moveDirection = new THREE.Vector3();
            const forwardVector = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
            const rightVector = new THREE.Vector3().crossVectors(camera.up, forwardVector).normalize();
            if (keysPressed['w']) moveDirection.add(forwardVector);
            if (keysPressed['s']) moveDirection.sub(forwardVector);
            if (keysPressed['a']) moveDirection.sub(rightVector);
            if (keysPressed['d']) moveDirection.add(rightVector);
            moveDirection.normalize().multiplyScalar(moveSpeed);
            camera.position.add(moveDirection);
        }

        function onPointerDown(event) {
            if (isTerrainEditing && !dom.ui.contains(event.target)) { handleTerrainSculptStart(event); return; }
            if (isExploreModeActive || dom.ui.contains(event.target) || dom.instructionsPanel.contains(event.target) || dom.modelMenu.contains(event.target) || transformControls.dragging) return;
            mouse.set((event.clientX / window.innerWidth) * 2 - 1, -(event.clientY / window.innerHeight) * 2 + 1); raycaster.setFromCamera(mouse, camera);
            if (isPlacingDecal) { const objectsToIntersect = scene.children.filter(c => c.isMesh && c.visible && (c.userData.isGeometry || c.userData.isModelPart || c.userData.isTerrain) && !c.userData.isGroupHelper); if (objectsToIntersect.length === 0) return; const intersects = raycaster.intersectObjects(objectsToIntersect, true); if (intersects.length > 0) { const validIntersect = intersects.find(intersect => intersect.object.isMesh && !intersect.object.userData.isMarker && !intersect.object.userData.isDecal && !intersect.object.userData.isWater); if (validIntersect) placeDecalPlane(validIntersect); } return; }
            let clickedGizmo = false; if (transformControls.object && transformControls.visible) { const gizmoParts = []; transformControls.traverseVisible(child => { if ((child.isMesh || child.isLine) && child.parent?.name && ['X','Y','Z', 'XYZE', 'E', 'Translate', 'Rotate', 'Scale', 'XYZ'].includes(child.parent.name)) gizmoParts.push(child); }); const gizmoIntersects = raycaster.intersectObjects(gizmoParts, false); if (gizmoIntersects.length > 0) { clickedGizmo = true; if (gizmoIntersects[0].object.name === 'XYZ') { cycleTransformMode(['rotate', 'scale']); event.stopPropagation(); } } }
            if (!clickedGizmo) {
                const objectsToIntersect = scene.children.filter(c => c !== transformControls && c.type !== 'GridHelper' && !c.userData.isWater && (c.isMesh || c.isSprite || c.isGroup) && c.visible && !c.userData.isHelper && (c.userData.dataId || c.userData.isModelPart));
                const intersects = raycaster.intersectObjects(objectsToIntersect, true);
                let clickedSceneObject = null;
                let clickedDataObject = null;
                if (intersects.length > 0) {
                    let obj = intersects[0].object;
                    while (obj && obj !== scene && !obj.userData.dataId) {
                        obj = obj.parent;
                    }
                    if (obj && obj.userData.dataId) {
                         clickedSceneObject = obj;
                         clickedDataObject = findObjectDataById(obj.userData.dataId);
                         if (clickedDataObject?.parentId) {
                             const parentGroupMesh = scene.getObjectByProperty('uuid', clickedDataObject.parentId);
                             const parentGroupData = findObjectDataById(clickedDataObject.parentId);
                             if (parentGroupMesh && parentGroupData) {
                                 clickedSceneObject = parentGroupMesh;
                                 clickedDataObject = parentGroupData;
                             }
                         }
                    }
                }

                if (clickedSceneObject && clickedDataObject) {
                    if (clickedDataObject.isLocked) {
                        const now = performance.now();
                        if (clickedDataObject.id === lastLockedClickId && now - lastLockedClickTimestamp < TRIPLE_CLICK_TIMEOUT) {
                             lockedClickCount++;
                        } else {
                             lockedClickCount = 1;
                        }
                        lastLockedClickId = clickedDataObject.id;
                        lastLockedClickTimestamp = now;
                        if (lockedClickCount >= 3) {
                             captureState("Unlock Object");
                             clickedDataObject.isLocked = false;
                             if (selectedMeshes.includes(clickedSceneObject)) {
                                 updateSelectedObjectUI();
                             }
                             showStatus("Object unlocked.");
                             selectObject(clickedSceneObject, clickedDataObject, event.shiftKey || event.ctrlKey);
                             lastLockedClickId = null;
                             lockedClickCount = 0;
                        } else {
                             showStatus(`Object locked. Click again to unlock (${lockedClickCount}/3).`, 2000);
                             if (!(event.shiftKey || event.ctrlKey)) { deselectObject(); }
                        }
                        return;
                    } else {
                        lastLockedClickId = null;
                        lockedClickCount = 0;
                        selectObject(clickedSceneObject, clickedDataObject, event.shiftKey || event.ctrlKey);
                    }
                } else {
                    if (!(event.shiftKey || event.ctrlKey)) {
                        deselectObject();
                    }
                    lastLockedClickId = null;
                    lockedClickCount = 0;
                }
            }
        }
        function onPointerMove(event) { if (isExploreModeActive) return; if (isTerrainEditing && isSculpting && !dom.ui.contains(event.target)) handleTerrainSculpting(event); else if (isTerrainEditing && !dom.ui.contains(event.target)) updateBrushPosition(event); }
        function onPointerUp(event) { if (isExploreModeActive) return; if (isTerrainEditing && isSculpting) handleTerrainSculptEnd(event); }

        function addTerrain() { if (terrainMesh) { if (confirm("Terrain already exists. Replace it?")) captureState("Replace Terrain"); else return; clearTerrain(false); } else { captureState("Add Terrain"); } const size = TERRAIN_DEFAULT_SIZE, segments = TERRAIN_DEFAULT_SEGMENTS; const geometry = new THREE.PlaneGeometry(size, size, segments, segments); geometry.rotateX(-Math.PI / 2); const numVertices = (segments + 1) * (segments + 1); const yPositions = new Float32Array(numVertices); const textureWeights1 = new Float32Array(numVertices * 4); const textureWeights2 = new Float32Array(numVertices * 2); for (let i = 0; i < numVertices; i++) { yPositions[i] = 0; textureWeights1[i * 4 + 0] = 1.0; textureWeights1[i * 4 + 1] = 0.0; textureWeights1[i * 4 + 2] = 0.0; textureWeights1[i * 4 + 3] = 0.0; textureWeights2[i * 2 + 0] = 0.0; textureWeights2[i * 2 + 1] = 0.0; } const positions = geometry.attributes.position.array; for (let i = 0; i < numVertices; i++) positions[i * 3 + 1] = yPositions[i]; geometry.setAttribute('textureWeights1', new THREE.BufferAttribute(textureWeights1, 4)); geometry.setAttribute('textureWeights2', new THREE.BufferAttribute(textureWeights2, 2)); geometry.attributes.position.needsUpdate = true; geometry.computeVertexNormals(); const material = createTerrainMaterial(); terrainMesh = new THREE.Mesh(geometry, material); const initialBaseTexScale = [...DEFAULT_TERRAIN_BASE_TEX_SCALE]; const initialPaintTexScales = Array(5).fill(null).map(() => [...DEFAULT_TERRAIN_PAINT_TEX_SCALE]); terrainMesh.userData = { isTerrain: true, size: [size, size], segments: [segments, segments], baseTexturePath: null, baseTextureScale: initialBaseTexScale, paintTextures: [null, null, null, null, null], paintTextureScales: initialPaintTexScales }; scene.add(terrainMesh); levelData.terrain = { size: terrainMesh.userData.size, segments: terrainMesh.userData.segments, yPositions: Array.from(yPositions), textureWeights1: Array.from(textureWeights1), textureWeights2: Array.from(textureWeights2), baseTextureRef: null, baseTextureScale: initialBaseTexScale, paintTextureRefs: [null, null, null, null, null], paintTextureScales: initialPaintTexScales }; showStatus("Terrain added. Entering edit mode."); if (!isTerrainEditing) toggleTerrainEditing(); populateTerrainBaseTextureSelect(); updateTerrainPaintSlotsUI(); render(); }
        function clearTerrain(captureUndo = true) { if (terrainMesh) { if(captureUndo) captureState("Clear Terrain"); scene.remove(terrainMesh); terrainMesh.geometry.dispose(); if (terrainMesh.material) terrainMesh.material.dispose(); terrainMesh = null; delete levelData.terrain; if (isTerrainEditing) toggleTerrainEditing(); removeWaterPlane(); showStatus("Terrain removed."); render(); } }
        function toggleTerrainEditing() { isExploreModeActive = false; isTerrainEditing = !isTerrainEditing; dom.terrainEditingTools.style.display = isTerrainEditing ? 'block' : 'none'; brushHelper.visible = isTerrainEditing; if (isTerrainEditing) { if (!terrainMesh) { showStatus("Add Terrain first before editing.", 3000); isTerrainEditing = false; dom.terrainEditingTools.style.display = 'none'; brushHelper.visible = false; return; } deselectObject(); transformControls.detach(); orbitControls.enabled = false; showStatus("Terrain Edit Mode ON. Orbit disabled while sculpting."); activateTerrainTool(activeTerrainTool); updateBrushHelper(); const currentBaseScale = terrainMesh.userData.baseTextureScale || DEFAULT_TERRAIN_BASE_TEX_SCALE; dom.terrainBaseTexScaleU.value = currentBaseScale[0]; dom.terrainBaseTexScaleV.value = currentBaseScale[1]; updateTerrainPaintSlotsUI(); updateTerrainPaintTextureScaleUI(); } else { isSculpting = false; orbitControls.enabled = true; brushHelper.visible = false; showStatus("Terrain Edit Mode OFF."); activePaintSlotIndex = -1; dom['paintSlots'].forEach(slot => slot.classList.remove('active-assign', 'active-paint')); } }
        function activateTerrainTool(toolName) { activeTerrainTool = toolName; if (dom['terrain-tool-buttons']) dom['terrain-tool-buttons'].querySelectorAll('button').forEach(btn => btn.classList.toggle('active', btn.dataset.tool === toolName)); dom.terrainFlattenHeightContainer.style.display = toolName === 'flatten' ? 'block' : 'none'; dom.terrainPaintContainer.style.display = toolName === 'paint' ? 'block' : 'none'; dom.terrainTextureContainer.style.display = toolName !== 'paint' ? 'block' : 'none'; if (toolName !== 'paint') { activePaintSlotIndex = -1; dom['paintSlots'].forEach(slot => slot.classList.remove('active-assign', 'active-paint')); } else { dom['paintSlots'][activePaintTextureIndex]?.classList.add('active-paint'); } showStatus(`Tool: ${toolName}`); }
        function updateBrushHelper() { if (brushHelper) brushHelper.scale.set(terrainBrushSize, 1, terrainBrushSize); }
        function updateBrushPosition(event) { if (!isTerrainEditing || !terrainMesh || !brushHelper) return null; mouse.set((event.clientX / window.innerWidth) * 2 - 1, -(event.clientY / window.innerHeight) * 2 + 1); raycaster.setFromCamera(mouse, camera); const intersects = raycaster.intersectObject(terrainMesh); if (intersects.length > 0) { const intersectionPoint = intersects[0].point; brushHelper.position.copy(intersectionPoint); brushHelper.position.y += 0.05; brushHelper.visible = true; return intersectionPoint; } else { brushHelper.visible = false; return null; } }
        function handleTerrainSculptStart(event) { if (!isTerrainEditing || event.button !== 0) return; const intersectionPoint = updateBrushPosition(event); if (intersectionPoint) { isSculpting = true; orbitControls.enabled = false; applyTerrainModification(intersectionPoint); } }
        function handleTerrainSculpting(event) { if (!isTerrainEditing || !isSculpting) return; const intersectionPoint = updateBrushPosition(event); if (intersectionPoint) applyTerrainModification(intersectionPoint); }
        function handleTerrainSculptEnd(event) { if (!isTerrainEditing || !isSculpting) return; isSculpting = false; orbitControls.enabled = true; if (terrainMesh && levelData.terrain) { levelData.terrain.yPositions = getYPositions(terrainMesh.geometry); levelData.terrain.textureWeights1 = Array.from(terrainMesh.geometry.attributes.textureWeights1.array); levelData.terrain.textureWeights2 = Array.from(terrainMesh.geometry.attributes.textureWeights2.array); captureState("Sculpt/Paint Terrain"); } }
        function applyTerrainModification(centerPoint) { if (!terrainMesh || !terrainMesh.geometry.attributes.position) return; const positions = terrainMesh.geometry.attributes.position.array; const weights1Attr = terrainMesh.geometry.attributes.textureWeights1; const weights2Attr = terrainMesh.geometry.attributes.textureWeights2; const weights1 = weights1Attr?.array; const weights2 = weights2Attr?.array; const vertex = new THREE.Vector3(); const center = new THREE.Vector3().copy(centerPoint); const radiusSq = terrainBrushSize * terrainBrushSize; let modifiedHeight = false, modifiedWeights = false; const vertexIndices = []; const originalHeights = []; if (!weights1 || !weights2) return; for (let i = 0; i < positions.length; i += 3) { vertex.set(positions[i], positions[i + 1], positions[i + 2]); const dx = vertex.x - center.x, dz = vertex.z - center.z, distSq = dx * dx + dz * dz; if (distSq < radiusSq) { vertexIndices.push(i / 3); if (activeTerrainTool === 'smooth') originalHeights.push(vertex.y); } } if (vertexIndices.length === 0) return; let averageHeight = 0; if (activeTerrainTool === 'smooth') averageHeight = originalHeights.reduce((sum, h) => sum + h, 0) / originalHeights.length; vertexIndices.forEach((vertexIndex, idx) => { const iPos = vertexIndex * 3; const iW1 = vertexIndex * 4; const iW2 = vertexIndex * 2; vertex.set(positions[iPos], positions[iPos + 1], positions[iPos + 2]); const dx = vertex.x - center.x, dz = vertex.z - center.z, dist = Math.sqrt(dx * dx + dz * dz); const falloff = smoothstep(terrainBrushSize, terrainBrushSize * 0.2, dist); let modificationAmount = falloff * terrainBrushStrength, targetHeight; switch (activeTerrainTool) { case 'raise': positions[iPos + 1] += modificationAmount; modifiedHeight = true; break; case 'lower': positions[iPos + 1] -= modificationAmount; modifiedHeight = true; break; case 'smooth': targetHeight = averageHeight; positions[iPos + 1] = THREE.MathUtils.lerp(vertex.y, targetHeight, modificationAmount * 0.5); modifiedHeight = true; break; case 'flatten': targetHeight = terrainFlattenHeight; positions[iPos + 1] = THREE.MathUtils.lerp(vertex.y, targetHeight, modificationAmount); modifiedHeight = true; break; case 'paint': { if (activePaintTextureIndex < 0 || activePaintTextureIndex > 4) break; const paintTargetIndex = activePaintTextureIndex + 1; let currentWeights = [weights1[iW1], weights1[iW1 + 1], weights1[iW1 + 2], weights1[iW1 + 3], weights2[iW2], weights2[iW2 + 1]]; const targetWeightIncrease = modificationAmount * 0.5; let currentTargetWeight = 0; if (paintTargetIndex === 0) currentTargetWeight = currentWeights[0]; else if (paintTargetIndex === 1) currentTargetWeight = currentWeights[1]; else if (paintTargetIndex === 2) currentTargetWeight = currentWeights[2]; else if (paintTargetIndex === 3) currentTargetWeight = currentWeights[3]; else if (paintTargetIndex === 4) currentTargetWeight = currentWeights[4]; else if (paintTargetIndex === 5) currentTargetWeight = currentWeights[5]; const actualIncrease = Math.min(targetWeightIncrease, 1.0 - currentTargetWeight); if (actualIncrease <= 0) break; let totalOtherWeights = 1.0 - currentTargetWeight; let scaleFactor = totalOtherWeights > 0.001 ? (totalOtherWeights - actualIncrease) / totalOtherWeights : 0; if (scaleFactor < 0) scaleFactor = 0; let newWeights = [0, 0, 0, 0, 0, 0]; let sumCheck = 0; for (let k = 0; k < 6; k++) { if (k === paintTargetIndex) { newWeights[k] = currentTargetWeight + actualIncrease; } else { newWeights[k] = currentWeights[k] * scaleFactor; } sumCheck += newWeights[k]; } if (Math.abs(sumCheck - 1.0) > 0.01) { const normFactor = 1.0 / sumCheck; for (let k = 0; k < 6; k++) newWeights[k] *= normFactor; } weights1[iW1] = newWeights[0]; weights1[iW1 + 1] = newWeights[1]; weights1[iW1 + 2] = newWeights[2]; weights1[iW1 + 3] = newWeights[3]; weights2[iW2] = newWeights[4]; weights2[iW2 + 1] = newWeights[5]; modifiedWeights = true; break; } } }); if (modifiedHeight) { terrainMesh.geometry.attributes.position.needsUpdate = true; terrainMesh.geometry.computeVertexNormals(); } if (modifiedWeights) { weights1Attr.needsUpdate = true; weights2Attr.needsUpdate = true; } }
        function smoothstep(edge0, edge1, x) { const t = THREE.MathUtils.clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0); return t * t * (3.0 - 2.0 * t); }
        function getYPositions(geometry) { const positions = geometry.attributes.position.array; const yPositions = new Float32Array(positions.length / 3); for (let i = 0; i < yPositions.length; i++) yPositions[i] = positions[i * 3 + 1]; return Array.from(yPositions); }
        function applyYPositions(geometry, yPositions) { const positions = geometry.attributes.position.array; if (positions.length / 3 !== yPositions.length) { console.error("Mismatch vertex count applying Y positions."); return false; } for (let i = 0; i < yPositions.length; i++) positions[i * 3 + 1] = yPositions[i]; geometry.attributes.position.needsUpdate = true; geometry.computeVertexNormals(); return true; }
        function updateTerrainBaseTextureScale() { if (!terrainMesh || !terrainMesh.material || !terrainMesh.material.uniforms.uBaseTexture.value) return; const scaleU = parseFloat(dom.terrainBaseTexScaleU.value) || 1; const scaleV = parseFloat(dom.terrainBaseTexScaleV.value) || 1; const newScale = [scaleU, scaleV]; terrainMesh.material.uniforms.uBaseTexScale.value.fromArray(newScale); terrainMesh.userData.baseTextureScale = newScale; if (levelData.terrain) levelData.terrain.baseTextureScale = newScale; render(); }
        function applyTerrainBaseTexture() { if (!terrainMesh || !dom.terrainBaseTextureSelect) return; captureState("Apply Terrain Base Texture"); const selectedPath = dom.terrainBaseTextureSelect.value; const scaleU = parseFloat(dom.terrainBaseTexScaleU.value) || 1; const scaleV = parseFloat(dom.terrainBaseTexScaleV.value) || 1; const newScale = [scaleU, scaleV]; const texture = getTexture(selectedPath || null); if (terrainMesh.material.uniforms.uBaseTexture.value) terrainMesh.material.uniforms.uBaseTexture.value.dispose(); terrainMesh.material.uniforms.uBaseTexture.value = texture; terrainMesh.material.uniforms.uHasBaseTexture.value = !!texture; terrainMesh.material.uniforms.uBaseTexScale.value.fromArray(newScale); terrainMesh.userData.baseTexturePath = selectedPath || null; terrainMesh.userData.baseTextureScale = newScale; if (levelData.terrain) { levelData.terrain.baseTextureRef = selectedPath || null; levelData.terrain.baseTextureScale = newScale; } showStatus(`Terrain base texture applied: ${selectedPath ? selectedPath.split('/').pop() : 'None'} (Scale: ${scaleU.toFixed(1)}x${scaleV.toFixed(1)})`); render(); }
        function handlePaintSlotClick(event) { const clickedSlot = event.currentTarget; const index = parseInt(clickedSlot.dataset.slotIndex, 10); if (isNaN(index)) return; if (activeTerrainTool !== 'paint') { activateTerrainTool('paint'); } dom['paintSlots'].forEach(slot => slot.classList.remove('active-assign', 'active-paint')); if (activePaintSlotIndex === index) { activePaintSlotIndex = -1; activePaintTextureIndex = index; clickedSlot.classList.add('active-paint'); showStatus(`Selected paint texture ${index + 1}.`); } else { activePaintSlotIndex = index; clickedSlot.classList.add('active-assign'); showStatus(`Click texture below to assign to slot ${index + 1}.`); } updateTerrainPaintTextureScaleUI(); }
        function assignTextureToPaintSlot(texturePath, slotIndex) { if (!terrainMesh || slotIndex < 0 || slotIndex > 4) return; captureState("Assign Terrain Paint Texture"); const texture = getTexture(texturePath || null); const slotElement = dom['paintSlots'][slotIndex]; terrainMesh.userData.paintTextures[slotIndex] = texturePath || null; const uniformName = `uPaintTexture${slotIndex}`; const scaleUniformName = `uPaintTexScale${slotIndex}`; const hasUniformName = `uHasPaintTexture${slotIndex}`; if (terrainMesh.material.uniforms[uniformName].value) terrainMesh.material.uniforms[uniformName].value.dispose(); terrainMesh.material.uniforms[uniformName].value = texture; terrainMesh.material.uniforms[hasUniformName].value = !!texture; if (levelData.terrain) levelData.terrain.paintTextureRefs[slotIndex] = texturePath || null; slotElement.style.backgroundImage = texturePath ? `url(${texturePath})` : 'none'; slotElement.dataset.texturePath = texturePath || ""; slotElement.classList.remove('active-assign'); activePaintSlotIndex = -1; if (activePaintTextureIndex === slotIndex) { slotElement.classList.add('active-paint'); } showStatus(`Assigned ${texturePath ? texturePath.split('/').pop() : 'None'} to paint slot ${slotIndex + 1}.`); render(); }
        function updateTerrainPaintSlotsUI() { if (!terrainMesh || !dom['paintSlots']) return; const paintTextures = terrainMesh.userData.paintTextures || []; dom['paintSlots'].forEach((slot, index) => { const path = paintTextures[index] || ""; slot.style.backgroundImage = path ? `url(${path})` : 'none'; slot.dataset.texturePath = path; }); }
        function updateTerrainPaintTextureScaleUI() { if (!terrainMesh || activePaintTextureIndex < 0 || activePaintTextureIndex > 4) { dom.terrainPaintTexScaleU.value = ""; dom.terrainPaintTexScaleV.value = ""; dom.terrainPaintTextureProps.style.display = 'none'; return; } dom.terrainPaintTextureProps.style.display = 'block'; const currentScale = terrainMesh.userData.paintTextureScales[activePaintTextureIndex] || DEFAULT_TERRAIN_PAINT_TEX_SCALE; dom.terrainPaintTexScaleU.value = currentScale[0]; dom.terrainPaintTexScaleV.value = currentScale[1]; }
        function applyTerrainPaintTextureScale() { if (!terrainMesh || activePaintTextureIndex < 0 || activePaintTextureIndex > 4) return; captureState("Update Paint Texture Scale"); const scaleU = parseFloat(dom.terrainPaintTexScaleU.value) || 1; const scaleV = parseFloat(dom.terrainPaintTexScaleV.value) || 1; const newScale = [scaleU, scaleV]; const scaleUniformName = `uPaintTexScale${activePaintTextureIndex}`; terrainMesh.material.uniforms[scaleUniformName].value.fromArray(newScale); terrainMesh.userData.paintTextureScales[activePaintTextureIndex] = newScale; if (levelData.terrain) levelData.terrain.paintTextureScales[activePaintTextureIndex] = newScale; showStatus(`Scale updated for paint texture ${activePaintTextureIndex + 1}.`); render(); }
        function createTerrainMaterial() {
            const uniforms = {
                uBaseTexture: { value: null }, uPaintTexture0: { value: null }, uPaintTexture1: { value: null }, uPaintTexture2: { value: null }, uPaintTexture3: { value: null }, uPaintTexture4: { value: null },
                uBaseTexScale: { value: new THREE.Vector2(1, 1) }, uPaintTexScale0: { value: new THREE.Vector2(1, 1) }, uPaintTexScale1: { value: new THREE.Vector2(1, 1) }, uPaintTexScale2: { value: new THREE.Vector2(1, 1) }, uPaintTexScale3: { value: new THREE.Vector2(1, 1) }, uPaintTexScale4: { value: new THREE.Vector2(1, 1) },
                uHasBaseTexture: { value: false }, uHasPaintTexture0: { value: false }, uHasPaintTexture1: { value: false }, uHasPaintTexture2: { value: false }, uHasPaintTexture3: { value: false }, uHasPaintTexture4: { value: false },
            };
            const vertexShader = `
                varying vec2 vUv;
                varying vec4 vTextureWeights1;
                varying vec2 vTextureWeights2;
                attribute vec4 textureWeights1;
                attribute vec2 textureWeights2;
                void main() {
                    vUv = uv;
                    vTextureWeights1 = textureWeights1;
                    vTextureWeights2 = textureWeights2;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }`;
            const fragmentShader = `
                precision highp float;
                uniform sampler2D uBaseTexture; uniform sampler2D uPaintTexture0; uniform sampler2D uPaintTexture1; uniform sampler2D uPaintTexture2; uniform sampler2D uPaintTexture3; uniform sampler2D uPaintTexture4;
                uniform vec2 uBaseTexScale; uniform vec2 uPaintTexScale0; uniform vec2 uPaintTexScale1; uniform vec2 uPaintTexScale2; uniform vec2 uPaintTexScale3; uniform vec2 uPaintTexScale4;
                uniform bool uHasBaseTexture; uniform bool uHasPaintTexture0; uniform bool uHasPaintTexture1; uniform bool uHasPaintTexture2; uniform bool uHasPaintTexture3; uniform bool uHasPaintTexture4;
                varying vec2 vUv; varying vec4 vTextureWeights1; varying vec2 vTextureWeights2;
                void main() {
                    vec4 finalColor = vec4(0.8, 0.8, 0.8, 1.0);
                    vec4 baseColor = uHasBaseTexture ? texture2D(uBaseTexture, vUv * uBaseTexScale) : vec4(0.0);
                    vec4 paintColor0 = uHasPaintTexture0 ? texture2D(uPaintTexture0, vUv * uPaintTexScale0) : vec4(0.0);
                    vec4 paintColor1 = uHasPaintTexture1 ? texture2D(uPaintTexture1, vUv * uPaintTexScale1) : vec4(0.0);
                    vec4 paintColor2 = uHasPaintTexture2 ? texture2D(uPaintTexture2, vUv * uPaintTexScale2) : vec4(0.0);
                    vec4 paintColor3 = uHasPaintTexture3 ? texture2D(uPaintTexture3, vUv * uPaintTexScale3) : vec4(0.0);
                    vec4 paintColor4 = uHasPaintTexture4 ? texture2D(uPaintTexture4, vUv * uPaintTexScale4) : vec4(0.0);
                    finalColor = baseColor * vTextureWeights1.r + paintColor0 * vTextureWeights1.g + paintColor1 * vTextureWeights1.b + paintColor2 * vTextureWeights1.a + paintColor3 * vTextureWeights2.r + paintColor4 * vTextureWeights2.g;
                    float totalWeight = vTextureWeights1.r + vTextureWeights1.g + vTextureWeights1.b + vTextureWeights1.a + vTextureWeights2.r + vTextureWeights2.g;
                    if (!uHasBaseTexture && !uHasPaintTexture0 && !uHasPaintTexture1 && !uHasPaintTexture2 && !uHasPaintTexture3 && !uHasPaintTexture4) { finalColor = vec4(0.7, 0.7, 0.7, 1.0); }
                    else if (totalWeight < 0.1) { finalColor = uHasBaseTexture ? baseColor : vec4(0.7, 0.7, 0.7, 1.0); }
                    gl_FragColor = vec4(finalColor.rgb, 1.0);
                }`;
            return new THREE.ShaderMaterial({ uniforms: uniforms, vertexShader: vertexShader, fragmentShader: fragmentShader, side: THREE.DoubleSide, wireframe: dom.toggleWireframe.checked });
        }

        function toggleDecalMode() { isExploreModeActive = false; isPlacingDecal = !isPlacingDecal; dom.addDecalPlane.classList.toggle('active', isPlacingDecal); showStatus(isPlacingDecal ? 'Decal Placement Mode: Click on surface' : 'Exited Decal Placement Mode'); if (!isPlacingDecal && transformControls.object) { transformControls.enabled = true; } else if (isPlacingDecal) { deselectObject(); transformControls.enabled = false; } }
        function getPlacementPosition() { const direction = new THREE.Vector3(); camera.getWorldDirection(direction); const position = new THREE.Vector3(); position.copy(camera.position).addScaledVector(direction, PLACE_DISTANCE); const snap = dom.snapToGrid.checked; if (snap) { position.x = Math.round(position.x / SNAP_TRANSLATION) * SNAP_TRANSLATION; position.y = Math.round(position.y / SNAP_TRANSLATION) * SNAP_TRANSLATION; if (Math.abs(position.y) < SNAP_TRANSLATION / 2) position.y = 0; position.z = Math.round(position.z / SNAP_TRANSLATION) * SNAP_TRANSLATION; } if (position.y < 0.1) position.y = 0.1; return position.toArray(); }
        function createBaseData(type, position, isPlane=false) { const defaultSize = [1,1,isPlane?MIN_SCALE:1]; const defaultRotation = isPlane?[-Math.PI/2,0,0]:[0,0,0]; const data = { id: THREE.MathUtils.generateUUID(), type: type, name: "", isVisible: true, isLocked: false, position: position, rotation: defaultRotation, scale: defaultSize, isCollider: !isPlane, animation: null, parentId: null, userData: {} }; if (isPlane) { data.material = { ref: null, scale: [...DEFAULT_TEX_SCALE], offset: [...DEFAULT_TEX_OFFSET], materialProps: { transparent: false, alphaTest: 0.0 } }; } else if (type === 'box') { data.materials = Array(6).fill(null).map(() => ({ ref: null, scale: [...DEFAULT_TEX_SCALE], offset: [...DEFAULT_TEX_OFFSET] })); } return data; }
        function addGeometry(type) { captureState(`Add ${type}`); const isPlane = type === 'plane'; const placementPos = getPlacementPosition(); if (isPlane) placementPos[1] = 0; const geoData = createBaseData(type, placementPos, isPlane); levelData.geometry.push(geoData); const mesh = createMeshFromData(geoData); if (mesh) { scene.add(mesh); selectObject(mesh, geoData); showStatus(`Added ${type}`); } else { showStatus(`Failed to create ${type}`, 4000); } }
        function addSpawner(type) { captureState(`Add ${type}`); const placementPos = getPlacementPosition(); placementPos[1] = 0.1; const spawnerData = { id: THREE.MathUtils.generateUUID(), type: type, name: "", isVisible: true, isLocked: false, position: placementPos, parentId: null, userData: {} }; if (type === 'item') { spawnerData.itemType = itemTypes[0]; spawnerData.itemId = 'item_' + Math.random().toString(16).substring(2, 8); } else if (type === 'enemy') { spawnerData.enemyType = enemyTypes[0]; } else if (type === 'player_start') { spawnerData.lookDirection = [0, 0, -1]; spawnerData.rotationY = 0; } else if (type === 'level_trigger') { spawnerData.targetLevel = 'levelX.json'; spawnerData.boundingBox = { min: [-1, -0.1, -1], max: [1, 1, 1] }; } else if (type === 'door_trigger') { spawnerData.targetTriggerId = null; spawnerData.requiredKey = null; spawnerData.oneShot = false; } else if (type === 'proximity_trigger') { spawnerData.targetTriggerId = null; spawnerData.radius = 3.0; spawnerData.oneShot = false; } levelData.spawners.push(spawnerData); const marker = createMarkerMesh(spawnerData); if (marker) { scene.add(marker); selectObject(marker, spawnerData); showStatus(`Added ${type} marker`); } else { showStatus(`Failed to create ${type} marker`, 4000); } }
        function addSpriteObject() { captureState("Add Sprite"); const placementPos = getPlacementPosition(); const spriteData = { id: THREE.MathUtils.generateUUID(), type: 'sprite', name: "", isVisible: true, isLocked: false, position: placementPos, rotation: [0,0,0], scale: [1, 1, 1], materialRef: null, autoRotate: true, isCollider: false, center: [0.5, 0.0], sizeAttenuation: false, alphaTest: 0.5, depthWrite: false, tintColor: '#ffffff', parentId: null, userData: {} }; levelData.sprites.push(spriteData); const spriteMesh = createSpriteMesh(spriteData); if (spriteMesh) { scene.add(spriteMesh); selectObject(spriteMesh, spriteData); showStatus('Added sprite'); } else { showStatus('Failed to create sprite', 4000); } }
        function createMeshFromData(geoData) { let geometry; if (geoData.type === 'box') geometry = new THREE.BoxGeometry(1, 1, 1); else if (geoData.type === 'plane') geometry = new THREE.PlaneGeometry(1, 1); else { console.error("Unsupported geometry type:", geoData.type); return null; } let meshMaterial; const isWireframeActive = dom.toggleWireframe.checked; if (geoData.type === 'box') { if (!geoData.materials || !Array.isArray(geoData.materials) || geoData.materials.length !== 6) geoData.materials = Array(6).fill(null).map(() => ({ ref: null, scale: [...DEFAULT_TEX_SCALE], offset: [...DEFAULT_TEX_OFFSET] })); meshMaterial = []; for (let i = 0; i < 6; i++) { const matData = geoData.materials[i] || { ref: null, scale: [...DEFAULT_TEX_SCALE], offset: [...DEFAULT_TEX_OFFSET] }; const baseMaterial = getMaterial(matData.ref, false, null, geoData.materialProps || {}); const faceMaterial = baseMaterial.clone(); faceMaterial.wireframe = isWireframeActive; faceMaterial.userData.mapCloned = false; if (faceMaterial.map) updateMaterialTextureTransform(faceMaterial, matData.scale, matData.offset); meshMaterial.push(faceMaterial); } } else { if (!geoData.material || typeof geoData.material !== 'object') geoData.material = { ref: null, scale: [...DEFAULT_TEX_SCALE], offset: [...DEFAULT_TEX_OFFSET], materialProps: { transparent: false, alphaTest: 0.0 } }; const matData = geoData.material; meshMaterial = getMaterial(matData.ref, false, null, matData.materialProps || {}).clone(); meshMaterial.wireframe = isWireframeActive; if (meshMaterial.map) updateMaterialTextureTransform(meshMaterial, matData.scale, matData.offset); } const mesh = new THREE.Mesh(geometry, meshMaterial); mesh.position.fromArray(geoData.position); mesh.rotation.fromArray(geoData.rotation); mesh.scale.fromArray(geoData.scale); mesh.visible = geoData.isVisible ?? true; mesh.userData.dataId = geoData.id; mesh.userData.isCollider = geoData.isCollider; mesh.userData.isGeometry = true; mesh.userData.isPlane = (geoData.type === 'plane'); mesh.userData.initialPosition = mesh.position.clone(); mesh.userData.initialRotation = mesh.rotation.clone(); if (geoData.animation) mesh.userData.animationData = geoData.animation; if (geoData.userData) mesh.userData = {...mesh.userData, ...geoData.userData}; return mesh; }
        function createMarkerMesh(markerData) { const mat = markerMats[markerData.type]; if (!mat) { console.error("Could not find material for marker type:", markerData.type); return null; } const mesh = new THREE.Mesh(markerGeo, mat); mesh.position.fromArray(markerData.position); if (markerData.rotationY !== undefined) mesh.rotation.y = markerData.rotationY; else if (markerData.lookDirection && markerData.type === 'player_start') { const lookDir = new THREE.Vector3().fromArray(markerData.lookDirection); mesh.lookAt(mesh.position.clone().add(lookDir)); markerData.rotationY = mesh.rotation.y; } mesh.visible = markerData.isVisible ?? true; mesh.userData.dataId = markerData.id; mesh.userData.isMarker = true; mesh.userData.markerType = markerData.type; mesh.userData.initialPosition = mesh.position.clone(); mesh.userData.initialRotation = mesh.rotation.clone(); return mesh; }
        function createSpriteMesh(spriteData) { const material = getMaterial(spriteData.materialRef, true, spriteData); if (!material) { console.error("Failed to create material for sprite:", spriteData.id); return null; } const sprite = new THREE.Sprite(material); sprite.position.fromArray(spriteData.position); sprite.scale.set(spriteData.scale[0], spriteData.scale[1], 1); sprite.center.set(spriteData.center[0] ?? 0.5, spriteData.center[1] ?? 0.0); sprite.visible = spriteData.isVisible ?? true; sprite.userData.dataId = spriteData.id; sprite.userData.isSprite = true; sprite.userData.autoRotate = spriteData.autoRotate ?? true; sprite.userData.initialPosition = sprite.position.clone(); if (!sprite.userData.autoRotate && spriteData.rotation) { _tempEuler.fromArray(spriteData.rotation); sprite.quaternion.setFromEuler(_tempEuler); } return sprite; }
        function showModelMenu() { if (!dom.modelMenu) return; if (Object.keys(loadedModelDefinitions).length === 0 || AVAILABLE_MODELS.length !== Object.keys(loadedModelDefinitions).length) { populateModelMenu(); } dom.modelMenu.style.display = 'flex'; }
        function hideModelMenu() { if (!dom.modelMenu) return; dom.modelMenu.style.display = 'none'; }
        async function loadModelDefinition(modelName) { if (loadedModelDefinitions[modelName]) { return loadedModelDefinitions[modelName]; } try { const response = await fetch(`${MODEL_PATH_PREFIX}${modelName}.json`); if (!response.ok) { throw new Error(`HTTP error! status: ${response.status}`); } const data = await response.json(); loadedModelDefinitions[modelName] = data; console.log(`Loaded model definition: ${modelName}`); return data; } catch (error) { console.error(`Failed to load model definition ${modelName}:`, error); showStatus(`Error loading model: ${modelName}`, 5000); return null; } }
        async function populateModelMenu() { if (!dom.modelList) return; dom.modelList.innerHTML = '<p>Loading models...</p>'; let itemsHtml = ''; for (const modelName of AVAILABLE_MODELS) { const definition = await loadModelDefinition(modelName); if (definition) { const previewFilename = definition.previewImage || ''; const previewSrc = previewFilename ? IMG_PREFIX + previewFilename : ''; const imgTag = previewSrc ? `<img src="${previewSrc}" alt="${definition.modelName || modelName}">` : ''; itemsHtml += ` <div class="model-item" data-model-name="${modelName}" title="Add ${definition.modelName || modelName}"> ${imgTag} <span>${definition.modelName || modelName}</span> </div>`; } else { itemsHtml += `<div class="model-item disabled" title="Failed to load ${modelName}"><span>${modelName} (Error)</span></div>`; } } if (itemsHtml === '') { dom.modelList.innerHTML = '<p>No models found or failed to load.</p>'; } else { dom.modelList.innerHTML = itemsHtml; dom.modelList.querySelectorAll('.model-item:not(.disabled)').forEach(item => { item.addEventListener('click', () => { const modelName = item.dataset.modelName; if (modelName) { addModelInstance(modelName); } }); }); } }
        async function addModelInstance(modelName) { hideModelMenu(); captureState("Add Model"); const definition = loadedModelDefinitions[modelName]; if (!definition) { showStatus(`Model definition "${modelName}" not loaded.`, 4000); console.error(`Attempted to add instance of unloaded model: ${modelName}`); return; } const placementPos = getPlacementPosition(); if (placementPos[1] < 0.5) placementPos[1] = 0.5; const instanceData = { id: THREE.MathUtils.generateUUID(), type: 'model_instance', name: "", isVisible: true, isLocked: false, modelName: modelName, position: placementPos, rotation: [0, 0, 0], scale: [1, 1, 1], animation: null, parentId: null, userData: {} }; levelData.modelInstances.push(instanceData); const modelGroup = createModelGroup(instanceData, definition); if (modelGroup) { scene.add(modelGroup); selectObject(modelGroup, instanceData); showStatus(`Added model: ${definition.modelName || modelName}`); render(); } else { showStatus(`Failed to create model instance: ${modelName}`, 4000); const index = levelData.modelInstances.findIndex(item => item.id === instanceData.id); if (index > -1) levelData.modelInstances.splice(index, 1); } }
        function createModelGroup(instanceData, definition) { const group = new THREE.Group(); group.position.fromArray(instanceData.position); group.rotation.fromArray(instanceData.rotation); group.scale.fromArray(instanceData.scale); group.visible = instanceData.isVisible ?? true; group.userData = { dataId: instanceData.id, isModelInstance: true, modelName: instanceData.modelName, initialPosition: group.position.clone(), initialRotation: group.rotation.clone(), initialScale: group.scale.clone(), }; if (instanceData.animation) group.userData.animationData = instanceData.animation; if (!definition.geometry || !Array.isArray(definition.geometry)) { console.error(`Model definition ${definition.modelName} has no valid geometry array.`); return null; } const textureMap = definition.textures || {}; const isWireframeActive = dom.toggleWireframe.checked; for (const geoDef of definition.geometry) { const childGeoData = { id: THREE.MathUtils.generateUUID(), type: geoDef.type || 'box', position: geoDef.position || [0, 0, 0], rotation: geoDef.rotation || [0, 0, 0], scale: geoDef.scale || [1, 1, 1], isCollider: geoDef.isCollider !== undefined ? geoDef.isCollider : true, materialProps: geoDef.materialProps || {}, userData: geoDef.userData || {} }; const resolveTextureRef = (matDef) => { let texturePath = null; if (matDef && matDef.ref && textureMap[matDef.ref]) { texturePath = IMG_PREFIX + textureMap[matDef.ref]; } return { ref: texturePath, scale: matDef?.scale || [...DEFAULT_TEX_SCALE], offset: matDef?.offset || [...DEFAULT_TEX_OFFSET] }; }; if (geoDef.type === 'box' && geoDef.materials) { childGeoData.materials = geoDef.materials.map(resolveTextureRef); } else if (geoDef.type === 'plane' && geoDef.material) { childGeoData.material = resolveTextureRef(geoDef.material); childGeoData.material.materialProps = geoDef.material.materialProps || { transparent: false, alphaTest: 0.0 }; } else { if (geoDef.type === 'box') { childGeoData.materials = Array(6).fill(null).map(()=>resolveTextureRef(null)); } else if (geoDef.type === 'plane') { childGeoData.material = resolveTextureRef(null); childGeoData.material.materialProps = { transparent: false, alphaTest: 0.0 }; } } const childMesh = createMeshFromData(childGeoData); if (childMesh) { childMesh.position.fromArray(childGeoData.position); childMesh.rotation.fromArray(childGeoData.rotation); childMesh.scale.fromArray(childGeoData.scale); childMesh.userData.parentGroupDataId = instanceData.id; childMesh.userData.isModelPart = true; if (geoDef.animation) { childMesh.userData.animationData = geoDef.animation; } group.add(childMesh); } else { console.warn("Failed to create child mesh for model:", definition.modelName, geoDef); } } return group; }
        function createEditorGroup(groupData) { const group = new THREE.Group(); group.uuid = groupData.id; group.position.fromArray(groupData.position); group.rotation.fromArray(groupData.rotation); group.scale.fromArray(groupData.scale); group.visible = groupData.isVisible ?? true; group.userData = { dataId: groupData.id, isEditorGroup: true, name: groupData.name || '', initialPosition: group.position.clone(), initialRotation: group.rotation.clone(), initialScale: group.scale.clone(), }; return group; }
        function applyTextureToSelected(applyToAll=false) { if (selectedMeshes.length === 0) { showStatus("Select an object first.", 4000); return; } const locked = selectedObjectDatas.some(d => d.isLocked); if (locked) { showStatus("Cannot apply texture, selection contains locked objects.", 4000); return; } captureState("Apply Texture"); const textureToApply = selectedTexturePath; const isWireframeActive = dom.toggleWireframe.checked; const currentScale = [parseFloat(dom.texScaleU.value) || 1, parseFloat(dom.texScaleV.value) || 1]; const currentOffset = [parseFloat(dom.texOffsetU.value) || 0, parseFloat(dom.texOffsetV.value) || 0]; let appliedCount = 0; selectedMeshes.forEach((mesh, index) => { const data = selectedObjectDatas[index]; if (data && mesh.userData.isGeometry) { if (data.type === 'box') { const indicesToUpdate = applyToAll ? [0, 1, 2, 3, 4, 5] : [selectedFaceIndex]; const newBaseMaterial = getMaterial(textureToApply, false); indicesToUpdate.forEach(faceIdx => { const matData = data.materials[faceIdx]; matData.ref = textureToApply || null; matData.scale = [...currentScale]; matData.offset = [...currentOffset]; if (mesh.material[faceIdx]?.map) mesh.material[faceIdx].map.dispose(); if (mesh.material[faceIdx]) mesh.material[faceIdx].dispose(); const newFaceMaterial = newBaseMaterial.clone(); newFaceMaterial.wireframe = isWireframeActive; newFaceMaterial.userData.mapCloned = false; if (newFaceMaterial.map) updateMaterialTextureTransform(newFaceMaterial, matData.scale, matData.offset); mesh.material[faceIdx] = newFaceMaterial; }); appliedCount++; } else if (data.type === 'plane') { const matData = data.material; matData.ref = textureToApply || null; matData.scale = [...currentScale]; matData.offset = [...currentOffset]; if (mesh.material?.map) mesh.material.map.dispose(); if (mesh.material) mesh.material.dispose(); const materialProps = matData.materialProps || {}; const newBaseMaterial = getMaterial(matData.ref, false, null, materialProps); mesh.material = newBaseMaterial.clone(); mesh.material.wireframe = isWireframeActive; if (mesh.material.map) updateMaterialTextureTransform(mesh.material, matData.scale, matData.offset); appliedCount++; } } else if (data && mesh.userData.isSprite) { data.materialRef = textureToApply || null; const newMaterial = getMaterial(data.materialRef, true, data); if (mesh.material !== newMaterial) { if (mesh.material?.map) mesh.material.map.dispose(); if (mesh.material) mesh.material.dispose(); mesh.material = newMaterial; } else mesh.material.needsUpdate = true; appliedCount++; } }); if (appliedCount > 0) showStatus(`Texture applied to ${appliedCount} object(s).`); else showStatus("No compatible objects selected for texturing."); updateSelectedObjectUI(); render(); }
        function toggleWireframeMode() { const isChecked = dom.toggleWireframe.checked; loadedMaterials = {}; scene.traverse(child => { if (child === terrainMesh && child.isMesh && child.material.isShaderMaterial) { child.material.wireframe = isChecked; child.material.needsUpdate = true; } else if (child === waterMesh && child.isMesh) { const oldMat = child.material; const texPath = oldMat.map ? IMG_PREFIX + 'water.png' : null; const newMat = new THREE.MeshStandardMaterial({ color: texPath ? 0xffffff : 0x205080, map: getTexture(texPath), opacity: 0.75, transparent: true, roughness: 0.2, metalness: 0.1, side: THREE.DoubleSide, wireframe: isChecked }); if (newMat.map) { newMat.map.wrapS = THREE.RepeatWrapping; newMat.map.wrapT = THREE.RepeatWrapping; const scaleFactor = 4; const size = terrainMesh?.userData.size || [TERRAIN_DEFAULT_SIZE, TERRAIN_DEFAULT_SIZE]; newMat.map.repeat.set(size[0] / scaleFactor, size[1] / scaleFactor); } if(oldMat.map && !oldMat.userData.mapCloned) oldMat.map.dispose(); if(oldMat) oldMat.dispose(); child.material = newMat; } else if (child.isMesh && (child.userData.isGeometry || child.userData.isModelPart ) ) { const parentData = findObjectDataById(child.userData.parentGroupDataId); const objData = findObjectDataById(child.userData.dataId); let matData = null; let texturePath = null; let materialProps = {}; if (child.userData.isModelPart && parentData?.type === 'model_instance') { materialProps = { metalness: child.material?.metalness || 0.1, roughness: child.material?.roughness || 0.8, side: child.material?.side || THREE.DoubleSide, ...child.userData.materialProps }; texturePath = child.material?.map?.userData?.texturePath || child.material?.map?.image?.src || null; if(texturePath && !texturePath.startsWith(IMG_PREFIX)) texturePath = IMG_PREFIX + texturePath.split('/').pop(); } else if (child.userData.isGeometry && objData?.type === 'box') { } else if (child.userData.isGeometry && objData?.type === 'plane') { matData = objData.material; texturePath = matData?.ref; materialProps = matData?.materialProps || {}; } else { return; } const applyWireframe = (material) => { if (!material || !material.isMeshStandardMaterial) return material; const texPath = material.map?.userData?.texturePath || material.map?.image?.src || texturePath || null; const baseMat = getMaterial(texPath, false, null, { metalness: material.metalness, roughness: material.roughness, side: material.side, transparent: material.transparent, alphaTest: material.alphaTest, polygonOffset: material.polygonOffset, polygonOffsetFactor: material.polygonOffsetFactor, polygonOffsetUnits: material.polygonOffsetUnits, ...materialProps }); const newMat = baseMat.clone(); newMat.wireframe = isChecked; newMat.userData.mapCloned = false; if (newMat.map && material.map) { newMat.map.repeat.copy(material.map.repeat); newMat.map.offset.copy(material.map.offset); if (material.userData.mapCloned) newMat.userData.mapCloned = true; } return newMat; }; const disposeMaterial = (material) => { if (material?.map && !material.userData.mapCloned) material.map.dispose(); if (material && material.dispose) material.dispose(); }; if (Array.isArray(child.material)) { const newMaterials = []; for(let i=0; i < child.material.length; i++) { const oldMat = child.material[i]; const newMat = applyWireframe(oldMat); newMaterials.push(newMat); disposeMaterial(oldMat); } child.material = newMaterials; } else if (child.material && !Array.isArray(child.material)) { const newMaterial = applyWireframe(child.material); disposeMaterial(child.material); child.material = newMaterial; } } }); showStatus(`Wireframe ${isChecked ? 'ON' : 'OFF'}`); render(); }
        function deleteSelected() { if (selectedMeshes.length === 0) return; const locked = selectedObjectDatas.some(d => d.isLocked); if (locked) { showStatus("Cannot delete, selection contains locked objects.", 3000); return; } if (!confirm(`Are you sure you want to delete ${selectedMeshes.length} object(s)?`)) return; captureState("Delete Object(s)"); const idsToDelete = new Set(selectedObjectDatas.map(d => d.id)); const meshesToRemove = [...selectedMeshes]; deselectObject(false); idsToDelete.forEach(idToDelete => { let list = null; let index = -1; if ((list = levelData.geometry) && (index = list.findIndex(item => item.id === idToDelete)) > -1) list.splice(index, 1); else if ((list = levelData.sprites) && (index = list.findIndex(item => item.id === idToDelete)) > -1) list.splice(index, 1); else if ((list = levelData.spawners) && (index = list.findIndex(item => item.id === idToDelete)) > -1) list.splice(index, 1); else if ((list = levelData.modelInstances) && (index = list.findIndex(item => item.id === idToDelete)) > -1) list.splice(index, 1); else if ((list = levelData.groups) && (index = list.findIndex(item => item.id === idToDelete)) > -1) { const groupData = list[index]; list.splice(index, 1); groupData.childrenIds?.forEach(childId => { const childData = findObjectDataById(childId); if (childData) childData.parentId = null; }); } }); meshesToRemove.forEach(objectToRemove => { const dispose = (obj) => { if (obj.geometry) obj.geometry.dispose(); if (obj.material) { if (Array.isArray(obj.material)) obj.material.forEach(mat => { if (mat?.map) mat.map.dispose(); if(mat) mat.dispose(); }); else { if (obj.material.map) obj.material.map.dispose(); if (obj.material.dispose) obj.material.dispose(); } } }; if (obj.isGroup) { objectToRemove.traverse(child => { if (child.isMesh || child.isSprite) dispose(child); }); } else { dispose(objectToRemove); } scene.remove(objectToRemove); }); showStatus(`Deleted ${idsToDelete.size} object(s)`); render(); }
        function cloneSelected() { if (selectedMeshes.length === 0) return; captureState("Clone Object(s)"); const clonedMeshes = []; const clonedDatas = []; const offsetAmount = (dom.snapToGrid.checked ? SNAP_TRANSLATION : 1.0) || 1.0; selectedObjectDatas.forEach((originalData, index) => { const originalMesh = selectedMeshes[index]; const clonedData = deepClone(originalData); clonedData.id = THREE.MathUtils.generateUUID(); clonedData.parentId = null; clonedData.isLocked = false; if (clonedData.position) { clonedData.position[0] += offsetAmount; clonedData.position[2] += offsetAmount; if (clonedData.position[1] < 0.1 && !(originalMesh.userData.isPlane || originalMesh.userData.isSprite)) clonedData.position[1] = (originalMesh.userData.isModelInstance ? 0.5 : 0.6); else if (clonedData.position[1] < 0) clonedData.position[1] = 0; } let newMesh; let success = false; let list; let creatorFunc; if (originalMesh.userData.isGeometry) { list = levelData.geometry; creatorFunc = createMeshFromData; } else if (originalMesh.userData.isSprite) { list = levelData.sprites; creatorFunc = createSpriteMesh; } else if (originalMesh.userData.isMarker) { list = levelData.spawners; creatorFunc = createMarkerMesh; } else if (originalMesh.userData.isModelInstance) { list = levelData.modelInstances; const definition = loadedModelDefinitions[clonedData.modelName]; if (!definition) { console.error("Cannot clone model instance, definition not loaded:", clonedData.modelName); return; } creatorFunc = (instanceData) => createModelGroup(instanceData, definition); } else if (originalMesh.userData.isEditorGroup) { list = levelData.groups; creatorFunc = createEditorGroup; clonedData.childrenIds = []; } else { console.error("Unknown object type to clone:", originalData.type, originalMesh.userData); return; } if (!list || !creatorFunc) return; list.push(clonedData); newMesh = creatorFunc(clonedData); if (newMesh) { scene.add(newMesh); clonedMeshes.push(newMesh); clonedDatas.push(clonedData); } else { const idx = list.findIndex(item => item.id === clonedData.id); if (idx > -1) list.splice(idx, 1); console.error(`Failed to create cloned mesh for ${clonedData.type}`); } }); if (clonedMeshes.length > 0) { deselectObject(false); selectedMeshes = clonedMeshes; selectedObjectDatas = clonedDatas; selectedMesh = selectedMeshes[selectedMeshes.length - 1]; selectedObjectData = selectedObjectDatas[selectedMeshes.length - 1]; transformControls.attach(selectedMesh); outlinePass.selectedObjects = selectedMeshes; updateSelectedObjectUI(); showStatus(`Cloned ${clonedMeshes.length} object(s)`); } else { showStatus(`Error cloning object(s)`, 5000); } render(); }
        function placeDecalPlane(intersect) { if (!selectedTexturePath) { showStatus("Select a texture for the decal first.", 3000); return; } captureState("Place Decal"); const pos = intersect.point.clone(); const normal = intersect.face.normal.clone(); const targetObject = intersect.object; const worldNormal = normal.transformDirection(targetObject.matrixWorld).normalize(); pos.addScaledVector(worldNormal, _decalOffset); const decalSize = 0.5; const decalScale = [decalSize, decalSize, MIN_SCALE]; const tempObject = new THREE.Object3D(); tempObject.position.copy(pos); tempObject.lookAt(pos.clone().add(worldNormal)); tempObject.updateMatrixWorld(); const decalRotation = tempObject.rotation.toArray().slice(0, 3); const decalMatProps = { transparent: true, alphaTest: 0.1, depthWrite: false, polygonOffset: true, polygonOffsetFactor: -1, polygonOffsetUnits: -1 }; const geoData = { id: THREE.MathUtils.generateUUID(), type: 'plane', name: "", isVisible: true, isLocked: false, position: pos.toArray(), rotation: decalRotation, scale: decalScale, isCollider: false, material: { ref: selectedTexturePath, scale: [1,1], offset: [0,0], materialProps: decalMatProps }, parentId: null, userData: { isDecal: true } }; levelData.geometry.push(geoData); const mesh = createMeshFromData(geoData); if (mesh) { scene.add(mesh); selectObject(mesh, geoData); showStatus(`Placed decal plane`); } else { showStatus(`Failed to create decal plane`, 4000); const index = levelData.geometry.findIndex(item => item.id === geoData.id); if (index > -1) levelData.geometry.splice(index, 1); } }
        function findObjectDataById(id) { if (!id) return null; return levelData.geometry.find(item => item.id === id) || levelData.prefabs.find(item => item.id === id) || levelData.spawners.find(item => item.id === id) || levelData.sprites.find(item => item.id === id) || levelData.modelInstances.find(item => item.id === id) || levelData.groups.find(item => item.id === id); }
        function getObjectSceneMesh(dataId) { return scene.getObjectByProperty('uuid', dataId); }
        function setGizmoMode(newMode, isUserAction = false) { if (!transformControls) return; let canTranslate = selectedMeshes.length > 0; let canRotate = selectedMeshes.length > 0 && selectedMeshes.every(m => !m.userData.isMarker || (m.userData.isMarker && findObjectDataById(m.userData.dataId)?.type !== 'level_trigger')); let canScale = selectedMeshes.length > 0 && selectedMeshes.every(m => (m.userData.isGeometry || m.userData.isSprite || m.userData.isModelInstance || m.userData.isEditorGroup) && !m.userData.isMarker); let allowed = (newMode === 'translate' && canTranslate) || (newMode === 'rotate' && canRotate) || (newMode === 'scale' && canScale); let targetMode = transformControls.getMode(); const locked = selectedObjectDatas.some(d => d?.isLocked); if (locked) allowed = false; if (allowed) { targetMode = newMode; } else if (isUserAction) { if (canTranslate) targetMode = 'translate'; else if (canRotate) targetMode = 'rotate'; else if (canScale) targetMode = 'scale'; else targetMode = null; if (locked) targetMode = 'translate'; if (targetMode && targetMode !== newMode) { showStatus(`Mode '${newMode}' not available${locked ? ' (Locked)' : ''}. Switched to '${targetMode}'.`, 3000); } else if (!targetMode) { showStatus(`Mode '${newMode}' not available${locked ? ' (Locked)' : ''}. No manipulation possible.`, 3000); } } else { if (transformControls.mode === 'rotate' && !canRotate) targetMode = canTranslate ? 'translate' : (canScale ? 'scale' : null); else if (transformControls.mode === 'scale' && !canScale) targetMode = canTranslate ? 'translate' : (canRotate ? 'rotate' : null); else if (!canTranslate && !canRotate && !canScale) targetMode = null; else if (!allowed) { targetMode = canTranslate ? 'translate' : (canRotate ? 'rotate' : (canScale ? 'scale' : null)); } if (locked) targetMode = 'translate'; } if (transformControls.object && targetMode) { transformControls.setMode(targetMode); transformControls.showX = true; transformControls.showY = true; transformControls.showZ = true; transformControls.enabled = !locked; } else if (selectedMeshes.length === 0) { transformControls.setMode('translate'); transformControls.detach(); targetMode = 'translate'; } updateModeInfoUI(targetMode || 'translate'); if (isUserAction && allowed) { lastGizmoMode = newMode; } }
        function selectObject(obj, data, multiSelect = false) { if (isTerrainEditing || isExploreModeActive) return; if (obj === terrainMesh || obj === waterMesh) { showStatus("Use Terrain/Environment Tools section to edit.", 2000); deselectObject(); return; } const objIndex = selectedMeshes.findIndex(m => m.uuid === obj.uuid); if (multiSelect) { if (objIndex > -1) { selectedMeshes.splice(objIndex, 1); selectedObjectDatas.splice(objIndex, 1); } else { if (!data.isLocked) { selectedMeshes.push(obj); selectedObjectDatas.push(data); } else { showStatus("Cannot add locked object to selection.", 2000); return; } } } else { if (objIndex > -1 && selectedMeshes.length === 1) { return; } deselectObject(false); if (!data.isLocked) { selectedMeshes = [obj]; selectedObjectDatas = [data]; } else { showStatus("Object is locked. Triple-click to unlock.", 2000); return; } } if (selectedMeshes.length > 0) { selectedMesh = selectedMeshes[selectedMeshes.length - 1]; selectedObjectData = selectedObjectDatas[selectedMeshes.length - 1]; transformControls.attach(selectedMesh); const locked = selectedObjectDatas.some(d => d.isLocked); transformControls.enabled = !locked; outlinePass.selectedObjects = selectedMeshes; selectedFaceIndex = 0; let initialMode = 'translate'; let canRotate = selectedMeshes.every(m => !m.userData.isMarker || (m.userData.isMarker && findObjectDataById(m.userData.dataId)?.type !== 'level_trigger')); let canScale = selectedMeshes.every(m => (m.userData.isGeometry || m.userData.isSprite || m.userData.isModelInstance || m.userData.isEditorGroup) && !m.userData.isMarker); if (lastGizmoMode === 'rotate' && canRotate) initialMode = 'rotate'; else if (lastGizmoMode === 'scale' && canScale) initialMode = 'scale'; else initialMode = 'translate'; setGizmoMode(initialMode, false); } else { deselectObject(false); } updateSelectedObjectUI(); dom.deleteObject.disabled = selectedMeshes.length === 0 || selectedObjectDatas.some(d => d?.isLocked); dom.cloneObject.disabled = selectedMeshes.length === 0; dom.groupObjects.disabled = selectedMeshes.length < 2 || selectedObjectDatas.some(d => d?.isLocked || d?.parentId); dom.ungroupObjects.disabled = !(selectedMeshes.length === 1 && selectedMesh?.userData.isEditorGroup) || selectedObjectData?.isLocked; const firstData = selectedObjectDatas[0]; const canApplyTex = selectedMeshes.length > 0 && selectedObjectDatas.every(d => d.type === firstData.type && (d.type === 'box' || d.type === 'plane' || d.type === 'sprite')); dom.applyTexture.disabled = !canApplyTex || selectedObjectDatas.some(d => d?.isLocked); dom.applyTextureAll.disabled = !canApplyTex || selectedObjectDatas.some(d => d?.isLocked || d.type !== 'box'); dom.applyTextureSprite.disabled = !(selectedMeshes.length === 1 && selectedMesh?.userData.isSprite) || selectedObjectData?.isLocked; render(); }
        function deselectObject(renderUpdate=true) { if (isTerrainEditing) { transformControls.detach(); if (renderUpdate) render(); return; } if (selectedMeshes.length === 0) return; if (animationPreviewState.isPlaying && selectedMeshes.includes(animationPreviewState.mesh)) { resetToInitialTransform(animationPreviewState.mesh); animationPreviewState.isPlaying = false; showStatus("Animation preview stopped due to deselection."); } transformControls.detach(); outlinePass.selectedObjects = []; selectedMeshes = []; selectedObjectDatas = []; selectedMesh = null; selectedObjectData = null; selectedFaceIndex = 0; updateSelectedObjectUI(); dom.deleteObject.disabled = true; dom.cloneObject.disabled = true; dom.groupObjects.disabled = true; dom.ungroupObjects.disabled = true; dom.applyTexture.disabled = true; dom.applyTextureAll.disabled = true; dom.applyTextureSprite.disabled = true; setGizmoMode('translate', false); if (!isTerrainEditing && !isExploreModeActive) orbitControls.enabled = true; if (renderUpdate) render(); }
        function cycleTransformMode(modes=['rotate','scale']) { if (selectedMeshes.length === 0 || selectedObjectDatas.some(d=>d?.isLocked) || isExploreModeActive) return; let availableModes = []; let canRotate = selectedMeshes.every(m => !m.userData.isMarker || (m.userData.isMarker && findObjectDataById(m.userData.dataId)?.type !== 'level_trigger')); let canScale = selectedMeshes.every(m => (m.userData.isGeometry || m.userData.isSprite || m.userData.isModelInstance || m.userData.isEditorGroup) && !m.userData.isMarker); if (modes.includes('rotate') && canRotate) availableModes.push('rotate'); if (modes.includes('scale') && canScale) availableModes.push('scale'); if (availableModes.length === 0) return; const currentMode = transformControls.getMode(); let nextMode = availableModes[0]; const currentIndex = availableModes.indexOf(currentMode); if (currentIndex !== -1) nextMode = availableModes[(currentIndex + 1) % availableModes.length]; setGizmoMode(nextMode, true); }
        function updateModeInfoUI(activeMode) { const buttons = { translate: dom.modeTranslate, rotate: dom.modeRotate, scale: dom.modeScale }; let canTranslate = selectedMeshes.length > 0; let canRotate = selectedMeshes.length > 0 && selectedMeshes.every(m => !m.userData.isMarker || (m.userData.isMarker && findObjectDataById(m.userData.dataId)?.type !== 'level_trigger')); let canScale = selectedMeshes.length > 0 && selectedMeshes.every(m => (m.userData.isGeometry || m.userData.isSprite || m.userData.isModelInstance || m.userData.isEditorGroup) && !m.userData.isMarker); const locked = selectedObjectDatas.some(d => d?.isLocked); if (locked) { canRotate = false; canScale = false; } buttons.translate.disabled = !canTranslate; buttons.rotate.disabled = !canRotate; buttons.scale.disabled = !canScale; for (const mode in buttons) { if (buttons[mode]) buttons[mode].classList.toggle('active', mode === activeMode && !buttons[mode].disabled); } if (dom.currentModeInfo) { dom.currentModeInfo.style.display = selectedMeshes.length > 0 ? 'block' : 'none'; dom.currentModeInfo.textContent = selectedMeshes.length > 0 && activeMode ? `Mode: ${activeMode.charAt(0).toUpperCase() + activeMode.slice(1)}${locked ? ' (Locked)' : ''}` : ''; } }
        function onObjectTransform() { if (selectedMeshes.length === 0 || !transformControls.object) return; const controllingObject = transformControls.object; const controllingData = findObjectDataById(controllingObject.userData.dataId); if (!controllingData || controllingData.isLocked) return; if (selectedMeshes.length === 1) { selectedObjectData.position = selectedMesh.position.toArray(); if (selectedMesh.userData.isSprite) { const isFixedRotation = !(selectedObjectData?.autoRotate ?? true); if (isFixedRotation && transformControls.getMode() === 'rotate') selectedObjectData.rotation = selectedMesh.rotation.toArray().slice(0, 3); const currentScale = selectedMesh.scale; let newScaleX = Math.max(MIN_SCALE, Math.abs(currentScale.x)) * Math.sign(currentScale.x || 1); let newScaleY = Math.max(MIN_SCALE, Math.abs(currentScale.y)) * Math.sign(currentScale.y || 1); selectedObjectData.scale = [newScaleX, newScaleY, 1.0]; selectedMesh.scale.set(newScaleX, newScaleY, 1.0); } else if (selectedMesh.userData.isMarker) { selectedObjectData.rotationY = selectedMesh.rotation.y; if(Math.abs(selectedMesh.rotation.x) > 0.001 || Math.abs(selectedMesh.rotation.z) > 0.001) { selectedMesh.rotation.x = 0; selectedMesh.rotation.z = 0; } selectedMesh.scale.set(1, 1, 1); if(selectedObjectData.scale) selectedObjectData.scale = [1, 1, 1]; } else if (selectedMesh.userData.isGeometry || selectedMesh.userData.isModelInstance || selectedMesh.userData.isEditorGroup) { selectedObjectData.rotation = selectedMesh.rotation.toArray().slice(0, 3); const currentScale = selectedMesh.scale; let newScaleX = Math.max(MIN_SCALE, Math.abs(currentScale.x)) * Math.sign(currentScale.x || 1); let newScaleY = Math.max(MIN_SCALE, Math.abs(currentScale.y)) * Math.sign(currentScale.y || 1); let newScaleZ = 1.0; const isPlane = selectedObjectData?.type === 'plane'; if (selectedMesh.userData.isEditorGroup || (selectedMesh.userData.isGeometry && !isPlane) || selectedMesh.userData.isModelInstance) { newScaleZ = Math.max(MIN_SCALE, Math.abs(currentScale.z)) * Math.sign(currentScale.z || 1); } else if (isPlane) { newScaleZ = selectedObjectData.scale[2] || MIN_SCALE; } if (transformControls.getMode() === 'scale' && isShiftPressed && !isPlane && !selectedMesh.userData.isSprite) { const uniformScale = Math.max(MIN_SCALE, Math.max(Math.abs(newScaleX), Math.abs(newScaleY), Math.abs(newScaleZ))); newScaleX = uniformScale * Math.sign(currentScale.x || 1); newScaleY = uniformScale * Math.sign(currentScale.y || 1); newScaleZ = uniformScale * Math.sign(currentScale.z || 1); } selectedObjectData.scale = [newScaleX, newScaleY, newScaleZ]; selectedMesh.scale.set(newScaleX, newScaleY, newScaleZ); } } else { selectedObjectDatas.forEach((data, index) => { const mesh = selectedMeshes[index]; if (mesh && data && !data.isLocked) { data.position = mesh.position.toArray(); data.rotation = mesh.rotation.toArray().slice(0, 3); data.scale = mesh.scale.toArray(); } }); } updateSelectedObjectUI(false); }
        function updateSelectedObjectUI(fullUpdate=true) { const show = (elem, display='block') => elem.style.display = display; const hide = (elem) => elem.style.display = 'none'; if (selectedMeshes.length === 0) { hide(dom.selectedObjectInfo); updateModeInfoUI('translate'); dom.groupObjects.disabled = true; dom.ungroupObjects.disabled = true; return; } show(dom.selectedObjectInfo); dom.groupObjects.disabled = selectedMeshes.length < 2 || selectedObjectDatas.some(d => d?.isLocked || d?.parentId); dom.ungroupObjects.disabled = !(selectedMeshes.length === 1 && selectedMesh?.userData.isEditorGroup) || selectedObjectData?.isLocked; if (selectedMeshes.length > 1) { dom.selectedName.value = ""; dom.selectedName.placeholder = "Multiple Selected"; dom.selectedObjectType.textContent = `Type: Multiple (${selectedMeshes.length})`; dom.selectedIsVisible.checked = false; dom.selectedIsVisible.indeterminate = true; dom.selectedIsLocked.checked = false; dom.selectedIsLocked.indeterminate = true; hide(dom.rotationSection); hide(dom.scaleSection); hide(dom.geometryProps); hide(dom.spriteProps); hide(dom.animationProps); hide(dom.selectedSpawnerProps); hide(dom.selectedPrefabProps); dom.selectedPosX.value = ""; dom.selectedPosY.value = ""; dom.selectedPosZ.value = ""; dom.selectedPosX.placeholder = "---"; dom.selectedPosY.placeholder = "---"; dom.selectedPosZ.placeholder = "---"; dom.selectedName.disabled = true; dom.selectedIsVisible.disabled = true; dom.selectedIsLocked.disabled = true; dom.selectedPosX.disabled = true; dom.selectedPosY.disabled = true; dom.selectedPosZ.disabled = true; } else if (selectedObjectData && selectedMesh) { dom.selectedName.placeholder = "Optional name..."; const isLocked = selectedObjectData.isLocked ?? false; dom.selectedName.disabled = isLocked; dom.selectedIsVisible.disabled = isLocked; dom.selectedIsLocked.disabled = isLocked; dom.selectedPosX.disabled = isLocked; dom.selectedPosY.disabled = isLocked; dom.selectedPosZ.disabled = isLocked; dom.selectedIsVisible.indeterminate = false; dom.selectedIsLocked.indeterminate = false; dom.selectedPosX.placeholder = ""; dom.selectedPosY.placeholder = ""; dom.selectedPosZ.placeholder = ""; if (fullUpdate) { dom.selectedPrefabProps.innerHTML = ''; dom.selectedSpawnerProps.innerHTML = ''; } hide(dom.selectedPrefabProps); hide(dom.selectedSpawnerProps); hide(dom.geometryProps); hide(dom.spriteProps); hide(dom.animationProps); hide(dom.rotationSection); hide(dom.scaleSection); hide(dom.faceSelector); hide(dom.textureProps); hide(dom.applyTextureContainer); hide(dom.applyTextureContainerSprite); hide(dom.planeTransparencyProps); dom.selectedName.value = selectedObjectData.name || ''; dom.selectedIsVisible.checked = selectedObjectData.isVisible ?? true; dom.selectedIsLocked.checked = isLocked; let objectTypeName = selectedObjectData.type || 'Unknown'; if (selectedObjectData.type === 'model_instance') { objectTypeName = `Model Instance (${selectedObjectData.modelName || 'Unknown'})`; } else if (selectedObjectData.type === 'group') { objectTypeName = `Group (${selectedObjectData.childrenIds?.length || 0} children)`; } else if (selectedObjectData.userData?.isDecal) { objectTypeName = 'Decal Plane'; } dom.selectedObjectType.textContent = `Type: ${objectTypeName}`; dom.selectedPosX.value = selectedObjectData.position[0].toFixed(2); dom.selectedPosY.value = selectedObjectData.position[1].toFixed(2); dom.selectedPosZ.value = selectedObjectData.position[2].toFixed(2); const isGeometry = selectedMesh.userData.isGeometry; const isSprite = selectedMesh.userData.isSprite; const isMarker = selectedMesh.userData.isMarker; const isModelInstance = selectedMesh.userData.isModelInstance; const isEditorGroup = selectedMesh.userData.isEditorGroup; const isPlane = selectedObjectData?.type === 'plane'; const isBox = selectedObjectData?.type === 'box'; const isFixedRotation = isSprite && !(selectedObjectData.autoRotate ?? true); const showRotation = isGeometry || isMarker || isSprite || isModelInstance || isEditorGroup; if(showRotation) show(dom.rotationSection); if (showRotation) { let rotX=0, rotY=0, rotZ=0; if (isMarker) { rotY = selectedObjectData.rotationY || 0; } else { const rotSource = selectedObjectData.rotation || [0,0,0]; rotX = rotSource[0]; rotY = rotSource[1]; rotZ = rotSource[2]; } dom.selectedRotX.value = THREE.MathUtils.radToDeg(rotX).toFixed(1); dom.selectedRotY.value = THREE.MathUtils.radToDeg(rotY).toFixed(1); dom.selectedRotZ.value = THREE.MathUtils.radToDeg(rotZ).toFixed(1); dom.selectedRotX.disabled = isLocked || isMarker || (isSprite && !dom.selectedFixedRotation.checked); dom.selectedRotY.disabled = isLocked || (isSprite && !dom.selectedFixedRotation.checked); dom.selectedRotZ.disabled = isLocked || isMarker || (isSprite && !dom.selectedFixedRotation.checked); } const showScale = isGeometry || isSprite || isModelInstance || isEditorGroup; if(showScale) show(dom.scaleSection); if (showScale) { const scaleSource = selectedObjectData.scale || [1,1,1]; dom.selectedScaleX.value = scaleSource[0].toFixed(2); dom.selectedScaleY.value = scaleSource[1].toFixed(2); dom.selectedScaleZ.value = isSprite ? (1.0).toFixed(2) : scaleSource[2].toFixed(2); const disableScale = isMarker || isLocked; dom.selectedScaleX.disabled = disableScale; dom.selectedScaleY.disabled = disableScale; dom.selectedScaleZ.disabled = disableScale || isSprite; } if (isGeometry) { show(dom.geometryProps); show(dom.applyTextureContainer,'flex'); show(dom.textureProps); dom.selectedIsCollider.checked = selectedObjectData.isCollider ?? !isPlane; dom.selectedIsCollider.disabled = isLocked; dom.applyTextureAll.disabled = isLocked || !isBox; dom.applyTexture.textContent = isBox ? "Apply to Face" : "Apply Texture"; let currentMatData = null; let currentTexPath = ""; if (isBox) { show(dom.faceSelector,'grid'); dom.faceSelector.querySelectorAll('button').forEach((btn, index) => btn.classList.toggle('active', index === selectedFaceIndex)); currentMatData = selectedObjectData.materials?.[selectedFaceIndex]; } else { currentMatData = selectedObjectData.material; show(dom.planeTransparencyProps); dom.selectedIsTransparent.checked = currentMatData?.materialProps?.transparent ?? false; dom.selectedPlaneAlphaTest.value = (currentMatData?.materialProps?.alphaTest ?? 0.1).toFixed(2); dom.selectedPlaneAlphaTest.disabled = isLocked || !dom.selectedIsTransparent.checked; dom.selectedIsTransparent.disabled = isLocked; } dom.texScaleU.value = currentMatData?.scale?.[0] ?? DEFAULT_TEX_SCALE[0]; dom.texScaleV.value = currentMatData?.scale?.[1] ?? DEFAULT_TEX_SCALE[1]; dom.texOffsetU.value = currentMatData?.offset?.[0] ?? DEFAULT_TEX_OFFSET[0]; dom.texOffsetV.value = currentMatData?.offset?.[1] ?? DEFAULT_TEX_OFFSET[1]; currentTexPath = currentMatData?.ref || ""; const textureItem = document.querySelector(`.textureItem[data-texture-path="${CSS.escape(currentTexPath)}"]`); if (textureItem && !textureItem.classList.contains('selected')) selectTextureItem(textureItem); else if (!textureItem && currentTexPath !== selectedTexturePath) { const noneItem = document.querySelector('.textureItem[data-texture-path=""]'); if (noneItem && !noneItem.classList.contains('selected')) selectTextureItem(noneItem); } show(dom.animationProps); const anim = selectedObjectData.animation; const animType = anim?.type || 'translate'; dom.animType.value = animType; dom.animTargetPosX.value = anim?.targetPosition?.[0]?.toFixed(2) ?? ''; dom.animTargetPosY.value = anim?.targetPosition?.[1]?.toFixed(2) ?? ''; dom.animTargetPosZ.value = anim?.targetPosition?.[2]?.toFixed(2) ?? ''; dom.animTargetRotX.value = THREE.MathUtils.radToDeg(anim?.targetRotation?.[0] ?? 0).toFixed(1); dom.animTargetRotY.value = THREE.MathUtils.radToDeg(anim?.targetRotation?.[1] ?? 0).toFixed(1); dom.animTargetRotZ.value = THREE.MathUtils.radToDeg(anim?.targetRotation?.[2] ?? 0).toFixed(1); dom.animDuration.value = anim?.duration ?? 1.0; dom.animLoop.value = anim?.loop || 'once'; dom.animAutoStart.checked = anim?.autoStart ?? false; dom.animTriggerId.value = anim?.triggerId || ''; updateAnimationUIFields(animType); } else if (isSprite) { show(dom.spriteProps); show(dom.applyTextureContainerSprite,'flex'); dom.selectedFixedRotation.checked = !selectedObjectData.autoRotate; dom.selectedSizeAttenuation.checked = selectedObjectData.sizeAttenuation ?? false; dom.selectedDepthWrite.checked = selectedObjectData.depthWrite ?? false; dom.selectedAlphaTest.value = (selectedObjectData.alphaTest ?? 0.5).toFixed(2); dom.selectedCenterX.value = (selectedObjectData.center?.[0] ?? 0.5).toFixed(1); dom.selectedCenterY.value = (selectedObjectData.center?.[1] ?? 0.0).toFixed(1); dom.selectedTintColor.value = selectedObjectData.tintColor || '#ffffff'; const spriteTexPath = selectedObjectData.materialRef || ""; const spriteTextureItem = document.querySelector(`.textureItem[data-texture-path="${CSS.escape(spriteTexPath)}"]`); if (spriteTextureItem && !spriteTextureItem.classList.contains('selected')) selectTextureItem(spriteTextureItem); else if (!spriteTextureItem && spriteTexPath !== selectedTexturePath) { const noneItem = document.querySelector('.textureItem[data-texture-path=""]'); if (noneItem && !noneItem.classList.contains('selected')) selectTextureItem(noneItem); } } else if (isModelInstance || isEditorGroup) { hide(dom.geometryProps); hide(dom.spriteProps); show(dom.animationProps); show(dom.rotationSection); show(dom.scaleSection); dom.selectedIsCollider.checked = false; dom.selectedIsCollider.disabled = true; const anim = selectedObjectData.animation; const animType = anim?.type || 'translate'; dom.animType.value = animType; dom.animTargetPosX.value = anim?.targetPosition?.[0]?.toFixed(2) ?? ''; dom.animTargetPosY.value = anim?.targetPosition?.[1]?.toFixed(2) ?? ''; dom.animTargetPosZ.value = anim?.targetPosition?.[2]?.toFixed(2) ?? ''; dom.animTargetRotX.value = THREE.MathUtils.radToDeg(anim?.targetRotation?.[0] ?? 0).toFixed(1); dom.animTargetRotY.value = THREE.MathUtils.radToDeg(anim?.targetRotation?.[1] ?? 0).toFixed(1); dom.animTargetRotZ.value = THREE.MathUtils.radToDeg(anim?.targetRotation?.[2] ?? 0).toFixed(1); dom.animDuration.value = anim?.duration ?? 1.0; dom.animLoop.value = anim?.loop || 'once'; dom.animAutoStart.checked = anim?.autoStart ?? false; dom.animTriggerId.value = anim?.triggerId || ''; updateAnimationUIFields(animType); } else if (isMarker && fullUpdate) { show(dom.selectedSpawnerProps); dom.selectedSpawnerProps.innerHTML = '<h4>Spawner/Trigger Properties</h4>'; const updatePropInput = (id, prop) => { const el = document.getElementById(id); if(el) { el.disabled = isLocked; el.addEventListener('change', (e) => { if(selectedObjectData) selectedObjectData[prop] = e.target.value || null; captureState("Update Spawner Prop", { skipUndo: true }); }); el.addEventListener('input', (e) => { if(selectedObjectData) selectedObjectData[prop] = e.target.value || null; }, true); }}; const updatePropSelect = (id, prop, statusMsg) => { const el = document.getElementById(id); if(el) { el.disabled = isLocked; el.addEventListener('change', (e) => { if(selectedObjectData) { selectedObjectData[prop] = e.target.value; if(statusMsg) showStatus(statusMsg); captureState("Update Spawner Prop"); } }); }}; const updatePropCheckbox = (id, prop) => { const el = document.getElementById(id); if(el) { el.disabled = isLocked; el.addEventListener('change', (e) => { if(selectedObjectData) selectedObjectData[prop] = e.target.checked; captureState("Update Spawner Prop"); }); }}; const updatePropNumber = (id, prop) => { const el = document.getElementById(id); if(el) { el.disabled = isLocked; el.addEventListener('change', (e) => { if(selectedObjectData) selectedObjectData[prop] = parseFloat(e.target.value) || 0; captureState("Update Spawner Prop"); }); el.addEventListener('input', (e) => { if(selectedObjectData) selectedObjectData[prop] = parseFloat(e.target.value) || 0; }, true); }}; if (selectedObjectData.type === 'item') { dom.selectedSpawnerProps.innerHTML += `<label for=prop_itemType>Item Type:</label><select id=prop_itemType>${itemTypes.map(t => `<option value="${t}" ${selectedObjectData.itemType === t ? 'selected' : ''}>${t}</option>`).join('')}</select><label for=prop_itemId>Unique Item ID:</label><input type=text id=prop_itemId value="${selectedObjectData.itemId || ''}">`; setTimeout(() => { updatePropSelect('prop_itemType', 'itemType', "Item type updated."); updatePropInput('prop_itemId', 'itemId'); }, 0); } else if (selectedObjectData.type === 'enemy') { dom.selectedSpawnerProps.innerHTML += `<label for=prop_enemyType>Enemy Type:</label><select id=prop_enemyType>${enemyTypes.map(t => `<option value="${t}" ${selectedObjectData.enemyType === t ? 'selected' : ''}>${t}</option>`).join('')}</select>`; setTimeout(() => updatePropSelect('prop_enemyType', 'enemyType', "Enemy type updated."), 0); } else if (selectedObjectData.type === 'level_trigger') { dom.selectedSpawnerProps.innerHTML += `<label for=prop_targetLevel>Target Level File:</label><input type=text id=prop_targetLevel value="${selectedObjectData.targetLevel || ''}"><div><label>Trigger Area:</label><small>Defined by game logic.</small></div>`; setTimeout(() => updatePropInput('prop_targetLevel', 'targetLevel'), 0); } else if (selectedObjectData.type === 'player_start') { dom.selectedSpawnerProps.innerHTML += `<div><label>Facing Direction:</label><small>Set by marker Y rotation.</small></div>`; } else if (selectedObjectData.type === 'door_trigger') { dom.selectedSpawnerProps.innerHTML += `<label for=prop_targetTriggerId>Target Trigger ID:</label><input type=text id=prop_targetTriggerId value="${selectedObjectData.targetTriggerId || ''}" placeholder="e.g., door_1_anim"><label for=prop_requiredKey>Required Key ID (optional):</label><input type=text id=prop_requiredKey value="${selectedObjectData.requiredKey || ''}" placeholder="e.g., keycard_office"><label for=prop_oneShot><input type=checkbox id=prop_oneShot ${selectedObjectData.oneShot ? 'checked' : ''}> One Shot Trigger</label>`; setTimeout(() => { updatePropInput('prop_targetTriggerId', 'targetTriggerId'); updatePropInput('prop_requiredKey', 'requiredKey'); updatePropCheckbox('prop_oneShot', 'oneShot'); }, 0); } else if (selectedObjectData.type === 'proximity_trigger') { dom.selectedSpawnerProps.innerHTML += `<label for=prop_targetTriggerId>Target Trigger ID:</label><input type=text id=prop_targetTriggerId value="${selectedObjectData.targetTriggerId || ''}" placeholder="e.g., trap_door_anim"><label for=prop_radius>Trigger Radius:</label><input type=number step=0.1 min=0.1 id=prop_radius value="${selectedObjectData.radius || 3.0}"><label for=prop_oneShot><input type=checkbox id=prop_oneShot ${selectedObjectData.oneShot ? 'checked' : ''}> One Shot Trigger</label>`; setTimeout(() => { updatePropInput('prop_targetTriggerId', 'targetTriggerId'); updatePropNumber('prop_radius', 'radius'); updatePropCheckbox('prop_oneShot', 'oneShot'); }, 0); } } const elementsToDisableIfLocked = [dom.selectedName, dom.selectedPosX, dom.selectedPosY, dom.selectedPosZ, dom.selectedRotX, dom.selectedRotY, dom.selectedRotZ, dom.selectedScaleX, dom.selectedScaleY, dom.selectedScaleZ, dom.selectedIsCollider, dom.texScaleU, dom.texScaleV, dom.texOffsetU, dom.texOffsetV, dom.selectedIsTransparent, dom.selectedPlaneAlphaTest, dom.applyTexture, dom.applyTextureAll, dom.applyTextureSprite, dom.selectedFixedRotation, dom.selectedSizeAttenuation, dom.selectedDepthWrite, dom.selectedAlphaTest, dom.selectedCenterX, dom.selectedCenterY, dom.selectedTintColor, dom.animType, dom.animTargetPosX, dom.animTargetPosY, dom.animTargetPosZ, dom.animTargetRotX, dom.animTargetRotY, dom.animTargetRotZ, dom.setAnimTarget, dom.animDuration, dom.animLoop, dom.animAutoStart, dom.animTriggerId, dom.previewAnim, dom.clearAnim]; dom.faceSelector.querySelectorAll('button').forEach(btn => btn.disabled = isLocked); elementsToDisableIfLocked.forEach(el => { if(el) el.disabled = isLocked; }); } else { hide(dom.selectedObjectInfo); updateModeInfoUI('translate'); } }
        function updateSelectedDataFromUI(event) { if (selectedMeshes.length !== 1 || !selectedObjectData || !selectedMesh) return; const sourceElementId = event?.target?.id; if (sourceElementId === 'selectedIsLocked') { const currentlyLocked = selectedObjectData.isLocked ?? false; const attemptingToLock = dom.selectedIsLocked.checked; if (attemptingToLock && !currentlyLocked) { const confirmed = confirm("Locking this object will prevent selection and editing.\nTo unlock, you must triple-click the object in the 3D view.\n\nAre you sure you want to lock it?"); if (confirmed) { captureState("Lock Object"); selectedObjectData.isLocked = true; transformControls.detach(); } else { dom.selectedIsLocked.checked = false; return; } } else if (!attemptingToLock && currentlyLocked) { showStatus("Triple-click the object in the 3D view to unlock.", 3000); dom.selectedIsLocked.checked = true; return; } updateSelectedObjectUI(false); setGizmoMode(transformControls.getMode(), false); render(); return; } if (selectedObjectData.isLocked) return; selectedObjectData.name = dom.selectedName.value.trim(); selectedObjectData.isVisible = dom.selectedIsVisible.checked; selectedMesh.visible = selectedObjectData.isVisible; const isGeometry = selectedMesh.userData.isGeometry; const isSprite = selectedMesh.userData.isSprite; const isMarker = selectedMesh.userData.isMarker; const isModelInstance = selectedMesh.userData.isModelInstance; const isEditorGroup = selectedMesh.userData.isEditorGroup; const isPlane = selectedObjectData?.type === 'plane'; const isBox = selectedObjectData?.type === 'box'; const getFloat = (id) => parseFloat(dom[id].value) || 0; const getClamp = (id, min, max, def) => Math.max(min, Math.min(max, parseFloat(dom[id].value) || def)); const getDeg = (id) => THREE.MathUtils.degToRad(getFloat(id)); selectedObjectData.position = [getFloat('selectedPosX'), getFloat('selectedPosY'), getFloat('selectedPosZ')]; selectedMesh.position.fromArray(selectedObjectData.position); if (isSprite) { const isFixedRotation = dom.selectedFixedRotation.checked; selectedObjectData.autoRotate = !isFixedRotation; if (sourceElementId === 'selectedFixedRotation' || (sourceElementId?.startsWith('selectedRot') && isFixedRotation)) { selectedObjectData.rotation = [getDeg('selectedRotX'), getDeg('selectedRotY'), getDeg('selectedRotZ')]; _tempEuler.fromArray(selectedObjectData.rotation); selectedMesh.quaternion.setFromEuler(_tempEuler); } else if (!isFixedRotation) { selectedObjectData.rotation = [0, getDeg('selectedRotY'), 0]; selectedMesh.rotation.y = selectedObjectData.rotation[1]; selectedMesh.rotation.x = 0; selectedMesh.rotation.z = 0; } else { selectedMesh.quaternion.identity(); } } else if (isGeometry || isModelInstance || isEditorGroup) { selectedObjectData.rotation = [getDeg('selectedRotX'), getDeg('selectedRotY'), getDeg('selectedRotZ')]; selectedMesh.rotation.fromArray(selectedObjectData.rotation); selectedMesh.quaternion.setFromEuler(selectedMesh.rotation); } else if (isMarker) { const newRotY = getDeg('selectedRotY'); selectedObjectData.rotationY = newRotY; selectedMesh.rotation.y = newRotY; selectedMesh.rotation.x = 0; selectedMesh.rotation.z = 0; } if (isGeometry || isSprite || isModelInstance || isEditorGroup) { let scaleX = Math.max(MIN_SCALE, getFloat('selectedScaleX') || MIN_SCALE); let scaleY = Math.max(MIN_SCALE, getFloat('selectedScaleY') || MIN_SCALE); let scaleZ = 1.0; if (isGeometry) { scaleZ = isPlane ? (selectedObjectData.scale[2] || MIN_SCALE) : Math.max(MIN_SCALE, getFloat('selectedScaleZ') || MIN_SCALE); } else if (isModelInstance || isEditorGroup) { scaleZ = Math.max(MIN_SCALE, getFloat('selectedScaleZ') || MIN_SCALE); } selectedObjectData.scale = [scaleX, scaleY, scaleZ]; selectedMesh.scale.set(scaleX, scaleY, scaleZ); } else if (isMarker) { selectedObjectData.scale = [1, 1, 1]; selectedMesh.scale.set(1, 1, 1); } if (isGeometry || isModelInstance || isEditorGroup) { const animType = dom.animType.value; const hasTargetPos = dom.animTargetPosX.value.trim() !== ''; const hasTargetRot = dom.animTargetRotX.value.trim() !== ''; if (hasTargetPos || hasTargetRot) { if (!selectedObjectData.animation) selectedObjectData.animation = {}; selectedObjectData.animation.type = animType; if (animType === 'translate' && hasTargetPos) { selectedObjectData.animation.targetPosition = [getFloat('animTargetPosX'), getFloat('animTargetPosY'), getFloat('animTargetPosZ')]; delete selectedObjectData.animation.targetRotation; } else if (animType === 'rotate' && hasTargetRot) { selectedObjectData.animation.targetRotation = [getDeg('animTargetRotX'), getDeg('animTargetRotY'), getDeg('animTargetRotZ')]; delete selectedObjectData.animation.targetPosition; } else { delete selectedObjectData.animation.targetPosition; delete selectedObjectData.animation.targetRotation; } selectedObjectData.animation.duration = Math.max(0.1, getFloat('animDuration') || 1.0); selectedObjectData.animation.loop = dom.animLoop.value; selectedObjectData.animation.autoStart = dom.animAutoStart.checked; selectedObjectData.animation.triggerId = dom.animTriggerId.value.trim() || null; } else selectedObjectData.animation = null; updateAnimationUIFields(animType); } if (isGeometry) { selectedObjectData.isCollider = dom.selectedIsCollider.checked; selectedMesh.userData.isCollider = selectedObjectData.isCollider; const scaleU = getFloat('texScaleU') || 1; const scaleV = getFloat('texScaleV') || 1; const offsetU = getFloat('texOffsetU'); const offsetV = getFloat('texOffsetV'); let targetMaterial; let targetMatData; let materialNeedsUpdate = false; if (isBox && selectedFaceIndex >= 0 && selectedFaceIndex < 6 && selectedObjectData.materials) { targetMatData = selectedObjectData.materials[selectedFaceIndex]; targetMaterial = selectedMesh.material[selectedFaceIndex]; } else if (isPlane) { targetMatData = selectedObjectData.material; targetMaterial = selectedMesh.material; if (sourceElementId === 'selectedIsTransparent' || sourceElementId === 'selectedPlaneAlphaTest') { const isTransparent = dom.selectedIsTransparent.checked; const alphaTest = getClamp('selectedPlaneAlphaTest', 0, 1, 0.1); if (!targetMatData.materialProps) targetMatData.materialProps = {}; targetMatData.materialProps.transparent = isTransparent; targetMatData.materialProps.alphaTest = isTransparent ? alphaTest : 0.0; materialNeedsUpdate = true; dom.selectedPlaneAlphaTest.disabled = !isTransparent; } } if (targetMatData) { targetMatData.scale = [scaleU, scaleV]; targetMatData.offset = [offsetU, offsetV]; } if (targetMaterial) updateMaterialTextureTransform(targetMaterial, [scaleU, scaleV], [offsetU, offsetV]); if (materialNeedsUpdate && isPlane) { if (selectedMesh.material?.map) selectedMesh.material.map.dispose(); if (selectedMesh.material) selectedMesh.material.dispose(); const newMaterial = getMaterial(targetMatData.ref, false, null, targetMatData.materialProps || {}).clone(); newMaterial.wireframe = dom.toggleWireframe.checked; if (newMaterial.map) updateMaterialTextureTransform(newMaterial, targetMatData.scale, targetMatData.offset); selectedMesh.material = newMaterial; } } if (isSprite) { selectedObjectData.sizeAttenuation = dom.selectedSizeAttenuation.checked; selectedObjectData.depthWrite = dom.selectedDepthWrite.checked; selectedObjectData.alphaTest = getClamp('selectedAlphaTest', 0, 1, 0.5); selectedObjectData.center = [getClamp('selectedCenterX', 0, 1, 0.5), getClamp('selectedCenterY', 0, 1, 0.0)]; selectedObjectData.tintColor = dom.selectedTintColor.value || '#ffffff'; selectedMesh.center.fromArray(selectedObjectData.center); if (selectedMesh.material && selectedMesh.material.isSpriteMaterial) { selectedMesh.material.color.set(selectedObjectData.tintColor); selectedMesh.material.sizeAttenuation = selectedObjectData.sizeAttenuation; selectedMesh.material.depthWrite = selectedObjectData.depthWrite; selectedMesh.material.alphaTest = selectedObjectData.alphaTest; selectedMesh.material.transparent = (selectedObjectData.alphaTest < 1.0); selectedMesh.material.needsUpdate = true; } else selectedMesh.material = getMaterial(selectedObjectData.materialRef, true, selectedObjectData); if (sourceElementId === 'selectedFixedRotation' || sourceElementId?.startsWith('selectedRot')) { updateSelectedObjectUI(false); setGizmoMode(transformControls.getMode(), false); } } render(); }
        function updateAnimationUIFields(animType) { dom.animTargetPos.style.display = animType==='translate'?'block':'none'; dom.animTargetRot.style.display = animType==='rotate'?'block':'none'; }
        function setAnimationTarget() { if (selectedMeshes.length !== 1 || !selectedMesh || !selectedObjectData || selectedObjectData.isLocked || (!selectedMesh.userData.isGeometry && !selectedMesh.userData.isModelInstance && !selectedMesh.userData.isEditorGroup)) return; if (!selectedObjectData.animation) selectedObjectData.animation = {}; const animType = dom.animType.value; selectedObjectData.animation.type = animType; const initialPos = selectedMesh.userData.initialPosition; const initialRot = selectedMesh.userData.initialRotation; const currentPos = selectedMesh.position; const currentRot = selectedMesh.rotation; if (animType === 'translate') { const targetPosOffset = currentPos.clone().sub(initialPos); selectedObjectData.animation.targetPosition = targetPosOffset.toArray(); delete selectedObjectData.animation.targetRotation; showStatus("Target position offset set."); } else if (animType === 'rotate') { selectedObjectData.animation.targetRotation = [currentRot.x, currentRot.y, currentRot.z]; delete selectedObjectData.animation.targetPosition; showStatus("Target absolute rotation set."); } selectedObjectData.animation.duration = Math.max(0.1, parseFloat(dom.animDuration.value) || 1.0); selectedObjectData.animation.loop = dom.animLoop.value; selectedObjectData.animation.autoStart = dom.animAutoStart.checked; selectedObjectData.animation.triggerId = dom.animTriggerId.value.trim() || null; updateSelectedObjectUI(); }
        function clearAnimationData() { if (selectedMeshes.length !== 1 || !selectedObjectData || selectedObjectData.isLocked || (!selectedMesh.userData.isGeometry && !selectedMesh.userData.isModelInstance && !selectedMesh.userData.isEditorGroup)) return; if (animationPreviewState.isPlaying && animationPreviewState.mesh === selectedMesh) { resetToInitialTransform(selectedMesh); animationPreviewState.isPlaying = false; transformControls.attach(selectedMesh); } selectedObjectData.animation = null; updateSelectedObjectUI(); showStatus("Animation data cleared."); }
        function resetToInitialTransform(mesh) { if (!mesh || !mesh.userData.initialPosition) return; mesh.position.copy(mesh.userData.initialPosition); if ((mesh.userData.isGeometry || mesh.userData.isModelInstance || mesh.userData.isEditorGroup) && mesh.userData.initialRotation) { mesh.rotation.copy(mesh.userData.initialRotation); mesh.quaternion.setFromEuler(mesh.rotation); } else if (mesh.userData.isMarker) { const objData = findObjectDataById(mesh.userData.dataId); mesh.rotation.y = objData?.rotationY || 0; mesh.rotation.x = 0; mesh.rotation.z = 0; } else if (mesh.isSprite) { const spriteData = findObjectDataById(mesh.userData.dataId); if (spriteData) { if (spriteData.autoRotate) { mesh.quaternion.identity(); } else if (spriteData.rotation) { _tempEuler.fromArray(spriteData.rotation); mesh.quaternion.setFromEuler(_tempEuler); } else { mesh.quaternion.identity(); } } } if ((mesh.userData.isModelInstance || mesh.userData.isEditorGroup) && mesh.userData.initialScale) { mesh.scale.copy(mesh.userData.initialScale); } render(); }
        function previewAnimation() { if (animationPreviewState.isPlaying) { if (animationPreviewState.mesh) { resetToInitialTransform(animationPreviewState.mesh); if(selectedMeshes.includes(animationPreviewState.mesh) && !selectedObjectDatas.find(d=>d.id === animationPreviewState.mesh.userData.dataId)?.isLocked) transformControls.attach(animationPreviewState.mesh); } animationPreviewState.isPlaying = false; showStatus("Preview stopped."); return; } if (selectedMeshes.length !== 1 || !selectedMesh || !selectedObjectData?.animation || selectedObjectData.isLocked || (!selectedMesh.userData.isGeometry && !selectedMesh.userData.isModelInstance && !selectedMesh.userData.isEditorGroup)) { showStatus("Select one unlocked object with valid animation data.", 4000); return; } const anim = selectedObjectData.animation; const mesh = selectedMesh; resetToInitialTransform(mesh); animationPreviewState.mesh = mesh; animationPreviewState.isPlaying = true; animationPreviewState.startTime = performance.now(); animationPreviewState.duration = (anim.duration || 1.0) * 1000; animationPreviewState.type = anim.type; animationPreviewState.loop = anim.loop || 'once'; animationPreviewState.direction = 1; if (anim.type === 'translate' && anim.targetPosition) { animationPreviewState.startPos = mesh.userData.initialPosition.clone(); animationPreviewState.targetPos = mesh.userData.initialPosition.clone().add(new THREE.Vector3().fromArray(anim.targetPosition)); animationPreviewState.startRot = null; animationPreviewState.targetRot = null; } else if (anim.type === 'rotate' && anim.targetRotation) { animationPreviewState.startPos = null; animationPreviewState.targetPos = null; animationPreviewState.startRot = new THREE.Quaternion().setFromEuler(mesh.userData.initialRotation); animationPreviewState.targetRot = new THREE.Quaternion().setFromEuler(new THREE.Euler().fromArray(anim.targetRotation)); } else { showStatus("Invalid animation data for preview.", 4000); animationPreviewState.isPlaying = false; return; } transformControls.detach(); showStatus("Playing animation preview..."); }
        function onKeyDown(event) { const key = event.key.toLowerCase(); const activeElement=document.activeElement,isInputFocused=activeElement&&(activeElement.tagName==='INPUT'||activeElement.tagName==='SELECT'||activeElement.tagName==='TEXTAREA'); isCtrlPressed = event.ctrlKey || event.metaKey; isShiftPressed = event.shiftKey; if((isInputFocused || dom.modelMenu.style.display === 'flex' || isTerrainEditing) && key !=='escape') return; let targetMode = null; const exploreKeys = ['w', 'a', 's', 'd', 'arrowup', 'arrowdown', 'arrowleft', 'arrowright']; if (exploreKeys.includes(key)) { event.preventDefault(); keysPressed[key] = true; enterExploreMode(); return; } switch (key) { case 'm': targetMode='translate'; break; case 'o': targetMode='rotate'; break; case 'p': targetMode='scale'; break; case ' ': event.preventDefault(); if (!isExploreModeActive && selectedMeshes.length > 0) cycleTransformMode(['rotate','scale']); return; case 'q': if (!isExploreModeActive && transformControls.object && !selectedObjectDatas.some(d=>d?.isLocked)) { transformControls.setSpace(transformControls.space==="local"?"world":"local"); showStatus(`Gizmo space: ${transformControls.space}`, 1500); render(); } break; case 'delete': case 'backspace': if (!isExploreModeActive && !isInputFocused && !isPlacingDecal && !isTerrainEditing && selectedMeshes.length > 0 && !selectedObjectDatas.some(d=>d?.isLocked)) { deleteSelected(); } break; case 'd': if (!isExploreModeActive && isCtrlPressed && !isPlacingDecal && !isTerrainEditing && selectedMeshes.length > 0) { event.preventDefault(); cloneSelected(); } break; case 'g': if (!isExploreModeActive && isCtrlPressed && !isShiftPressed && !isPlacingDecal && !isTerrainEditing && selectedMeshes.length >= 2) { event.preventDefault(); groupSelection(); } else if (!isExploreModeActive && isCtrlPressed && isShiftPressed && !isPlacingDecal && !isTerrainEditing && selectedMeshes.length === 1 && selectedMesh?.userData.isEditorGroup) { event.preventDefault(); ungroupSelection(); } break; case 'escape': if (isExploreModeActive) { keysPressed={}; exitExploreMode(); } else if (dom.modelMenu.style.display === 'flex') hideModelMenu(); else if (isPlacingDecal) toggleDecalMode(); else if (isTerrainEditing) toggleTerrainEditing(); else deselectObject(); break; case 'z': if(isCtrlPressed){event.preventDefault();undo();} break; case 'y': if(isCtrlPressed){event.preventDefault();redo();} break; default: return; } if (!isExploreModeActive && targetMode) { event.preventDefault(); setGizmoMode(targetMode, true); } }
        function onKeyUp(event) { const key = event.key.toLowerCase(); keysPressed[key] = false; isCtrlPressed = event.ctrlKey || event.metaKey; isShiftPressed = event.shiftKey; const exploreKeys = ['w', 'a', 's', 'd', 'arrowup', 'arrowdown', 'arrowleft', 'arrowright']; if (exploreKeys.includes(key)) { exitExploreMode(); } switch (key) { case 'shift': if (transformControls.getMode()==='scale') { const snap=dom.snapToGrid.checked; transformControls.setScaleSnap(snap?SNAP_SCALE:null); if (!transformControls.dragging && !selectedObjectDatas.some(d=>d?.isLocked)) onObjectTransform(); } break; } }

        function groupSelection() { if (selectedMeshes.length < 2 || selectedObjectDatas.some(d => d?.isLocked || d?.parentId)) { showStatus("Select 2 or more un-grouped, unlocked objects to group.", 3000); return; } captureState("Group Objects"); const groupData = { id: THREE.MathUtils.generateUUID(), type: 'group', name: "New Group", isVisible: true, isLocked: false, position: [0,0,0], rotation: [0,0,0], scale: [1,1,1], childrenIds: [], parentId: null, userData: {} }; const group = new THREE.Group(); group.uuid = groupData.id; _box.makeEmpty(); selectedMeshes.forEach(mesh => { _box.expandByObject(mesh); }); _box.getCenter(group.position); groupData.position = group.position.toArray(); group.userData = { dataId: groupData.id, isEditorGroup: true, name: groupData.name, initialPosition: group.position.clone(), initialRotation: group.rotation.clone(), initialScale: group.scale.clone(), }; scene.add(group); _invMat.copy(group.matrixWorld).invert(); selectedMeshes.forEach((mesh, index) => { const data = selectedObjectDatas[index]; data.parentId = groupData.id; groupData.childrenIds.push(data.id); scene.attach(mesh); mesh.applyMatrix4(_invMat); group.attach(mesh); data.position = mesh.position.toArray(); data.rotation = mesh.rotation.toArray().slice(0,3); data.scale = mesh.scale.toArray(); }); levelData.groups.push(groupData); deselectObject(false); selectObject(group, groupData); showStatus(`Grouped ${groupData.childrenIds.length} objects.`); render(); }
        function ungroupSelection() { if (selectedMeshes.length !== 1 || !selectedMesh?.userData.isEditorGroup || selectedObjectData?.isLocked) { showStatus("Select a single, unlocked group to ungroup.", 3000); return; } captureState("Ungroup Objects"); const group = selectedMesh; const groupData = selectedObjectData; const childrenToSelect = []; const childrenData = []; groupData.childrenIds.forEach(childId => { const childMesh = scene.getObjectByProperty('uuid', childId); const childData = findObjectDataById(childId); if (childMesh && childData) { childData.parentId = null; group.getWorldPosition(childMesh.position); group.getWorldQuaternion(childMesh.quaternion); group.getWorldScale(childMesh.scale); scene.attach(childMesh); childData.position = childMesh.position.toArray(); childData.rotation = childMesh.rotation.toArray().slice(0,3); childData.scale = childMesh.scale.toArray(); childrenToSelect.push(childMesh); childrenData.push(childData); } }); const groupIndex = levelData.groups.findIndex(g => g.id === groupData.id); if (groupIndex > -1) levelData.groups.splice(groupIndex, 1); scene.remove(group); deselectObject(false); if (childrenToSelect.length > 0) { selectedMeshes = childrenToSelect; selectedObjectDatas = childrenData; selectedMesh = selectedMeshes[selectedMeshes.length - 1]; selectedObjectData = selectedObjectDatas[selectedMeshes.length - 1]; transformControls.attach(selectedMesh); outlinePass.selectedObjects = selectedMeshes; updateSelectedObjectUI(); } showStatus(`Ungrouped ${childrenToSelect.length} objects.`); render(); }

        function exportLevelData() { const exportData = { levelName: "Custom Level", textures: {}, modelDefinitions: {}, settings: { skybox: null, waterLevel: null }, geometry: [], prefabs: [], spawners: [], sprites: [], modelInstances: [], groups: [], terrain: null }; const usedTextures = new Set(); const usedModelNames = new Set(); levelData.geometry.forEach(geo => { const copy = deepClone(geo); if (copy.type === 'box' && copy.materials) copy.materials.forEach(mat => { if (mat?.ref) usedTextures.add(mat.ref); }); else if (copy.material?.ref) usedTextures.add(copy.material.ref); exportData.geometry.push(copy); }); levelData.sprites.forEach(sprite => { const copy = deepClone(sprite); if (copy.materialRef) usedTextures.add(copy.materialRef); exportData.sprites.push(copy); }); levelData.prefabs.forEach(prefab => exportData.prefabs.push(deepClone(prefab))); levelData.spawners.forEach(spawner => exportData.spawners.push(deepClone(spawner))); levelData.modelInstances.forEach(instanceData => { exportData.modelInstances.push(deepClone(instanceData)); usedModelNames.add(instanceData.modelName); const definition = loadedModelDefinitions[instanceData.modelName]; if (definition && definition.textures) Object.values(definition.textures).forEach(textureFilename => { if (textureFilename) usedTextures.add(IMG_PREFIX + textureFilename); }); }); levelData.groups.forEach(group => exportData.groups.push(deepClone(group))); if (levelData.terrain && terrainMesh) { levelData.terrain.yPositions = getYPositions(terrainMesh.geometry); levelData.terrain.textureWeights1 = Array.from(terrainMesh.geometry.attributes.textureWeights1.array); levelData.terrain.textureWeights2 = Array.from(terrainMesh.geometry.attributes.textureWeights2.array); exportData.terrain = { size: levelData.terrain.size, segments: levelData.terrain.segments, yPositions: levelData.terrain.yPositions, textureWeights1: levelData.terrain.textureWeights1, textureWeights2: levelData.terrain.textureWeights2, baseTextureRef: null, baseTextureScale: levelData.terrain.baseTextureScale || DEFAULT_TERRAIN_BASE_TEX_SCALE, paintTextureRefs: [null, null, null, null, null], paintTextureScales: levelData.terrain.paintTextureScales || Array(5).fill(null).map(() => [...DEFAULT_TERRAIN_PAINT_TEX_SCALE]) }; if (terrainMesh.userData.baseTexturePath) { usedTextures.add(terrainMesh.userData.baseTexturePath); exportData.terrain.baseTextureRef = terrainMesh.userData.baseTexturePath; } if (terrainMesh.userData.paintTextures) { terrainMesh.userData.paintTextures.forEach((path, i) => { if (path) { usedTextures.add(path); exportData.terrain.paintTextureRefs[i] = path; } }); } } if (levelData.settings?.skybox) usedTextures.add(levelData.settings.skybox); if (waterMesh) usedTextures.add(IMG_PREFIX + 'water.png'); usedModelNames.forEach(modelName => { if (loadedModelDefinitions[modelName]) exportData.modelDefinitions[modelName] = deepClone(loadedModelDefinitions[modelName]); }); let textureCounter = 1; const texturePathToKeyMap = {}; usedTextures.forEach(path => { if (path){ const key = `tex${textureCounter.toString().padStart(2, '0')}`; exportData.textures[key] = path; texturePathToKeyMap[path] = key; textureCounter++; } }); const resolveRef = (refPath) => texturePathToKeyMap[refPath] || null; exportData.geometry.forEach(geo => { if (geo.type === 'box' && geo.materials) geo.materials.forEach(mat => { if (mat) mat.ref = resolveRef(mat.ref); }); else if (geo.material) geo.material.ref = resolveRef(geo.material.ref); }); exportData.sprites.forEach(sprite => sprite.materialRef = resolveRef(sprite.materialRef)); if (exportData.terrain) { exportData.terrain.baseTextureRef = resolveRef(exportData.terrain.baseTextureRef); exportData.terrain.paintTextureRefs = exportData.terrain.paintTextureRefs.map(ref => resolveRef(ref)); } exportData.settings.skybox = resolveRef(levelData.settings?.skybox); exportData.settings.waterLevel = levelData.settings?.waterLevel; try { const jsonString = JSON.stringify(exportData, null, 2); const blob = new Blob([jsonString], { type: 'application/json' }); const link = document.createElement('a'); link.href = URL.createObjectURL(blob); const fileName = `${exportData.levelName.replace(/\s+/g, '_') || 'level'}_export.json`; link.download = fileName; link.click(); URL.revokeObjectURL(link.href); showStatus("Map exported successfully."); } catch (error) { console.error("Error during JSON export:", error); showStatus("Error exporting map!", 5000); } }
        function loadLevelDataFromFile(event) { const file = event.target.files[0]; if (!file) return; const reader = new FileReader(); reader.onload = async (e) => { try { const jsonData = JSON.parse(e.target.result); await clearScene(false); undoStack = []; redoStack = []; if (!jsonData || typeof jsonData !== 'object') throw new Error("Invalid JSON structure."); levelData = { geometry: [], prefabs: [], spawners: [], sprites: [], modelInstances: [], groups: [], terrain: null, settings: { skybox: null, waterLevel: null } }; levelData.geometry = jsonData.geometry || []; levelData.prefabs = jsonData.prefabs || []; levelData.spawners = jsonData.spawners || []; levelData.sprites = jsonData.sprites || []; levelData.modelInstances = jsonData.modelInstances || []; levelData.groups = jsonData.groups || []; levelData.terrain = jsonData.terrain || null; levelData.settings = jsonData.settings || { skybox: null, waterLevel: null }; if (jsonData.textures) levelData.textures = jsonData.textures; if (jsonData.modelDefinitions) levelData.modelDefinitions = jsonData.modelDefinitions; await rebuildSceneFromData(); deselectObject(false); render(); showStatus("Map loaded successfully."); captureState("Load Map"); } catch (error) { console.error("Error loading map file:", error); alert(`Failed to load map file:\n${error.message}`); showStatus("Error loading map!", 5000); await clearScene(true); } finally { event.target.value = null; updateHistoryButtons(); } }; reader.onerror = (e) => { console.error("Error reading file:", e); alert("Failed to read map file."); showStatus("Error reading file!", 5000); event.target.value = null; }; reader.readAsText(file); }
        async function rebuildSceneFromData() {
            const textureMap = levelData.textures || {};
            const embeddedModelDefinitions = levelData.modelDefinitions || {};
            for (const modelName in embeddedModelDefinitions) { if (!loadedModelDefinitions[modelName]) { loadedModelDefinitions[modelName] = embeddedModelDefinitions[modelName]; } }
            const resolveMaterialRef = (refKey) => refKey ? (textureMap[refKey] || refKey) : null;
            if (levelData.terrain) { const terrainData = levelData.terrain; const geometry = new THREE.PlaneGeometry(terrainData.size[0], terrainData.size[1], terrainData.segments[0], terrainData.segments[1]); geometry.rotateX(-Math.PI / 2); if (!applyYPositions(geometry, terrainData.yPositions)) console.warn("Failed to apply Y positions to loaded terrain."); const baseTexturePath = resolveMaterialRef(terrainData.baseTextureRef); const paintTexturePaths = (terrainData.paintTextureRefs || []).map(ref => resolveMaterialRef(ref)); const baseTextureScale = terrainData.baseTextureScale || DEFAULT_TERRAIN_BASE_TEX_SCALE; const paintTextureScales = terrainData.paintTextureScales || Array(5).fill(null).map(() => [...DEFAULT_TERRAIN_PAINT_TEX_SCALE]); const material = createTerrainMaterial(); const textureWeights1 = new Float32Array(terrainData.textureWeights1 || []); const textureWeights2 = new Float32Array(terrainData.textureWeights2 || []); geometry.setAttribute('textureWeights1', new THREE.BufferAttribute(textureWeights1, 4)); geometry.setAttribute('textureWeights2', new THREE.BufferAttribute(textureWeights2, 2)); terrainMesh = new THREE.Mesh(geometry, material); terrainMesh.userData = { isTerrain: true, size: terrainData.size, segments: terrainData.segments, baseTexturePath: baseTexturePath, baseTextureScale: baseTextureScale, paintTextures: paintTexturePaths, paintTextureScales: paintTextureScales }; material.uniforms.uBaseTexture.value = getTexture(baseTexturePath); material.uniforms.uHasBaseTexture.value = !!baseTexturePath; material.uniforms.uBaseTexScale.value.fromArray(baseTextureScale); paintTexturePaths.forEach((path, i) => { if (path) { material.uniforms[`uPaintTexture${i}`].value = getTexture(path); material.uniforms[`uHasPaintTexture${i}`].value = true; material.uniforms[`uPaintTexScale${i}`].value.fromArray(paintTextureScales[i]); } }); scene.add(terrainMesh); populateTerrainBaseTextureSelect(); if (baseTexturePath && dom.terrainBaseTextureSelect) dom.terrainBaseTextureSelect.value = baseTexturePath; updateTerrainPaintSlotsUI(); } else { terrainMesh = null; }
            const idToMeshMap = {}; const objectsToParent = [];
            for (const geoData of levelData.geometry) { if (geoData.type === 'box' && geoData.materials) geoData.materials.forEach(mat => { if (mat) mat.ref = resolveMaterialRef(mat.ref); }); else if (geoData.material) { geoData.material.ref = resolveMaterialRef(geoData.material.ref); if (!geoData.material.materialProps) geoData.material.materialProps = { transparent: false, alphaTest: 0.0 }; } if (geoData.isVisible === undefined) geoData.isVisible = true; if (geoData.isLocked === undefined) geoData.isLocked = false; const mesh = createMeshFromData(geoData); if (mesh) { idToMeshMap[geoData.id] = mesh; if (!geoData.parentId) scene.add(mesh); else objectsToParent.push(geoData); } }
            for (const prefabData of levelData.prefabs) { if (prefabData.isVisible === undefined) prefabData.isVisible = true; if (prefabData.isLocked === undefined) prefabData.isLocked = false; let prefabObject = createMarkerMesh(prefabData); if (prefabObject) { idToMeshMap[prefabData.id] = prefabObject; if (!prefabData.parentId) scene.add(prefabObject); else objectsToParent.push(prefabData); } }
            for (const spawnerData of levelData.spawners) { if (spawnerData.isVisible === undefined) spawnerData.isVisible = true; if (spawnerData.isLocked === undefined) spawnerData.isLocked = false; const marker = createMarkerMesh(spawnerData); if (marker) { idToMeshMap[spawnerData.id] = marker; if (!spawnerData.parentId) scene.add(marker); else objectsToParent.push(spawnerData); } }
            for (const spriteData of levelData.sprites) { spriteData.materialRef = resolveMaterialRef(spriteData.materialRef); if (spriteData.autoRotate === undefined) spriteData.autoRotate = true; if (spriteData.isVisible === undefined) spriteData.isVisible = true; if (spriteData.isLocked === undefined) spriteData.isLocked = false; const sprite = createSpriteMesh(spriteData); if (sprite) { idToMeshMap[spriteData.id] = sprite; if (!spriteData.parentId) scene.add(sprite); else objectsToParent.push(spriteData); } }
            if (levelData.modelInstances.length > 0) { for (const instanceData of levelData.modelInstances) { if (instanceData.isVisible === undefined) instanceData.isVisible = true; if (instanceData.isLocked === undefined) instanceData.isLocked = false; const definition = await loadModelDefinition(instanceData.modelName); if (definition) { const modelGroup = createModelGroup(instanceData, definition); if (modelGroup) { idToMeshMap[instanceData.id] = modelGroup; if (!instanceData.parentId) scene.add(modelGroup); else objectsToParent.push(instanceData); } else { console.warn(`Failed to recreate model instance on load: ${instanceData.modelName}`); } } else { console.warn(`Model definition ${instanceData.modelName} not found during load.`); } } }
            for (const groupData of levelData.groups) { const groupMesh = createEditorGroup(groupData); if (groupMesh) { idToMeshMap[groupData.id] = groupMesh; if (!groupData.parentId) scene.add(groupMesh); else objectsToParent.push(groupData); } }
            objectsToParent.forEach(data => { const childMesh = idToMeshMap[data.id]; const parentMesh = idToMeshMap[data.parentId]; if (childMesh && parentMesh) { parentMesh.attach(childMesh); } else { console.warn("Could not find child or parent mesh for parenting on load:", data.id, data.parentId); if (childMesh) scene.add(childMesh); } });
            const skyboxPath = resolveMaterialRef(levelData.settings?.skybox); levelData.settings.skybox = skyboxPath; populateSkyboxSelect(); if (skyboxPath) applySkybox(); else scene.background = DEFAULT_BG_COLOR.clone();
            if (levelData.settings?.waterLevel !== null && levelData.settings?.waterLevel !== undefined && terrainMesh) { dom.waterLevelInput.value = levelData.settings.waterLevel; addOrUpdateWaterPlane(); } else { removeWaterPlane(); if (dom.waterLevelInput) dom.waterLevelInput.value = ''; }
        }
        async function clearScene(captureUndo = true) { if(captureUndo) captureState("Clear Scene"); deselectObject(false); clearTerrain(false); removeWaterPlane(); scene.background = DEFAULT_BG_COLOR.clone(); const objectsToRemove = scene.children.filter(child => child !== gridHelper && child !== brushHelper && !child.isLight && !child.isCamera && child !== transformControls); objectsToRemove.forEach(obj => { const dispose = (o) => { if (o.geometry) o.geometry.dispose(); if (o.material) { if (Array.isArray(o.material)) o.material.forEach(mat => { if (mat?.map && !mat.userData.mapCloned) mat.map.dispose(); if(mat) mat.dispose(); }); else { if (o.material instanceof THREE.ShaderMaterial) { Object.values(o.material.uniforms).forEach(u => u.value?.dispose()); } else if (o.material.map && !o.material.userData.mapCloned) o.material.map.dispose(); if (o.material.dispose) o.material.dispose(); } } }; if (obj.isGroup) { obj.traverse(child => { if (child.isMesh || child.isSprite) dispose(child); }); } else { dispose(obj); } scene.remove(obj); }); levelData = { geometry: [], prefabs: [], spawners: [], sprites: [], modelInstances: [], groups: [], terrain: null, settings: { skybox: null, waterLevel: null } }; loadedTextures = {}; loadedMaterials = {}; loadedSpriteMaterials = {}; dom.toggleWireframe.checked = localStorage.getItem('editor_wireframe') === 'true'; dom.toggleGrid.checked = localStorage.getItem('editor_grid') !== 'false'; gridHelper.visible = dom.toggleGrid.checked; isTerrainEditing = false; if (dom.terrainEditingTools) dom.terrainEditingTools.style.display = 'none'; if (brushHelper) brushHelper.visible = false; activeTerrainTool = 'raise'; activePaintSlotIndex = -1; activePaintTextureIndex = 0; populateTextureUI(); populateTerrainBaseTextureSelect(); populateSkyboxSelect(); await Promise.resolve(); render(); if(captureUndo) showStatus("Scene cleared."); }
        function showStatus(message, duration=STATUS_MESSAGE_DURATION) { if (!dom.statusBar) return; dom.statusBar.textContent = message; if (statusTimeout) clearTimeout(statusTimeout); statusTimeout = setTimeout(() => { if (dom.statusBar.textContent === message) dom.statusBar.textContent = '-'; statusTimeout = null; }, duration); }
        function animate() { requestAnimationFrame(animate); const delta = clock.getDelta(); if (isExploreModeActive) { updateExploreModeCamera(delta); } else { orbitControls.update(); } if (animationPreviewState.isPlaying && animationPreviewState.mesh) { const now = performance.now(); let elapsed = (now - animationPreviewState.startTime); let progress = 0; let finished = false; if (animationPreviewState.loop === 'once') { progress = Math.min(elapsed / animationPreviewState.duration, 1.0); if (progress >= 1.0) finished = true; } else if (animationPreviewState.loop === 'loop') { elapsed = elapsed % animationPreviewState.duration; progress = elapsed / animationPreviewState.duration; } else if (animationPreviewState.loop === 'pingpong') { const cycleTime = animationPreviewState.duration * 2; elapsed = elapsed % cycleTime; if (elapsed > animationPreviewState.duration) { progress = 1.0 - ((elapsed - animationPreviewState.duration) / animationPreviewState.duration); animationPreviewState.direction = -1; } else { progress = elapsed / animationPreviewState.duration; animationPreviewState.direction = 1; } } const easedProgress = 0.5 - 0.5 * Math.cos(progress * Math.PI); const mesh = animationPreviewState.mesh; if (animationPreviewState.type === 'translate' && animationPreviewState.startPos && animationPreviewState.targetPos) mesh.position.lerpVectors(animationPreviewState.startPos, animationPreviewState.targetPos, easedProgress); else if (animationPreviewState.type === 'rotate' && animationPreviewState.startRot && animationPreviewState.targetRot) { THREE.Quaternion.slerp(animationPreviewState.startRot, animationPreviewState.targetRot, mesh.quaternion, easedProgress); mesh.rotation.setFromQuaternion(mesh.quaternion, mesh.rotation.order); } if (finished) { animationPreviewState.isPlaying = false; resetToInitialTransform(animationPreviewState.mesh); if(selectedMeshes.includes(animationPreviewState.mesh) && !selectedObjectDatas.find(d=>d.id === animationPreviewState.mesh.userData.dataId)?.isLocked) transformControls.attach(animationPreviewState.mesh); showStatus("Preview finished."); } } render(delta); }
        function render(delta) { scene.traverse(obj => { if (obj.isSprite && obj.userData.isSprite && camera) { const spriteData = findObjectDataById(obj.userData.dataId); if (!spriteData) return; const autoRotate = spriteData.autoRotate ?? true; if (autoRotate) { camera.getWorldPosition(_camPos); obj.getWorldPosition(_spritePos); _targetDir.set(_camPos.x - _spritePos.x, 0, _camPos.z - _spritePos.z).normalize(); let angleY = Math.atan2(_targetDir.x, _targetDir.z); _spriteQuaternion.setFromAxisAngle(_yAxis, angleY); if (!obj.quaternion.equals(_spriteQuaternion)) obj.quaternion.copy(_spriteQuaternion); } else { if (spriteData.rotation && Array.isArray(spriteData.rotation)) { _tempEuler.fromArray(spriteData.rotation); _spriteQuaternion.setFromEuler(_tempEuler); if (!obj.quaternion.equals(_spriteQuaternion)) obj.quaternion.copy(_spriteQuaternion); } else { if (!obj.quaternion.equals(_identityQuaternion)) obj.quaternion.identity(); } } } }); if (composer) composer.render(delta); else renderer.render(scene, camera); }
        function onWindowResize() { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); composer.setSize(window.innerWidth, window.innerHeight); outlinePass.resolution.set(window.innerWidth, window.innerHeight); render(); }
        init();
    </script>
</body>
</html>