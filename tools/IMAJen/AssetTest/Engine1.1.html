<!DOCTYPE html>
<html lang=en>
<head>
    <meta charset=utf8>
    <title>Map Editor Rebuild v3.4.2</title>
    <meta name=viewport content=width=device-width,initial-scale=1>
    <style>
        :root {
            --bg-color-darkest:#1e1e1e;--bg-color-dark:#252526;--bg-color-medium:#333;--bg-color-light:#3c3c3c;--border-color:#4a4a4a;--text-color-primary:#d4d4d4;--text-color-secondary:#ccc;--text-color-muted:#999;--accent-color-primary:#007acc;--accent-color-secondary:#6c757d;--accent-color-danger:#cd3131;--selection-color:#094771;--highlight-color:#00aaff;--font-size-base:12px;--font-size-small:11px;--font-size-header:14px;--border-radius:3px;--padding-base:8px;--padding-small:4px
        }
        body { margin:0; overflow:hidden; font-family:Segoe UI, Frutiger, Frutiger Linotype, Dejavu Sans, Helvetica Neue, Arial, sans-serif; background-color:var(--bg-color-darkest); color:var(--text-color-primary); font-size:var(--font-size-base) }
        canvas { display:block }
        #ui { position:absolute; top:0; left:0; background:var(--bg-color-dark); padding:0; border-right:1px solid var(--border-color); color:var(--text-color-primary); z-index:10; width:260px; height:100vh; display:flex; flex-direction:column; box-shadow:2px 0 5px rgba(0,0,0,.3) }
        #ui-header { background-color:var(--bg-color-light); padding:var(--padding-small) var(--padding-base); border-bottom:1px solid var(--border-color); text-align:center; font-size:var(--font-size-header); font-weight:bold; flex-shrink:0; user-select:none }
        #ui-content { overflow-y:auto; flex-grow:1; padding:var(--padding-base); }
        #ui-content::-webkit-scrollbar { width:8px; }
        #ui-content::-webkit-scrollbar-track { background:var(--bg-color-dark); }
        #ui-content::-webkit-scrollbar-thumb { background:var(--bg-color-light); border-radius:4px; }
        #ui-content::-webkit-scrollbar-thumb:hover { background:var(--border-color); }
        #ui h3 { font-size:var(--font-size-base); font-weight:bold; margin:12px 0 8px; padding-bottom:4px; border-bottom:1px solid var(--border-color); color:var(--text-color-secondary); }
        #ui h3:first-child { margin-top:0; }
        #ui h4 { font-size:var(--font-size-small); font-weight:bold; margin:10px 0 5px; color:var(--text-color-muted); text-transform:uppercase; }
        #ui button { display:block; margin:5px 0; width:100%; padding:6px var(--padding-base); border:1px solid var(--border-color); border-radius:var(--border-radius); font-size:var(--font-size-base); cursor:pointer; background-color:var(--bg-color-light); color:var(--text-color-primary); transition:background-color 0.15s, border-color 0.15s; box-sizing:border-box; text-align:center; }
        #ui button:hover:not(:disabled) { background-color:var(--border-color); border-color:#5a5a5a; }
        #ui button:active:not(:disabled) { background-color:var(--selection-color); border-color:var(--accent-color-primary); }
        #ui button.primary { background-color:var(--accent-color-primary); border-color:var(--accent-color-primary); color:white; }
        #ui button.primary:hover:not(:disabled) { background-color:#005a9e; border-color:#005a9e; }
        #ui button.secondary { background-color:var(--accent-color-secondary); border-color:var(--accent-color-secondary); color:white; }
        #ui button.secondary:hover:not(:disabled) { background-color:#5a6268; border-color:#545b62; }
        #ui button.danger { background-color:var(--accent-color-danger); border-color:var(--accent-color-danger); color:white; }
        #ui button.danger:hover:not(:disabled) { background-color:#a71d1d; border-color:#a71d1d; }
        #ui button:disabled { background-color:var(--bg-color-medium); border-color:var(--border-color); color:var(--text-color-muted); cursor:not-allowed; opacity:0.6; }
        #ui .section { margin-bottom: 12px; }
        #ui label { display: block; margin: 8px 0 3px; font-size: var(--font-size-small); color: var(--text-color-muted); }
        #ui input[type=checkbox] { margin-right: 5px; vertical-align: middle; accent-color: var(--accent-color-primary); }
        #ui label input[type=checkbox] { margin-top: -2px; }
        #ui input[type="text"], #ui input[type="number"], #ui input[type=color], #ui select { width: 100%; padding: 4px 6px; margin-bottom: 6px; background: var(--bg-color-darkest); color: var(--text-color-primary); border: 1px solid var(--border-color); border-radius: var(--border-radius); font-size: var(--font-size-base); box-sizing: border-box; line-height: 1.4; }
        #ui input:focus, #ui select:focus { outline: none; border-color: var(--accent-color-primary); box-shadow: 0 0 0 1px var(--accent-color-primary); }
        #ui input:disabled, #ui select:disabled { background-color: var(--bg-color-medium); color: var(--text-color-muted); cursor: not-allowed; opacity: 0.7; }
        #ui input[type=color] { height: 26px; padding: 2px; }

        #ui select { padding-right: 20px; appearance: none; background: url('data:image/svg+xml;charset=US-ASCII,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 292.4 292.4%22%3E%3Cpath fill=%22%23ccc%22 d=%22M287 69.4a17.6 17.6 0 00-13-5.4H18.4c-5 0-9.3 1.8-12.9 5.4A17.6 17.6 0 000 82.2c0 5 1.8 9.3 5.4 12.9l128 127.9c3.6 3.6 7.8 5.4 12.8 5.4s9.2-1.8 12.8-5.4L287 95c3.5-3.5 5.4-7.8 5.4-12.8 0-5-1.9-9.2-5.4-12.8z%22/%3E%3C/svg%3E') no-repeat right 6px top 50%/8px auto var(--bg-color-darkest); }
        #textureGrid { display: grid; grid-template-columns: repeat(auto-fill, minmax(45px, 1fr)); gap: 4px; margin-top: 5px; max-height: 145px; overflow-y: auto; background: var(--bg-color-darkest); padding: var(--padding-small); border-radius: var(--border-radius); border: 1px solid var(--border-color); }
        .textureItem { width: 45px; height: 45px; background-color: var(--bg-color-medium); border: 1px solid transparent; border-radius: var(--border-radius); cursor: pointer; background-size: cover; background-position: center; position: relative; display: inline-flex; justify-content: center; align-items: center; overflow: hidden; transition: border-color 0.15s; }
        .textureItem:hover { border-color: var(--text-color-muted); }
        .textureItem.selected { border-color: var(--highlight-color); box-shadow: 0 0 0 1px var(--highlight-color) inset; }
        .textureItem[data-texture-path=""] { background: var(--bg-color-medium) none !important; border: 1px dashed var(--border-color); }
        .textureItem[data-texture-path=""]::after { content: "None"; color: var(--text-color-muted); font-size: 10px; text-align: center; }
        #selectedObjectInfo { margin-top: 15px; border-top: 1px solid var(--border-color); padding-top: 10px; font-size: var(--font-size-base); }
        #selectedObjectInfo div { margin-bottom: 4px; }
        .coord-input-group, .half-input-group { display: flex; gap: 4px; align-items: center; }
        .coord-label { display: inline-block; width: 10px; text-align: center; color: var(--text-color-muted); font-size: var(--font-size-small); }
        .coord-input, .half-input { flex: 1; min-width: 0; margin: 0; }
        .prop-section { margin-top: 10px; padding-top: 10px; border-top: 1px solid var(--bg-color-light); }
        #currentModeInfo { margin-top: 5px; font-style: italic; color: var(--text-color-muted); font-size: var(--font-size-small); text-align: center; }
        #statusBar { padding: var(--padding-small) var(--padding-base); background-color: var(--bg-color-light); border-top: 1px solid var(--border-color); font-size: var(--font-size-small); color: var(--text-color-muted); min-height: 1.5em; line-height: 1.5em; flex-shrink: 0; user-select: none; }
        .mode-button-group { display: flex; gap: 4px; margin-bottom: 10px; }
        .mode-button-group button { flex: 1; padding: 5px; margin: 0; }
        .mode-button-group button.active, #faceSelector button.active { background-color: var(--selection-color); border-color: var(--accent-color-primary); color: var(--text-color-primary); box-shadow: inset 0 0 0 1px var(--accent-color-primary); }
        #instructionsPanel { position: fixed; top: 5px; right: 5px; width: 200px; max-height: calc(100vh - 10px); background: rgba(37, 37, 38, 0.85); padding: 10px; border-radius: var(--border-radius); border: 1px solid var(--border-color); color: var(--text-color-secondary); z-index: 9; font-size: var(--font-size-small); overflow-y: auto; box-shadow: 0 2px 5px rgba(0,0,0,.3); }
        #instructionsPanel h3 { margin-top: 0; text-align: center; font-size: var(--font-size-base); border-bottom: 1px solid var(--border-color); padding-bottom: 4px; margin-bottom: 8px; color: var(--text-color-primary); }
        #instructionsPanel ul { list-style: none; padding: 0; margin: 0 0 10px; }
        #instructionsPanel li { margin-bottom: 4px; }
        #instructionsPanel kbd { background-color: var(--bg-color-light); border-radius: 2px; padding: 1px 3px; border: 1px solid var(--border-color); font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace; font-size: 0.95em; margin-right: 4px; color: var(--text-color-primary); }
        #animationProps .coord-input-group { margin-bottom: 6px; }
        #animationProps label, #textureProps label { margin-top: 6px; margin-bottom: 2px; font-weight: normal; font-size: var(--font-size-small); color: var(--text-color-muted); }
        #animationProps select { margin-bottom: 10px; }
        #animationTargetFields { margin-top: 5px; }
        #textureProps .half-input-group { margin-bottom: 4px; }
        #faceSelector { display: grid; grid-template-columns: repeat(3, 1fr); gap: 4px; margin-bottom: 10px; }
        #faceSelector label { grid-column: 1 / -1; margin-bottom: 2px;}
        #faceSelector button { padding: 3px; font-size: 10px; margin: 0; line-height: 1.2; }
        small.unit { margin-left: 3px; font-size: 0.9em; color: var(--text-color-muted); }
        #applyTextureContainer, #applyTextureContainerSprite { display: flex; gap: 5px; margin-top: 5px; }
        #applyTextureContainer button, #applyTextureContainerSprite button { flex: 1; margin: 0; }
    </style>
</head>
<body>
    <div id=ui>
        <div id=ui-header>Map Editor Rebuild v3.3.8 (Sprite Fix)</div>
        <div id=ui-content>
            <div class="section"><h3>Add Geometry</h3><button id=addBox>Add Box</button><button id=addPlane>Add Plane</button><button id=addSprite>Add Sprite</button></div>
            <div class="section"><h3>Add Prefab/Spawner</h3><button id=addElevator>Add Elevator</button><button id=addDoor>Add Door</button><button id=addPlayerStart>Add Player Start</button><button id=addItemSpawn>Add Item Spawn</button><button id=addEnemySpawn>Add Enemy Spawn</button><button id=addLevelTrigger>Add Level Trigger</button></div>
            <div class="section">
                <h3>Manipulation Mode</h3>
                <div class="mode-button-group">
                    <button id=modeTranslate>Translate (G)</button>
                    <button id=modeRotate disabled>Rotate (R)</button>
                    <button id=modeScale disabled>Scale (S)</button>
                </div>
                 <div id=currentModeInfo style="display: none;">Mode: Translate</div>
            </div>
            <div class="section">
                 <h3>View & Selection</h3>
                 <button id=deleteObject class="danger" disabled>Delete (Del)</button>
                 <button id="cloneObject" disabled>Clone (Ctrl+D)</button>
                 <label for="snapToGrid"><input type=checkbox id="snapToGrid" checked> Snap To Grid</label>
                 <label for="toggleWireframe"><input type=checkbox id="toggleWireframe"> Show Wireframe</label>
            </div>
            <div class="section">
                 <h3>Textures</h3>
                 <label>Select Texture:</label>
                 <div id="textureGrid"></div>
            </div>
            <div class="section" id="selectedObjectInfo" style="display: none;">
                <h3>Selected Properties</h3>
                <div id="selectedObjectType">Type: -</div>
                <div class="prop-section"><label>Position:</label> <div class="coord-input-group"><span class="coord-label">X</span><input type="number" step="0.1" class="coord-input" id="selectedPosX"><span class="coord-label">Y</span><input type="number" step="0.1" class="coord-input" id="selectedPosY"><span class="coord-label">Z</span><input type="number" step="0.1" class="coord-input" id="selectedPosZ"></div></div>
                <div class="prop-section" id="rotationSection"><label>Rotation:</label> <div class="coord-input-group"><span class="coord-label">X</span><input type="number" step="1" class="coord-input" id="selectedRotX"><span class="coord-label">Y</span><input type="number" step="1" class="coord-input" id="selectedRotY"><span class="coord-label">Z</span><input type="number" step="1" class="coord-input" id="selectedRotZ"><small class="unit">deg</small></div></div>
                <div class="prop-section" id="scaleSection"><label>Scale:</label> <div class="coord-input-group"><span class="coord-label">X</span><input type="number" step="0.1" min="0.01" class="coord-input" id="selectedScaleX"><span class="coord-label">Y</span><input type="number" step="0.1" min="0.01" class="coord-input" id="selectedScaleY"><span class="coord-label">Z</span><input type="number" step="0.1" min="0.01" class="coord-input" id="selectedScaleZ"></div></div>
                <div class="prop-section" id="geometryProps">
                     <h4>Geometry Properties</h4>
                     <label for="selectedIsCollider"><input type=checkbox id="selectedIsCollider"> Is Collider?</label>
                     <div id="faceSelector" style="display: none;">
                        <label>Active Face:</label>
                        <button data-face-index="0">+X</button><button data-face-index="1">-X</button><button data-face-index="2">+Y</button><button data-face-index="3">-Y</button><button data-face-index="4">+Z</button><button data-face-index="5">-Z</button>
                     </div>
                     <div id="applyTextureContainer"><button id="applyTexture">Apply to Face</button><button id="applyTextureAll">Apply to All</button></div>
                     <div id="textureProps">
                        <label>Texture Scale:</label><div class="half-input-group"><span class="coord-label">U</span><input type="number" step="0.1" value="1" class="half-input" id="texScaleU"><span class="coord-label">V</span><input type="number" step="0.1" value="1" class="half-input" id="texScaleV"></div>
                         <label>Texture Offset:</label><div class="half-input-group"><span class="coord-label">U</span><input type="number" step="0.1" value="0" class="half-input" id="texOffsetU"><span class="coord-label">V</span><input type="number" step="0.1" value="0" class="half-input" id="texOffsetV"></div>
                     </div>
                </div>
                <div class="prop-section" id="spriteProps">
                     <h4>Sprite Properties</h4>
                     <div id="applyTextureContainerSprite"><button id="applyTextureSprite">Apply Texture</button></div>
                     <div><label for="selectedFixedRotation"><input type=checkbox id="selectedFixedRotation"> Fixed Rotation (vs Billboard)</label></div>
                     <div><label for="selectedSizeAttenuation"><input type=checkbox id="selectedSizeAttenuation"> Scale with Distance</label></div>
                     <div><label for="selectedDepthWrite"><input type=checkbox id="selectedDepthWrite"> Write to Depth Buffer</label></div>
                     <div><label for="selectedAlphaTest">Alpha Test Threshold (0-1):</label><input type="number" step="0.01" min="0" max="1" id="selectedAlphaTest"></div>
                     <div><label>Pivot Point (0-1):</label><div class="half-input-group"><span class="coord-label">X</span><input type="number" step="0.1" min="0" max="1" class="half-input" id="selectedCenterX"><span class="coord-label">Y</span><input type="number" step="0.1" min="0" max="1" class="half-input" id="selectedCenterY"></div></div>
                     <div><label for="selectedTintColor">Tint Color:</label><input type=color id="selectedTintColor"></div>
                </div>
                <div class="prop-section" id="animationProps" style="display: none;">
                    <h4>Animation</h4>
                    <label for="animType">Animation Type:</label> <select id="animType"><option value="translate">Translate</option><option value="rotate">Rotate</option></select>
                    <div id="animationTargetFields">
                        <div id="animTargetPos" style="display: none;"><label>Target Position Offset:</label><div class="coord-input-group"><span class="coord-label">X</span><input type="number" step="0.1" class="coord-input" id="animTargetPosX"><span class="coord-label">Y</span><input type="number" step="0.1" class="coord-input" id="animTargetPosY"><span class="coord-label">Z</span><input type="number" step="0.1" class="coord-input" id="animTargetPosZ"></div></div>
                        <div id="animTargetRot" style="display: none;"><label>Target Rotation:</label><div class="coord-input-group"><span class="coord-label">X</span><input type="number" step="1" class="coord-input" id="animTargetRotX"><span class="coord-label">Y</span><input type="number" step="1" class="coord-input" id="animTargetRotY"><span class="coord-label">Z</span><input type="number" step="1" class="coord-input" id="animTargetRotZ"><small class="unit">deg</small></div></div>
                    </div>
                    <button id="setAnimTarget" class="secondary">Set Current Transform as Target</button>
                    <label for="animDuration">Duration (seconds):</label><input type="number" step="0.1" min="0.1" id="animDuration">
                    <label for="animLoop">Loop Behaviour:</label><select id="animLoop"><option value="once">Play Once</option><option value="loop">Loop</option><option value="pingpong">Ping-Pong</option></select>
                    <label for="animAutoStart"><input type=checkbox id="animAutoStart"> Auto Start on Load</label>
                    <label for="animTriggerId">Trigger ID (Optional):</label><input type="text" id="animTriggerId" placeholder="e.g., door_button_1">
                    <button id="previewAnim" class="secondary">Preview Animation</button> <button id="clearAnim" class="danger">Clear Animation Data</button>
                </div>
                <div class="prop-section" id="selectedPrefabProps"></div>
                <div class="prop-section" id="selectedSpawnerProps"></div>
            </div>
            <div class="section"><h3>File</h3><button id="exportMap" class="primary">Export JSON</button><button id="loadMap">Load JSON</button><input type=file id="loadInput" accept=".json" style="display: none;"></div>
        </div>
        <div id="statusBar">-</div>
    </div>
    <div id="instructionsPanel">
        <h3>Controls</h3><ul><li><kbd>LMB Drag</kbd> Orbit View</li><li><kbd>MMB Drag</kbd> / <kbd>Shift+LMB Drag</kbd> Pan View</li><li><kbd>Scroll</kbd> Zoom View</li><li><kbd>LMB Click</kbd> Select / Deselect</li><li><kbd>LMB Click (Gizmo Center)</kbd> Cycle Mode (R/S)</li></ul>
        <h3>Manipulation</h3><ul><li><kbd>G</kbd> / <kbd>Button</kbd> Translate Mode</li><li><kbd>R</kbd> / <kbd>Button</kbd> Rotate Mode</li><li><kbd>S</kbd> / <kbd>Button</kbd> Scale Mode</li><li><kbd>Space</kbd> Cycle Rotate/Scale</li><li><kbd>Q</kbd> Toggle Local/World Space</li><li><kbd>Shift (Hold)</kbd> Uniform Scaling</li><li><kbd>Snap Checkbox</kbd> Enable Snapping</li></ul>
        <h3>View</h3><ul><li><kbd>Wireframe Checkbox</kbd> Toggle Wireframe</li></ul>
        <h3>Animation</h3><ul><li>Define target, duration etc. in UI</li><li><kbd>Set Target</kbd> Records current transform</li><li><kbd>Preview</kbd> Plays animation</li></ul>
        <h3>Texturing</h3><ul><li>Box: Select face, then apply</li><li><kbd>Apply to Face</kbd> Applies to active face</li><li><kbd>Apply to All</kbd> Applies to all faces/obj</li><li>Adjust UV Scale/Offset per face</li></ul>
        <h3>Editing</h3><ul><li><kbd>Del</kbd> / <kbd>Backspace</kbd> Delete</li><li><kbd>Ctrl+D</kbd> Clone</li><li><kbd>Esc</kbd> Deselect</li></ul>
        <h3>File</h3><ul><li>Use UI Buttons for Export/Load</li></ul>
    </div>
    <canvas id="editorCanvas"></canvas>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/controls/TransformControls.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/OutlinePass.js"></script>

    <script>
        const PLACE_DISTANCE = 5;
        const SNAP_TRANSLATION = 1.0;
        const SNAP_ROTATION_DEG = 15;
        const SNAP_SCALE = 0.5;
        const STATUS_MESSAGE_DURATION = 3000;
        const DEFAULT_TEX_SCALE = [1, 1];
        const DEFAULT_TEX_OFFSET = [0, 0];
        const MIN_SCALE = 0.01;
        const texturePathString = "images/BRICK_1A.png|images/BRICK_2B.png|images/BRICK_3B.png|images/BRICK_3D.png|images/BRICK_4A.png|images/BRICK_6D.png|images/Bigdoor_left.png|images/Bigdoor_right.png|images/BluePanel.png|images/CONCRETE_3C.png|images/CONCRETE_4A.png|images/CONSOLE_1B.png|images/Cryoback.png|images/Cryofront.png|images/Cryoleft.png|images/Cryoright.png|images/Cryotop.png|images/DIRT_1A.png|images/DOORTRIM_1A.png|images/DOOR_1A.png|images/DOOR_1C.png|images/DOOR_1E.png|images/DOOR_4A.png|images/Door.png|images/FLOOR_1A.png|images/FLOOR_3A.png|images/FLOOR_4A.png|images/GRASS_1A.png|images/GRID_1A.png|images/GRID_2B.png|images/HEDGE_1A.png|images/LAB_2B.png|images/LIGHT_1B.png|images/LockerPanel.png|images/Lorenote1.png|images/PAPER_1B.png|images/PAPER_1E.png|images/PAPER_1F.png|images/PIPES_1A.PNG|images/PIPES_2B.PNG|images/RIVET_1A.PNG|images/SAND_1A.PNG|images/WARN_1A.png|images/WOOD_1C.png|images/ammo.png|images/ammocrate.png|images/bigdoor23.png|images/blood.png|images/blood1.png|images/bullet.png|images/bullethole.png|images/bush1.png|images/bush2.png|images/bush3.png|images/bush4.png|images/bush5.png|images/ceiling_tiles_damaged.png|images/concrete_stained.png|images/concretewall.png|images/crate1.png|images/crate2.png|images/crate3.png|images/crate4.png|images/darkbricks.png|images/darktiles.png|images/desk_metal.png|images/dirt.png|images/door_barricaded.png|images/door_security_heavy.png|images/doorbord.png|images/elecPanel.png|images/elecbox.png|images/elevator_ceiling.png|images/elevator_door.png|images/elevator_floor.png|images/elevator_shaft.png|images/elevator_wall.png|images/floor_tiles_dirty.png|images/foresta1.png|images/foresta2.png|images/foresta3.png|images/foresta4.png|images/foresta5.png|images/foresta6.png|images/grass1.png|images/grass2.png|images/grass3.png|images/grass4.png|images/gun.gif|images/hazard.png|images/health_pack.png|images/iron.png|images/irondoor.png|images/ja987.png|images/jasdf7.png|images/jkdsa8j.png|images/key.png|images/keycardreader.png|images/level-2-keycard.png|images/level-3-keycard.png|images/level-4-keycard.png|images/level-5-keycard.png|images/level1keycard.png|images/lite1.png|images/lkhj58.png|images/locker.png|images/lockerSlim.png|images/medkit.png|images/n_gr_0_02.png|images/n_grass_diff_0_01.png|images/n_grass_diff_0_02.png|images/n_grass_diff_0_03.png|images/n_grass_diff_0_04.png|images/n_grass_diff_0_05.png|images/n_grass_diff_0_06.png|images/n_grass_diff_0_07.png|images/n_grass_diff_0_08.png|images/n_grass_diff_0_13.png|images/n_grass_diff_0_14.png|images/n_grass_diff_0_15.png|images/n_grass_diff_0_16.png|images/n_grass_diff_0_17.png|images/n_grass_diff_0_18.png|images/n_grass_diff_0_19.png|images/n_grass_diff_0_20.png|images/n_grass_diff_0_21.png|images/n_grass_diff_0_22.png|images/n_grass_diff_0_23.png|images/n_grass_diff_0_24.png|images/n_grass_diff_0_25.png|images/n_grass_diff_0_26.png|images/n_grass_diff_0_27.png|images/n_grass_diff_0_28.png|images/n_grass_diff_0_29.png|images/n_grass_diff_0_30.png|images/n_grass_diff_0_31.png|images/n_grass_diff_0_32.png|images/n_grass_diff_0_33.png|images/n_grass_diff_0_34.png|images/n_grass_diff_0_35.png|images/n_grass_diff_0_36.png|images/n_grass_diff_0_37.png|images/n_grass_diff_0_38.png|images/n_grass_diff_0_39.png|images/n_grass_diff_0_40.png|images/n_grass_diff_0_41.png|images/n_grass_diff_0_42.png|images/n_grass_diff_0_44.png|images/n_grass_diff_0_45.png|images/n_grass_diff_0_46.png|images/n_grass_diff_0_47.png|images/n_grass_diff_0_48.png|images/n_grass_diff_0_49.png|images/n_grass_diff_0_50.png|images/n_grass_diff_0_51.png|images/n_grass_diff_0_52.png|images/n_grass_diff_0_53.png|images/n_grass_diff_0_54.png|images/n_grass_diff_0_55.png|images/n_grass_diff_0_56.png|images/n_grass_diff_0_57.png|images/n_grass_diff_0_58.png|images/n_grass_diff_0_59.png|images/n_grass_diff_0_60.png|images/n_grass_diff_0_61.png|images/n_grass_diff_0_62.png|images/n_grass_diff_0_63.png|images/n_grass_diff_0_64.png|images/pistol_ammo.png|images/railing.png|images/ramp1.png|images/shortgrass1.png|images/shortgrass2.png|images/shortgrass3.png|images/sky.png|images/stepbot.png|images/steplight.png|images/stepsid.png|images/steptop.png|images/sun.png|images/suprt1.png|images/suprt2.png|images/suprt3.png|images/terminal_screen_off.png|images/tree.png|images/tree1.png|images/tree2.png|images/tree3.png|images/trim1.png|images/trim2.png|images/vdoor.png|images/wall_office_basic.png|images/wall_panel_damaged.png|images/water.png|images/xcrate11a.png|images/xcrate11b.png";
        const texturePaths = texturePathString.split('|');

        let scene, camera, renderer, orbitControls, transformControls;
        let composer, outlinePass;
        const raycaster = new THREE.Raycaster(); const mouse = new THREE.Vector2();
        const clock = new THREE.Clock(); const textureLoader = new THREE.TextureLoader();
        let levelData = { geometry: [], prefabs: [], spawners: [], sprites: [] };
        let selectedObjectData = null; let selectedMesh = null; let selectedFaceIndex = 0;
        let loadedTextures = {}; let loadedMaterials = {}; let loadedSpriteMaterials = {};
        let isShiftPressed = false; let lastGizmoMode = 'translate'; let selectedTexturePath = "";
        let statusTimeout = null; let animationPreviewState = { isPlaying: false, mesh: null, startTime: 0, duration: 1, startPos: null, targetPos: null, startRot: null, targetRot: null, type: 'translate', loop: 'once', direction: 1 };
        const markerGeo = new THREE.SphereGeometry(0.15, 16, 8);
        const markerMats = {  door:new THREE.MeshBasicMaterial({color:0xffff00, wireframe: true}), player_start:new THREE.MeshBasicMaterial({color:0x00ff00, wireframe: true}), item:new THREE.MeshBasicMaterial({color:0xff00ff, wireframe: true}), enemy:new THREE.MeshBasicMaterial({color:0xff0000, wireframe: true}), level_trigger:new THREE.MeshBasicMaterial({color:0x00ffff, wireframe: true}) };
        const prefabTypes=["elevator","door"]; const spawnerTypes=["player_start","enemy","item","level_trigger"];
        const itemTypes=["keycard_security","keycard_office","healthpack","ammo_pistol","ammo_heavy","weapon_biggun"]; const enemyTypes=["guard_easy","guard_heavy","turret"];
        const _camPos = new THREE.Vector3(); const _spritePos = new THREE.Vector3(); const _targetDir = new THREE.Vector3();
        const _spriteQuaternion = new THREE.Quaternion(); const _yAxis = new THREE.Vector3(0, 1, 0); const _tempEuler = new THREE.Euler(); const _identityQuaternion = new THREE.Quaternion();
        const dom = {};

        function cacheDOMElements() {
            const ids = [
                'ui', 'ui-header', 'ui-content', 'editorCanvas', 'textureGrid', 'selectedObjectInfo', 'statusBar', 'instructionsPanel',
                'addBox', 'addPlane', 'addSprite', 'addElevator', 'addDoor', 'addPlayerStart', 'addItemSpawn', 'addEnemySpawn', 'addLevelTrigger',
                'modeTranslate', 'modeRotate', 'modeScale', 'currentModeInfo', 'deleteObject', 'cloneObject', 'snapToGrid', 'toggleWireframe',
                'applyTexture', 'applyTextureAll', 'applyTextureSprite', 'exportMap', 'loadMap', 'loadInput',
                'selectedObjectType', 'rotationSection', 'scaleSection', 'faceSelector', 'geometryProps', 'spriteProps', 'animationProps',
                'selectedPosX', 'selectedPosY', 'selectedPosZ', 'selectedRotX', 'selectedRotY', 'selectedRotZ', 'selectedScaleX', 'selectedScaleY', 'selectedScaleZ',
                'selectedIsCollider', 'texScaleU', 'texScaleV', 'texOffsetU', 'texOffsetV', 'textureProps', 'applyTextureContainer', 'applyTextureContainerSprite',
                'selectedFixedRotation', 'selectedSizeAttenuation', 'selectedDepthWrite', 'selectedAlphaTest', 'selectedCenterX', 'selectedCenterY', 'selectedTintColor',
                'animType', 'animationTargetFields', 'animTargetPos', 'animTargetRot', 'animTargetPosX', 'animTargetPosY', 'animTargetPosZ',
                'animTargetRotX', 'animTargetRotY', 'animTargetRotZ', 'setAnimTarget', 'animDuration', 'animLoop', 'animAutoStart', 'animTriggerId',
                'previewAnim', 'clearAnim', 'selectedPrefabProps', 'selectedSpawnerProps'
            ];
            ids.forEach(id => dom[id] = document.getElementById(id));
        }

        function init() {
            cacheDOMElements();
            scene = new THREE.Scene(); scene.background = new THREE.Color(0x303030);
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000); camera.position.set(8, 8, 8);
            renderer = new THREE.WebGLRenderer({ canvas: dom.editorCanvas, antialias: true }); renderer.setSize(window.innerWidth, window.innerHeight);
            orbitControls = new THREE.OrbitControls(camera, renderer.domElement); orbitControls.enableDamping = true; orbitControls.target.set(0, 1, 0);
            transformControls = new THREE.TransformControls(camera, renderer.domElement);
            transformControls.addEventListener('change', render);
            transformControls.addEventListener('dragging-changed', event => {
                orbitControls.enabled = !event.value;
                if (animationPreviewState.isPlaying && event.value && animationPreviewState.mesh === transformControls.object) {
                    resetToInitialTransform(animationPreviewState.mesh); animationPreviewState.isPlaying = false; showStatus("Animation preview stopped by dragging.");
                }
            });
            transformControls.addEventListener('objectChange', onObjectTransform); scene.add(transformControls);
            scene.add(new THREE.AmbientLight(0x888888));
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8); dirLight.position.set(5, 10, 7); scene.add(dirLight);
            const gridHelper = new THREE.GridHelper(50, 50, 0x555555, 0x444444); scene.add(gridHelper);
            composer = new THREE.EffectComposer(renderer); const renderPass = new THREE.RenderPass(scene, camera); composer.addPass(renderPass);
            outlinePass = new THREE.OutlinePass(new THREE.Vector2(window.innerWidth, window.innerHeight), scene, camera);
            outlinePass.edgeStrength = 2.5; outlinePass.edgeGlow = 0.2; outlinePass.edgeThickness = 0.8; outlinePass.pulsePeriod = 0;
            outlinePass.visibleEdgeColor.set('#00aaff'); outlinePass.hiddenEdgeColor.set('#094771'); composer.addPass(outlinePass);
            const copyPass = new THREE.ShaderPass(THREE.CopyShader); copyPass.renderToScreen = true; composer.addPass(copyPass);
            populateTextureUI(); setupEventListeners(); updateModeInfoUI(transformControls.mode); showStatus("Editor Ready."); animate();
        }
        function getTexture(texturePath) {
            if (!texturePath || loadedTextures[texturePath] === null) return null;
            if (loadedTextures[texturePath]) return loadedTextures[texturePath];
            try {
                const texture = textureLoader.load( texturePath, () => { render(); }, undefined, (err) => {
                        console.error(`Failed texture load: ${texturePath}`, err); loadedTextures[texturePath] = null; showStatus(`Error loading texture: ${texturePath.split('/').pop()}`, 5000); render();
                    });
                texture.wrapS = texture.wrapT = THREE.RepeatWrapping; texture.magFilter = THREE.NearestFilter; texture.minFilter = THREE.NearestMipmapLinearFilter;
                loadedTextures[texturePath] = texture; return texture;
            } catch (error) { console.error(`Exception during texture loading: ${texturePath}`, error); loadedTextures[texturePath] = null; showStatus(`Error loading texture: ${texturePath.split('/').pop()}`, 5000); return null; }
        }
        function getMaterial(texturePath, forSprite = false, spriteData = null, materialProps = {}) {
            const effectivePath = texturePath || 'FALLBACK'; const isWireframeActive = dom.toggleWireframe.checked;
            if (forSprite) {
                const props = { tint: spriteData?.tintColor || '#ffffff', sizeAtt: spriteData?.sizeAttenuation ?? false, alphaTest: spriteData?.alphaTest ?? 0.5, depthWrite: spriteData?.depthWrite ?? false };
                const cacheKey = `${effectivePath}_SPRITE`;
                if (loadedSpriteMaterials[cacheKey] && loadedSpriteMaterials[cacheKey].map?.image) {
                     const mat = loadedSpriteMaterials[cacheKey]; mat.color.set(props.tint); mat.sizeAttenuation = props.sizeAtt; mat.alphaTest = props.alphaTest; mat.depthWrite = props.depthWrite; mat.transparent = (props.alphaTest < 1.0); mat.needsUpdate = true; return mat;
                }
                const texture = getTexture(texturePath);
                const material = new THREE.SpriteMaterial({ map: texture, color: new THREE.Color(props.tint), sizeAttenuation: props.sizeAtt, alphaTest: props.alphaTest, depthWrite: props.depthWrite, transparent: (props.alphaTest < 1.0) });
                loadedSpriteMaterials[cacheKey] = material; return material;
            } else {
                const cacheKey = `${effectivePath}_MESH_${isWireframeActive}_${JSON.stringify(materialProps)}`;
                if (loadedMaterials[cacheKey] && loadedMaterials[cacheKey].map?.image) return loadedMaterials[cacheKey];
                const texture = getTexture(texturePath);
                const defaultProps = { map: texture, color: texture ? 0xffffff : 0xcccccc, roughness: 0.8, metalness: 0.1, side: materialProps.side || THREE.DoubleSide, wireframe: isWireframeActive, transparent: false, alphaTest: 0, depthWrite: true };
                const finalProps = { ...defaultProps, ...materialProps };
                const material = new THREE.MeshStandardMaterial(finalProps);
                loadedMaterials[cacheKey] = material; return material;
            }
        }
        function updateMaterialTextureTransform(material, scale, offset) {
            if (!material || !material.map) return;
            let needsClone = material.isMeshStandardMaterial && Array.isArray(selectedMesh?.material);
            if (needsClone && !material.userData.mapCloned) { material.map = material.map.clone(); material.map.needsUpdate = true; material.userData.mapCloned = true; }
            else if (!needsClone) material.userData.mapCloned = false;
            material.map.repeat.fromArray(scale || DEFAULT_TEX_SCALE); material.map.offset.fromArray(offset || DEFAULT_TEX_OFFSET); material.needsUpdate = true;
        }
        function populateTextureUI() {
            dom.textureGrid.innerHTML = ''; const noneItem = createTextureItem("", "None"); dom.textureGrid.appendChild(noneItem);
            texturePaths.forEach(path => { const filename = path.split('/').pop(); const item = createTextureItem(path, filename); dom.textureGrid.appendChild(item); });
            selectTextureItem(noneItem);
        }
        function createTextureItem(path, label) {
            const item = document.createElement('div'); item.className = 'textureItem'; item.dataset.texturePath = path; item.style.backgroundImage = path ? `url(${path})` : 'none'; item.title = label;
            item.addEventListener('click', () => selectTextureItem(item)); return item;
        }
        function selectTextureItem(itemElement) {
            const currentSelected = dom.textureGrid.querySelector('.textureItem.selected');
            if (currentSelected) currentSelected.classList.remove('selected');
            itemElement.classList.add('selected'); selectedTexturePath = itemElement.dataset.texturePath;
        }
        function setupEventListeners() {
            window.addEventListener('resize', onWindowResize); renderer.domElement.addEventListener('pointerdown', onPointerDown);
            window.addEventListener('keydown', onKeyDown); window.addEventListener('keyup', onKeyUp);
            dom.addBox.addEventListener('click', () => addGeometry('box')); dom.addPlane.addEventListener('click', () => addGeometry('plane')); dom.addSprite.addEventListener('click', addSpriteObject);
            dom.addElevator.addEventListener('click', () => addPrefab('elevator')); dom.addDoor.addEventListener('click', () => addPrefab('door')); dom.addPlayerStart.addEventListener('click', () => addSpawner('player_start'));
            dom.addItemSpawn.addEventListener('click', () => addSpawner('item')); dom.addEnemySpawn.addEventListener('click', () => addSpawner('enemy')); dom.addLevelTrigger.addEventListener('click', () => addSpawner('level_trigger'));
            dom.deleteObject.addEventListener('click', deleteSelected); dom.cloneObject.addEventListener('click', cloneSelected);
            dom.applyTexture.addEventListener('click', () => applyTextureToSelected(false)); dom.applyTextureAll.addEventListener('click', () => applyTextureToSelected(true)); dom.applyTextureSprite.addEventListener('click', () => applyTextureToSelected(false));
            dom.toggleWireframe.addEventListener('change', toggleWireframeMode);
            dom.modeTranslate.addEventListener('click', () => setGizmoMode('translate', true)); dom.modeRotate.addEventListener('click', () => setGizmoMode('rotate', true)); dom.modeScale.addEventListener('click', () => setGizmoMode('scale', true));
            dom.snapToGrid.addEventListener('change', () => {
                 const snap = dom.snapToGrid.checked; transformControls.setTranslationSnap(snap ? SNAP_TRANSLATION : null); transformControls.setRotationSnap(snap ? THREE.MathUtils.degToRad(SNAP_ROTATION_DEG) : null); transformControls.setScaleSnap((snap && !(isShiftPressed && transformControls.getMode() === 'scale')) ? SNAP_SCALE : null); render();
            });
            dom.exportMap.addEventListener('click', exportLevelData); dom.loadMap.addEventListener('click', () => dom.loadInput.click()); dom.loadInput.addEventListener('change', loadLevelDataFromFile);
            const updateInputs = ['selectedPosX', 'selectedPosY', 'selectedPosZ', 'selectedRotX', 'selectedRotY', 'selectedRotZ', 'selectedScaleX', 'selectedScaleY', 'selectedScaleZ', 'selectedIsCollider', 'texScaleU', 'texScaleV', 'texOffsetU', 'texOffsetV', 'selectedFixedRotation', 'selectedSizeAttenuation', 'selectedDepthWrite', 'selectedAlphaTest', 'selectedCenterX', 'selectedCenterY', 'selectedTintColor', 'animType', 'animTargetPosX', 'animTargetPosY', 'animTargetPosZ', 'animTargetRotX', 'animTargetRotY', 'animTargetRotZ', 'animDuration', 'animLoop', 'animAutoStart', 'animTriggerId'];
            updateInputs.forEach(id => dom[id].addEventListener(dom[id].type === 'checkbox' ? 'change' : 'input', updateSelectedDataFromUI));
            dom.faceSelector.querySelectorAll('button').forEach(button => { button.addEventListener('click', (e) => { const index = parseInt(e.target.dataset.faceIndex, 10); if (!isNaN(index) && selectedObjectData?.type === 'box') { selectedFaceIndex = index; updateSelectedObjectUI(); } }); });
            dom.setAnimTarget.addEventListener('click', setAnimationTarget); dom.previewAnim.addEventListener('click', previewAnimation); dom.clearAnim.addEventListener('click', clearAnimationData);
        }
        function getPlacementPosition() {
            const direction = new THREE.Vector3(); camera.getWorldDirection(direction);
            const position = new THREE.Vector3(); position.copy(camera.position).addScaledVector(direction, PLACE_DISTANCE);
            if (position.y < 0.6) position.y = 0.6;
            const snap = dom.snapToGrid.checked;
            if (snap) { position.x = Math.round(position.x / SNAP_TRANSLATION) * SNAP_TRANSLATION; position.y = Math.round(position.y / SNAP_TRANSLATION) * SNAP_TRANSLATION; if (Math.abs(position.y) < SNAP_TRANSLATION / 2) position.y = 0; position.z = Math.round(position.z / SNAP_TRANSLATION) * SNAP_TRANSLATION; }
            return position.toArray();
        }
        function createBaseData(type, position, isPlane = false) {
            const defaultSize = [1, 1, isPlane ? MIN_SCALE : 1];
            const defaultRotation = isPlane ? [-Math.PI / 2, 0, 0] : [0, 0, 0];
            const data = { id: THREE.MathUtils.generateUUID(), type: type, position: position, rotation: defaultRotation, scale: defaultSize, isCollider: !isPlane, animation: null, userData: {} };
            if (isPlane) data.material = { ref: null, scale: [...DEFAULT_TEX_SCALE], offset: [...DEFAULT_TEX_OFFSET] };
            else if (type === 'box') data.materials = Array(6).fill(null).map(() => ({ ref: null, scale: [...DEFAULT_TEX_SCALE], offset: [...DEFAULT_TEX_OFFSET] }));
            return data;
        }
        function addGeometry(type) {
            const isPlane = type === 'plane'; const placementPos = getPlacementPosition(); if (isPlane) placementPos[1] = 0;
            const geoData = createBaseData(type, placementPos, isPlane);
            levelData.geometry.push(geoData); const mesh = createMeshFromData(geoData);
            if (mesh) { scene.add(mesh); selectObject(mesh, geoData); showStatus(`Added ${type}`); } else { showStatus(`Failed to create ${type}`, 4000); }
        }
        function addPrefab(type) {
            const placementPos = getPlacementPosition(); placementPos[1] = 0;
            const prefabData = { id: THREE.MathUtils.generateUUID(), type: type, position: placementPos, rotationY: 0, config: type === 'elevator' ? { width: 1.8, height: 2.4, depth: 1.6 } : {}, requiredKey: type === 'door' ? null : undefined, userData: {} };
            levelData.prefabs.push(prefabData);
            let prefabObject;
            if (type === 'elevator') {
                prefabObject = createElevatorMesh(prefabData);
            } else {
                prefabObject = createMarkerMesh(prefabData);
            }
            if (prefabObject) { scene.add(prefabObject); selectObject(prefabObject, prefabData); showStatus(`Added ${type} ${type === 'elevator' ? '' : 'marker'}`); }
            else { showStatus(`Failed to create ${type} ${type === 'elevator' ? '' : 'marker'}`, 4000); }
        }
        function addSpawner(type) {
            const placementPos = getPlacementPosition(); placementPos[1] = 0.1;
            const spawnerData = { id: THREE.MathUtils.generateUUID(), type: type, position: placementPos, itemType: type === 'item' ? itemTypes[0] : undefined, itemId: type === 'item' ? 'item_' + Math.random().toString(16).substring(2, 8) : undefined, enemyType: type === 'enemy' ? enemyTypes[0] : undefined, lookDirection: type === 'player_start' ? [0, 0, -1] : undefined, rotationY: type === 'player_start' ? 0 : undefined, targetLevel: type === 'level_trigger' ? 'levelX.json' : undefined, boundingBox: type === 'level_trigger' ? { min: [-1, -0.1, -1], max: [1, 1, 1] } : undefined, userData: {} };
            levelData.spawners.push(spawnerData); const marker = createMarkerMesh(spawnerData);
            if (marker) { scene.add(marker); selectObject(marker, spawnerData); showStatus(`Added ${type} marker`); } else { showStatus(`Failed to create ${type} marker`, 4000); }
        }
        function addSpriteObject() {
            const placementPos = getPlacementPosition();
            const spriteData = { id: THREE.MathUtils.generateUUID(), type: 'sprite', position: placementPos, rotation: [0,0,0], scale: [1, 1, 1], materialRef: null, autoRotate: true, isCollider: false, center: [0.5, 0.0], sizeAttenuation: false, alphaTest: 0.5, depthWrite: false, tintColor: '#ffffff', userData: {} };
            levelData.sprites.push(spriteData); const spriteMesh = createSpriteMesh(spriteData);
            if (spriteMesh) { scene.add(spriteMesh); selectObject(spriteMesh, spriteData); showStatus('Added sprite'); } else { showStatus('Failed to create sprite', 4000); }
        }
        function createMeshFromData(geoData) {
            let geometry; if (geoData.type === 'box') geometry = new THREE.BoxGeometry(1, 1, 1); else if (geoData.type === 'plane') geometry = new THREE.PlaneGeometry(1, 1); else { console.error("Unsupported geometry type:", geoData.type); return null; }
            let meshMaterial; const isWireframeActive = dom.toggleWireframe.checked;
            if (geoData.type === 'box') {
                 if (!geoData.materials || !Array.isArray(geoData.materials) || geoData.materials.length !== 6) geoData.materials = Array(6).fill(null).map(() => ({ ref: null, scale: [...DEFAULT_TEX_SCALE], offset: [...DEFAULT_TEX_OFFSET] }));
                meshMaterial = [];
                for (let i = 0; i < 6; i++) {
                    const matData = geoData.materials[i] || { ref: null, scale: [...DEFAULT_TEX_SCALE], offset: [...DEFAULT_TEX_OFFSET] };
                    const baseMaterial = getMaterial(matData.ref, false); const faceMaterial = baseMaterial.clone();
                    faceMaterial.wireframe = isWireframeActive; faceMaterial.userData.mapCloned = false; if (faceMaterial.map) updateMaterialTextureTransform(faceMaterial, matData.scale, matData.offset); meshMaterial.push(faceMaterial);
                }
            } else {
                 if (!geoData.material || typeof geoData.material !== 'object') geoData.material = { ref: null, scale: [...DEFAULT_TEX_SCALE], offset: [...DEFAULT_TEX_OFFSET] };
                const matData = geoData.material; meshMaterial = getMaterial(matData.ref, false).clone(); meshMaterial.wireframe = isWireframeActive; if (meshMaterial.map) updateMaterialTextureTransform(meshMaterial, matData.scale, matData.offset);
            }
            const mesh = new THREE.Mesh(geometry, meshMaterial); mesh.position.fromArray(geoData.position); mesh.rotation.fromArray(geoData.rotation); mesh.scale.fromArray(geoData.scale);
            mesh.userData.dataId = geoData.id; mesh.userData.isCollider = geoData.isCollider; mesh.userData.isGeometry = true; mesh.userData.isPlane = (geoData.type === 'plane');
            mesh.userData.initialPosition = mesh.position.clone(); mesh.userData.initialRotation = mesh.rotation.clone(); return mesh;
        }
        function createMarkerMesh(markerData) {
             const mat = markerMats[markerData.type]; if (!mat) { console.error("Could not find material for marker type:", markerData.type); return null; }
            const mesh = new THREE.Mesh(markerGeo, mat); mesh.position.fromArray(markerData.position);
             if (markerData.rotationY !== undefined) mesh.rotation.y = markerData.rotationY;
             else if (markerData.lookDirection && markerData.type === 'player_start') { const lookDir = new THREE.Vector3().fromArray(markerData.lookDirection); mesh.lookAt(mesh.position.clone().add(lookDir)); markerData.rotationY = mesh.rotation.y; }
            mesh.userData.dataId = markerData.id; mesh.userData.isMarker = true; mesh.userData.markerType = markerData.type;
            mesh.userData.initialPosition = mesh.position.clone(); mesh.userData.initialRotation = mesh.rotation.clone(); return mesh;
        }

        function createElevatorMesh(d) {
            const c = d.config || {};
            const w = c.width || 1.8, h = c.height || 2.4, dp = c.depth || 1.6;
            const dt = 0.04, ft = 0.05, fw = 0.08;
            const hw = w / 2, hh = h / 2, hdp = dp / 2;
            const dw = hw;

            const grp = new THREE.Group();
            grp.position.fromArray(d.position);
            grp.rotation.y = d.rotationY || 0;

            const mDr = getMaterial('images/elevator_door.png', false, null, { metalness: 0.6, roughness: 0.4, side: THREE.DoubleSide });
            const mWl = getMaterial('images/elevator_wall.png', false, null, { metalness: 0.3, roughness: 0.7 });
            const mFl = getMaterial('images/elevator_floor.png', false, null, { metalness: 0.3, roughness: 0.7 });
            const mCl = getMaterial('images/elevator_ceiling.png', false, null, { metalness: 0.3, roughness: 0.7 });
            const mFr = mWl;

            const setUV = (m, u, v) => { if (m && m.map) { m.map = m.map.clone(); m.map.repeat.set(u, v); m.map.needsUpdate = true; m.userData.mapCloned = true; } };

            const fl = new THREE.Mesh(new THREE.PlaneGeometry(w, dp), mFl);
            fl.rotation.x = -Math.PI / 2; setUV(fl.material, w/2, dp/2);
            const cl = new THREE.Mesh(new THREE.PlaneGeometry(w, dp), mCl);
            cl.rotation.x = Math.PI / 2; cl.position.y = h; setUV(cl.material, w/2, dp/2);
            const bw = new THREE.Mesh(new THREE.PlaneGeometry(w, h), mWl);
            bw.position.set(0, hh, hdp); setUV(bw.material, w/2, h/2);
            const lw = new THREE.Mesh(new THREE.PlaneGeometry(dp, h), mWl.clone());
            lw.rotation.y = Math.PI / 2; lw.position.set(-hw, hh, 0); setUV(lw.material, dp/2, h/2);
            const rw = new THREE.Mesh(new THREE.PlaneGeometry(dp, h), mWl.clone());
            rw.rotation.y = -Math.PI / 2; rw.position.set(hw, hh, 0); setUV(rw.material, dp/2, h/2);

            const frZ = -hdp - ft / 2;
            const frT = new THREE.Mesh(new THREE.BoxGeometry(w + fw*2, fw, ft), mFr.clone());
            frT.position.set(0, h - fw / 2, frZ);
            const frL = new THREE.Mesh(new THREE.BoxGeometry(fw, h - fw, ft), mFr.clone());
            frL.position.set(-hw - fw / 2, hh - fw / 2, frZ);
            const frR = new THREE.Mesh(new THREE.BoxGeometry(fw, h - fw, ft), mFr.clone());
            frR.position.set(hw + fw / 2, hh - fw / 2, frZ);

            const drZ = -hdp - ft + dt / 2;
            const drL = new THREE.Mesh(new THREE.BoxGeometry(dw, h, dt), mDr);
            drL.position.set(-dw / 2, hh, drZ);
            const drR = new THREE.Mesh(new THREE.BoxGeometry(dw, h, dt), mDr.clone());
            drR.position.set(dw / 2, hh, drZ);

            grp.add(fl, cl, bw, lw, rw, frT, frL, frR, drL, drR);

            grp.traverse(ch => { if (ch.isMesh) ch.userData.parentGroupDataId = d.id; });
            grp.userData = { dataId: d.id, isPrefab: true, prefabType: 'elevator', initialPosition: grp.position.clone(), initialRotation: grp.rotation.clone() };

            [fl, cl, bw, lw, rw, frT, frL, frR, drL, drR].forEach(m => m.userData.isCollider = true);

            return grp;
        }

        function createSpriteMesh(spriteData) {
             const material = getMaterial(spriteData.materialRef, true, spriteData); if (!material) { console.error("Failed to create material for sprite:", spriteData.id); return null; }
             const sprite = new THREE.Sprite(material); sprite.position.fromArray(spriteData.position); sprite.scale.set(spriteData.scale[0], spriteData.scale[1], 1); sprite.center.set(spriteData.center[0] ?? 0.5, spriteData.center[1] ?? 0.0);
             sprite.userData.dataId = spriteData.id; sprite.userData.isSprite = true; sprite.userData.autoRotate = spriteData.autoRotate ?? true; sprite.userData.initialPosition = sprite.position.clone();
             if (!sprite.userData.autoRotate && spriteData.rotation) { _tempEuler.fromArray(spriteData.rotation); sprite.quaternion.setFromEuler(_tempEuler); } return sprite;
         }
        function applyTextureToSelected(applyToAll = false) {
            if (!selectedMesh || !selectedObjectData) { showStatus("Select an object first.", 4000); return; }
            const textureToApply = selectedTexturePath; const isWireframeActive = dom.toggleWireframe.checked; const isSprite = selectedMesh.userData.isSprite;
            if (selectedMesh.userData.isGeometry) {
                const currentScale = [parseFloat(dom.texScaleU.value) || 1, parseFloat(dom.texScaleV.value) || 1]; const currentOffset = [parseFloat(dom.texOffsetU.value) || 0, parseFloat(dom.texOffsetV.value) || 0];
                if (selectedObjectData.type === 'box') {
                    const indicesToUpdate = applyToAll ? [0, 1, 2, 3, 4, 5] : [selectedFaceIndex]; if (selectedFaceIndex < 0 || selectedFaceIndex >= 6) { showStatus("Invalid face index selected.", 4000); return; }
                    const newBaseMaterial = getMaterial(textureToApply, false);
                    indicesToUpdate.forEach(index => {
                        const matData = selectedObjectData.materials[index]; matData.ref = textureToApply || null; matData.scale = [...currentScale]; matData.offset = [...currentOffset];
                        if (selectedMesh.material[index]?.map) selectedMesh.material[index].map.dispose(); if (selectedMesh.material[index]) selectedMesh.material[index].dispose();
                        const newFaceMaterial = newBaseMaterial.clone(); newFaceMaterial.wireframe = isWireframeActive; newFaceMaterial.userData.mapCloned = false; if (newFaceMaterial.map) updateMaterialTextureTransform(newFaceMaterial, matData.scale, matData.offset); selectedMesh.material[index] = newFaceMaterial;
                    }); showStatus(`Texture applied to ${applyToAll ? 'all faces' : 'face ' + selectedFaceIndex}.`);
                } else {
                    const matData = selectedObjectData.material; matData.ref = textureToApply || null; matData.scale = [...currentScale]; matData.offset = [...currentOffset];
                    if (selectedMesh.material?.map) selectedMesh.material.map.dispose(); if (selectedMesh.material) selectedMesh.material.dispose();
                    const newBaseMaterial = getMaterial(matData.ref, false); selectedMesh.material = newBaseMaterial.clone(); selectedMesh.material.wireframe = isWireframeActive; if (selectedMesh.material.map) updateMaterialTextureTransform(selectedMesh.material, matData.scale, matData.offset); showStatus(`Texture applied to plane.`);
                }
            } else if (isSprite) {
                 selectedObjectData.materialRef = textureToApply || null; const newMaterial = getMaterial(selectedObjectData.materialRef, true, selectedObjectData);
                 if (selectedMesh.material !== newMaterial) { if (selectedMesh.material?.map) selectedMesh.material.map.dispose(); if (selectedMesh.material) selectedMesh.material.dispose(); selectedMesh.material = newMaterial; } else selectedMesh.material.needsUpdate = true;
                 showStatus(`Texture applied to sprite.`);
            } else { showStatus("Cannot apply texture to this object type.", 4000); return; }
            updateSelectedObjectUI(); render();
        }
        function toggleWireframeMode() {
            const isChecked = dom.toggleWireframe.checked; loadedMaterials = {};
            scene.traverse(child => {
                 if (child.isMesh && (child.userData.isGeometry || (child.userData.parentGroupDataId && findObjectDataById(child.userData.parentGroupDataId)?.type === 'elevator') ) ) {
                    const geoData = findObjectDataById(child.userData.dataId || child.userData.parentGroupDataId); if (!geoData) return;

                     const applyWireframe = (material, matData) => {
                        if (!material || !material.isMeshStandardMaterial) return material;
                        const baseMat = getMaterial(matData?.ref, false, null, { metalness: material.metalness, roughness: material.roughness, side: material.side });
                        const newMat = baseMat.clone();
                        newMat.wireframe = isChecked;
                        newMat.userData.mapCloned = false;
                        if (newMat.map) updateMaterialTextureTransform(newMat, matData?.scale, matData?.offset);
                        return newMat;
                    };
                    const disposeMaterial = (material) => { if (material?.map) material.map.dispose(); if (material && material.dispose) material.dispose(); };

                    if (geoData.type === 'box' && Array.isArray(child.material)) {
                         const newBaseMaterials = {};
                         for (let i = 0; i < 6; i++) {
                             const matData = geoData.materials[i];
                             const baseKey = matData.ref || 'FALLBACK';
                             if (!newBaseMaterials[baseKey]) newBaseMaterials[baseKey] = getMaterial(matData.ref, false);
                             const newFaceMaterial = newBaseMaterials[baseKey].clone();
                             newFaceMaterial.wireframe = isChecked;
                             newFaceMaterial.userData.mapCloned = false;
                             if(newFaceMaterial.map) updateMaterialTextureTransform(newFaceMaterial, matData.scale, matData.offset);
                             disposeMaterial(child.material[i]);
                             child.material[i] = newFaceMaterial;
                         }
                     } else if (geoData.type === 'plane' && !Array.isArray(child.material)) {
                         const newMaterial = applyWireframe(child.material, geoData.material);
                         disposeMaterial(child.material);
                         child.material = newMaterial;
                     } else if (geoData.type === 'elevator' && child.isMesh && !Array.isArray(child.material)) {

                         const newMaterial = applyWireframe(child.material, null);
                         disposeMaterial(child.material);
                         child.material = newMaterial;
                     }
                 }
            }); showStatus(`Wireframe ${isChecked ? 'ON' : 'OFF'}`); render();
        }
        function deleteSelected() {
            if (!selectedObjectData || !selectedMesh) return; const idToDelete = selectedObjectData.id; const type = selectedObjectData.type;
            let list; if (type === 'sprite') list = levelData.sprites; else if (type === 'plane' || type === 'box') list = levelData.geometry; else if (prefabTypes.includes(type)) list = levelData.prefabs; else if (spawnerTypes.includes(type)) list = levelData.spawners;
            if (list) { const index = list.findIndex(item => item.id === idToDelete); if (index > -1) { list.splice(index, 1); transformControls.detach(); outlinePass.selectedObjects = [];
                 if (selectedMesh.isGroup) {
                     selectedMesh.traverse(child => {
                         if (child.geometry) child.geometry.dispose();
                         if (child.material) {
                            if (Array.isArray(child.material)) child.material.forEach(mat => { if (mat?.map) mat.map.dispose(); if(mat) mat.dispose(); });
                            else { if (child.material.map) child.material.map.dispose(); if (child.material.dispose) child.material.dispose(); }
                         }
                     });
                 } else {
                     if (selectedMesh.geometry) selectedMesh.geometry.dispose();
                     if (selectedMesh.material) {
                         if (Array.isArray(selectedMesh.material)) selectedMesh.material.forEach(mat => { if (mat?.map) mat.map.dispose(); if(mat) mat.dispose(); });
                         else { if (selectedMesh.material.map) selectedMesh.material.map.dispose(); if(selectedMesh.material.dispose) selectedMesh.material.dispose(); }
                     }
                 }
                 scene.remove(selectedMesh);
                 selectedObjectData = null; selectedMesh = null; updateSelectedObjectUI(); showStatus(`Deleted ${type}`); render(); return;
                 } }
            console.error("Could not find data to delete for object:", idToDelete); showStatus("Error: Could not delete object data.", 5000);
        }
        function cloneSelected() {
            if (!selectedObjectData || !selectedMesh) return; const clonedData = JSON.parse(JSON.stringify(selectedObjectData)); clonedData.id = THREE.MathUtils.generateUUID();
            const offsetAmount = (dom.snapToGrid.checked ? SNAP_TRANSLATION : 1.0) || 1.0; clonedData.position[0] += offsetAmount; clonedData.position[2] += offsetAmount; if (clonedData.position[1] < 0.1 && !selectedMesh.userData.isPlane && !selectedMesh.userData.isPrefab) clonedData.position[1] = selectedMesh.userData.isPlane ? 0 : 0.6; else if (clonedData.position[1] < 0) clonedData.position[1] = 0;

            let newMesh; let success = false; let list; let creatorFunc;
            if (selectedMesh.userData.isGeometry) { list = levelData.geometry; creatorFunc = createMeshFromData; }
            else if (selectedMesh.userData.isSprite) { list = levelData.sprites; creatorFunc = createSpriteMesh; }
            else if (selectedMesh.userData.isMarker || selectedMesh.userData.isPrefab) {
                 if (prefabTypes.includes(clonedData.type)) {
                     list = levelData.prefabs;
                     creatorFunc = (clonedData.type === 'elevator') ? createElevatorMesh : createMarkerMesh;
                 } else if (spawnerTypes.includes(clonedData.type)) {
                     list = levelData.spawners; creatorFunc = createMarkerMesh;
                 } else { console.error("Unknown marker/prefab type to clone:", clonedData.type); showStatus("Error: Cannot clone unknown marker/prefab type.", 5000); return; }
            }
            else { console.error("Unknown object type to clone:", selectedObjectData.type); showStatus("Error: Cannot clone this object type.", 5000); return; }
            list.push(clonedData); newMesh = creatorFunc(clonedData); if (newMesh) success = true;
            if (success && newMesh) { scene.add(newMesh); selectObject(newMesh, clonedData); showStatus(`Cloned ${clonedData.type}`); render(); } else { showStatus(`Error cloning ${clonedData.type}`, 5000); }
        }
        function onPointerDown(event) {
             if (dom.ui.contains(event.target) || dom.instructionsPanel.contains(event.target) || transformControls.dragging) return;
            mouse.set((event.clientX / window.innerWidth) * 2 - 1, -(event.clientY / window.innerHeight) * 2 + 1); raycaster.setFromCamera(mouse, camera);
            let clickedGizmo = false;
            if (transformControls.object && transformControls.visible) {
                const gizmoParts = []; transformControls.traverseVisible(child => { if ((child.isMesh || child.isLine) && child.parent?.name && ['X','Y','Z', 'XYZE', 'E', 'Translate', 'Rotate', 'Scale', 'XYZ'].includes(child.parent.name)) gizmoParts.push(child); });
                const gizmoIntersects = raycaster.intersectObjects(gizmoParts, false);
                if (gizmoIntersects.length > 0) { clickedGizmo = true; if (gizmoIntersects[0].object.name === 'XYZ') { cycleTransformMode(['rotate', 'scale']); event.stopPropagation(); } }
            }
            if (!clickedGizmo) {
                 const objectsToIntersect = scene.children.filter(c => c !== transformControls && c.type !== 'GridHelper' && (c.isMesh || c.isSprite || c.isGroup) && c.visible && (c.userData.dataId || c.userData.parentGroupDataId) );
                 const intersects = raycaster.intersectObjects(objectsToIntersect, true);

                if (intersects.length > 0) {
                    let clickedObj = intersects[0].object;

                    while (clickedObj.userData.parentGroupDataId && clickedObj.parent) {
                         if (clickedObj.parent.userData?.dataId === clickedObj.userData.parentGroupDataId) {
                            clickedObj = clickedObj.parent;
                            break;
                         }
                         clickedObj = clickedObj.parent;
                    }

                    if (clickedObj.userData.dataId) {
                        const dataObject = findObjectDataById(clickedObj.userData.dataId);
                        if (dataObject) {
                             selectObject(clickedObj, dataObject);
                        } else { console.warn("Clicked mesh has dataId but no corresponding data found:", clickedObj.userData.dataId); deselectObject(); }
                     } else {
                        deselectObject();
                     }
                 } else {
                     deselectObject();
                 }
            }
        }
        function findObjectDataById(id) { return !id ? null : levelData.geometry.find(item => item.id === id) || levelData.prefabs.find(item => item.id === id) || levelData.spawners.find(item => item.id === id) || levelData.sprites.find(item => item.id === id); }
        function setGizmoMode(newMode, isUserAction = false) {
             if (!transformControls) return;
             let canTranslate = selectedMesh != null;
             let canRotate = selectedMesh && (!selectedMesh.userData.isMarker && !selectedMesh.userData.isPrefab && (!selectedMesh.userData.isSprite || !(selectedObjectData?.autoRotate ?? true))) || (selectedMesh.userData.isPrefab && selectedObjectData?.type ==='elevator') || (selectedMesh.userData.isMarker && selectedObjectData?.type !== 'level_trigger');
             let canScale = selectedMesh && (selectedMesh.userData.isGeometry || selectedMesh.userData.isSprite) && !selectedMesh.userData.isPrefab;

             let allowed = (newMode === 'translate' && canTranslate) || (newMode === 'rotate' && canRotate) || (newMode === 'scale' && canScale);
             let targetMode = transformControls.getMode();

            if (allowed) {
                targetMode = newMode;
             } else if (isUserAction) {
                 if (newMode === 'rotate') targetMode = canTranslate ? 'translate' : (canScale ? 'scale' : 'translate');
                 else if (newMode === 'scale') targetMode = canTranslate ? 'translate' : (canRotate ? 'rotate' : 'translate');
                 else targetMode = 'translate';
                 showStatus(`Mode '${newMode}' not available. Switched to '${targetMode}'.`, 3000);
             } else {

                 if (transformControls.mode === 'rotate' && !canRotate) targetMode = 'translate';
                 if (transformControls.mode === 'scale' && !canScale) targetMode = 'translate';
                 if (!canTranslate && !canRotate && !canScale) targetMode = null;
                 else if (targetMode === transformControls.mode && !allowed) targetMode = 'translate';
                 else if (!targetMode && canTranslate) targetMode = 'translate';
             }

             if (transformControls.object && targetMode) {
                 transformControls.setMode(targetMode);

                 transformControls.showX = targetMode !== 'rotate' || !selectedMesh.userData.isMarker && !selectedMesh.userData.isPrefab;
                 transformControls.showY = targetMode !== 'rotate' || canRotate;
                 transformControls.showZ = targetMode !== 'rotate' || !selectedMesh.userData.isMarker && !selectedMesh.userData.isPrefab;
             } else if (!selectedMesh) {
                 transformControls.setMode('translate');
                 transformControls.detach();
             }

            updateModeInfoUI(targetMode || 'translate');
            if (isUserAction && allowed) lastGizmoMode = newMode;
        }
        function selectObject(obj, data) {
             if (selectedMesh === obj) return; if (animationPreviewState.isPlaying && animationPreviewState.mesh !== obj) { resetToInitialTransform(animationPreviewState.mesh); animationPreviewState.isPlaying = false; showStatus("Animation preview stopped due to new selection."); }
             deselectObject(false); selectedMesh = obj; selectedObjectData = data; transformControls.attach(obj); outlinePass.selectedObjects = [obj]; selectedFaceIndex = 0;

            let initialMode = 'translate';
            let canRotate = (!obj.userData.isMarker && !obj.userData.isPrefab && (!obj.userData.isSprite || !(data?.autoRotate ?? true))) || (obj.userData.isPrefab && data?.type === 'elevator') || (obj.userData.isMarker && data?.type !== 'level_trigger');
            let canScale = (obj.userData.isGeometry || obj.userData.isSprite) && !obj.userData.isPrefab;

            if (lastGizmoMode === 'rotate' && canRotate) initialMode = 'rotate';
            else if (lastGizmoMode === 'scale' && canScale) initialMode = 'scale';

            setGizmoMode(initialMode, false); updateSelectedObjectUI();
            dom.deleteObject.disabled = false; dom.cloneObject.disabled = false;
            const canApplyTex = obj.userData.isGeometry;
            dom.applyTexture.disabled = !canApplyTex; dom.applyTextureAll.disabled = !(canApplyTex && data?.type === 'box'); dom.applyTextureSprite.disabled = !obj.userData.isSprite;
            render();
        }
        function deselectObject(renderUpdate = true) {
            if (!selectedMesh) return; if (animationPreviewState.isPlaying && animationPreviewState.mesh === selectedMesh) { resetToInitialTransform(animationPreviewState.mesh); animationPreviewState.isPlaying = false; showStatus("Animation preview stopped due to deselection."); }
            transformControls.detach(); outlinePass.selectedObjects = []; selectedMesh = null; selectedObjectData = null; selectedFaceIndex = 0; updateSelectedObjectUI();
            dom.deleteObject.disabled = true; dom.cloneObject.disabled = true; dom.applyTexture.disabled = true; dom.applyTextureAll.disabled = true; dom.applyTextureSprite.disabled = true;
            setGizmoMode('translate', false); if (renderUpdate) render();
        }
        function cycleTransformMode(modes = ['rotate', 'scale']) {
             if (!selectedMesh) return; let availableModes = [];
             let canRotate = (!selectedMesh.userData.isMarker && !selectedMesh.userData.isPrefab && (!selectedMesh.userData.isSprite || !(selectedObjectData?.autoRotate ?? true))) || (selectedMesh.userData.isPrefab && selectedObjectData?.type === 'elevator') || (selectedMesh.userData.isMarker && selectedObjectData?.type !== 'level_trigger');
             let canScale = (selectedMesh.userData.isGeometry || selectedMesh.userData.isSprite) && !selectedMesh.userData.isPrefab;

            if (modes.includes('rotate') && canRotate) availableModes.push('rotate');
            if (modes.includes('scale') && canScale) availableModes.push('scale');
            if (availableModes.length === 0) return;
            const currentMode = transformControls.getMode(); let nextMode = availableModes[0]; const currentIndex = availableModes.indexOf(currentMode); if (currentIndex !== -1) nextMode = availableModes[(currentIndex + 1) % availableModes.length]; setGizmoMode(nextMode, true);
        }
        function updateModeInfoUI(activeMode) {
            const buttons = { translate: dom.modeTranslate, rotate: dom.modeRotate, scale: dom.modeScale };
            let canTranslate = selectedMesh != null;
            let canRotate = selectedMesh && ((!selectedMesh.userData.isMarker && !selectedMesh.userData.isPrefab && (!selectedMesh.userData.isSprite || !(selectedObjectData?.autoRotate ?? true))) || (selectedMesh.userData.isPrefab && selectedObjectData?.type === 'elevator') || (selectedMesh.userData.isMarker && selectedObjectData?.type !== 'level_trigger'));
            let canScale = selectedMesh && (selectedMesh.userData.isGeometry || selectedMesh.userData.isSprite) && !selectedMesh.userData.isPrefab;

            buttons.translate.disabled = !canTranslate; buttons.rotate.disabled = !canRotate; buttons.scale.disabled = !canScale;
            for (const mode in buttons) { if (buttons[mode]) buttons[mode].classList.toggle('active', mode === activeMode && !buttons[mode].disabled); }
            if (dom.currentModeInfo) { dom.currentModeInfo.style.display = selectedMesh ? 'block' : 'none'; dom.currentModeInfo.textContent = selectedMesh && activeMode ? `Mode: ${activeMode.charAt(0).toUpperCase() + activeMode.slice(1)}` : ''; }
        }
        function onObjectTransform() {
            if (!selectedObjectData || !selectedMesh) return; selectedObjectData.position = selectedMesh.position.toArray();
            if (selectedMesh.userData.isSprite) {
                const isFixedRotation = !(selectedObjectData?.autoRotate ?? true); if (isFixedRotation && transformControls.getMode() === 'rotate') selectedObjectData.rotation = selectedMesh.rotation.toArray().slice(0, 3);
                const currentScale = selectedMesh.scale; let newScaleX = Math.max(MIN_SCALE, Math.abs(currentScale.x)) * Math.sign(currentScale.x || 1); let newScaleY = Math.max(MIN_SCALE, Math.abs(currentScale.y)) * Math.sign(currentScale.y || 1);
                selectedObjectData.scale = [newScaleX, newScaleY, 1.0]; selectedMesh.scale.set(newScaleX, newScaleY, 1.0);
            } else if (selectedMesh.userData.isMarker || selectedMesh.userData.isPrefab) {

                 selectedObjectData.rotationY = selectedMesh.rotation.y;

                 if(Math.abs(selectedMesh.rotation.x) > 0.001 || Math.abs(selectedMesh.rotation.z) > 0.001) {
                     selectedMesh.rotation.x = 0;
                     selectedMesh.rotation.z = 0;
                 }

                 selectedMesh.scale.set(1, 1, 1);
                 if(selectedObjectData.scale) selectedObjectData.scale = [1, 1, 1];
             }
             else {
                selectedObjectData.rotation = selectedMesh.rotation.toArray().slice(0, 3); const currentScale = selectedMesh.scale;
                let newScaleX = Math.max(MIN_SCALE, Math.abs(currentScale.x)) * Math.sign(currentScale.x || 1); let newScaleY = Math.max(MIN_SCALE, Math.abs(currentScale.y)) * Math.sign(currentScale.y || 1); let newScaleZ = Math.max(MIN_SCALE, Math.abs(currentScale.z)) * Math.sign(currentScale.z || 1);
                const isPlane = selectedObjectData?.type === 'plane';
                if (transformControls.getMode() === 'scale') { if (isShiftPressed && !isPlane) { const uniformScale = Math.max(MIN_SCALE, Math.max(Math.abs(newScaleX), Math.abs(newScaleY), Math.abs(newScaleZ))); newScaleX = uniformScale * Math.sign(currentScale.x || 1); newScaleY = uniformScale * Math.sign(currentScale.y || 1); newScaleZ = uniformScale * Math.sign(currentScale.z || 1); } else if (isPlane) newScaleZ = selectedObjectData.scale[2] || MIN_SCALE; }
                selectedObjectData.scale = [newScaleX, newScaleY, newScaleZ]; selectedMesh.scale.set(newScaleX, newScaleY, newScaleZ);
            } updateSelectedObjectUI(false);
        }
        function updateSelectedObjectUI(fullUpdate = true) {
            const show = (elem, display = 'block') => elem.style.display = display; const hide = (elem) => elem.style.display = 'none';
            if (fullUpdate) { dom.selectedPrefabProps.innerHTML = ''; dom.selectedSpawnerProps.innerHTML = ''; }
            hide(dom.selectedPrefabProps); hide(dom.selectedSpawnerProps); hide(dom.geometryProps); hide(dom.spriteProps); hide(dom.animationProps); hide(dom.rotationSection); hide(dom.scaleSection); hide(dom.faceSelector); hide(dom.textureProps); hide(dom.applyTextureContainer); hide(dom.applyTextureContainerSprite);
            if (selectedObjectData && selectedMesh) {
                show(dom.selectedObjectInfo); dom.selectedObjectType.textContent = `Type: ${selectedObjectData.type || 'Unknown'}`;
                dom.selectedPosX.value = selectedObjectData.position[0].toFixed(2); dom.selectedPosY.value = selectedObjectData.position[1].toFixed(2); dom.selectedPosZ.value = selectedObjectData.position[2].toFixed(2);
                const isGeometry = selectedMesh.userData.isGeometry; const isSprite = selectedMesh.userData.isSprite; const isMarker = selectedMesh.userData.isMarker; const isPrefab = selectedMesh.userData.isPrefab;
                const isPlane = selectedObjectData?.type === 'plane'; const isBox = selectedObjectData?.type === 'box'; const isFixedRotation = isSprite && !(selectedObjectData.autoRotate ?? true);
                const showRotation = isGeometry || isMarker || isPrefab || isSprite; if(showRotation) show(dom.rotationSection);
                if (showRotation) { let rotX = 0, rotY = 0, rotZ = 0;
                    if (isMarker || isPrefab) {
                        rotY = selectedObjectData.rotationY || 0;
                    } else {
                        const rotSource = selectedObjectData.rotation || [0,0,0]; rotX = rotSource[0]; rotY = rotSource[1]; rotZ = rotSource[2];
                    }
                    dom.selectedRotX.value = THREE.MathUtils.radToDeg(rotX).toFixed(1); dom.selectedRotY.value = THREE.MathUtils.radToDeg(rotY).toFixed(1); dom.selectedRotZ.value = THREE.MathUtils.radToDeg(rotZ).toFixed(1);

                    dom.selectedRotX.disabled = isMarker || isPrefab;
                    dom.selectedRotY.disabled = (isSprite && !isFixedRotation);
                    dom.selectedRotZ.disabled = isMarker || isPrefab;
                }
                const showScale = isGeometry || isSprite; if(showScale) show(dom.scaleSection);
                if (showScale) { dom.selectedScaleX.value = selectedObjectData.scale[0].toFixed(2); dom.selectedScaleY.value = selectedObjectData.scale[1].toFixed(2); dom.selectedScaleZ.value = isSprite ? (1.0).toFixed(2) : selectedObjectData.scale[2].toFixed(2); dom.selectedScaleX.disabled = isMarker || isPrefab; dom.selectedScaleY.disabled = isMarker || isPrefab; dom.selectedScaleZ.disabled = isMarker || isPrefab || isPlane || isSprite; }
                if (isGeometry) {
                    show(dom.geometryProps); show(dom.applyTextureContainer, 'flex'); show(dom.textureProps);
                    dom.selectedIsCollider.checked = selectedObjectData.isCollider ?? !isPlane; dom.selectedIsCollider.disabled = false; dom.applyTextureAll.disabled = !isBox; dom.applyTexture.textContent = isBox ? "Apply to Face" : "Apply Texture";
                    let currentMatData = null; let currentTexPath = "";
                    if (isBox) { show(dom.faceSelector, 'grid'); dom.faceSelector.querySelectorAll('button').forEach((btn, index) => btn.classList.toggle('active', index === selectedFaceIndex)); currentMatData = selectedObjectData.materials?.[selectedFaceIndex]; } else currentMatData = selectedObjectData.material;
                    dom.texScaleU.value = currentMatData?.scale?.[0] ?? DEFAULT_TEX_SCALE[0]; dom.texScaleV.value = currentMatData?.scale?.[1] ?? DEFAULT_TEX_SCALE[1]; dom.texOffsetU.value = currentMatData?.offset?.[0] ?? DEFAULT_TEX_OFFSET[0]; dom.texOffsetV.value = currentMatData?.offset?.[1] ?? DEFAULT_TEX_OFFSET[1];
                    currentTexPath = currentMatData?.ref || ""; const textureItem = dom.textureGrid.querySelector(`.textureItem[data-texture-path="${CSS.escape(currentTexPath)}"]`);
                    if (textureItem && !textureItem.classList.contains('selected')) selectTextureItem(textureItem); else if (!textureItem && currentTexPath !== selectedTexturePath) { const noneItem = dom.textureGrid.querySelector('.textureItem[data-texture-path=""]'); if (noneItem && !noneItem.classList.contains('selected')) selectTextureItem(noneItem); }
                    show(dom.animationProps); const anim = selectedObjectData.animation; const animType = anim?.type || 'translate'; dom.animType.value = animType;
                    dom.animTargetPosX.value = anim?.targetPosition?.[0]?.toFixed(2) ?? ''; dom.animTargetPosY.value = anim?.targetPosition?.[1]?.toFixed(2) ?? ''; dom.animTargetPosZ.value = anim?.targetPosition?.[2]?.toFixed(2) ?? '';
                    dom.animTargetRotX.value = THREE.MathUtils.radToDeg(anim?.targetRotation?.[0] ?? 0).toFixed(1); dom.animTargetRotY.value = THREE.MathUtils.radToDeg(anim?.targetRotation?.[1] ?? 0).toFixed(1); dom.animTargetRotZ.value = THREE.MathUtils.radToDeg(anim?.targetRotation?.[2] ?? 0).toFixed(1);
                    dom.animDuration.value = anim?.duration ?? 1.0; dom.animLoop.value = anim?.loop || 'once'; dom.animAutoStart.checked = anim?.autoStart ?? false; dom.animTriggerId.value = anim?.triggerId || ''; updateAnimationUIFields(animType);
                }
                if (isSprite) {
                    show(dom.spriteProps); show(dom.applyTextureContainerSprite, 'flex');
                    dom.selectedFixedRotation.checked = isFixedRotation; dom.selectedSizeAttenuation.checked = selectedObjectData.sizeAttenuation ?? false; dom.selectedDepthWrite.checked = selectedObjectData.depthWrite ?? false;
                    dom.selectedAlphaTest.value = (selectedObjectData.alphaTest ?? 0.5).toFixed(2); dom.selectedCenterX.value = (selectedObjectData.center?.[0] ?? 0.5).toFixed(1); dom.selectedCenterY.value = (selectedObjectData.center?.[1] ?? 0.0).toFixed(1); dom.selectedTintColor.value = selectedObjectData.tintColor || '#ffffff';
                    const spriteTexPath = selectedObjectData.materialRef || ""; const spriteTextureItem = dom.textureGrid.querySelector(`.textureItem[data-texture-path="${CSS.escape(spriteTexPath)}"]`);
                    if (spriteTextureItem && !spriteTextureItem.classList.contains('selected')) selectTextureItem(spriteTextureItem); else if (!spriteTextureItem && spriteTexPath !== selectedTexturePath) { const noneItem = dom.textureGrid.querySelector('.textureItem[data-texture-path=""]'); if (noneItem && !noneItem.classList.contains('selected')) selectTextureItem(noneItem); }
                }
                if ((isMarker || isPrefab) && fullUpdate) {
                    const updatePropInput = (id, prop) => { const el = document.getElementById(id); if(el) el.addEventListener('input', (e) => { if(selectedObjectData) selectedObjectData[prop] = e.target.value || null; }); };
                     const updatePropConfigInput = (id, prop, isNumber = false) => { const el = document.getElementById(id); if(el) el.addEventListener('input', (e) => { if(selectedObjectData) { if (!selectedObjectData.config) selectedObjectData.config = {}; selectedObjectData.config[prop] = isNumber ? parseFloat(e.target.value) : (e.target.value || null); console.log(selectedObjectData.config)  } }); };
                    const updatePropSelect = (id, prop, statusMsg) => { const el = document.getElementById(id); if(el) el.addEventListener('change', (e) => { if(selectedObjectData) { selectedObjectData[prop] = e.target.value; if(statusMsg) showStatus(statusMsg); } }); };
                    if (prefabTypes.includes(selectedObjectData.type)) {
                        show(dom.selectedPrefabProps); dom.selectedPrefabProps.innerHTML = '<h4>Prefab Properties</h4>';
                        if (selectedObjectData.type === 'door') { dom.selectedPrefabProps.innerHTML += `<label for="prop_reqKey">Required Key ID (optional):</label><input type="text" id="prop_reqKey" value="${selectedObjectData.requiredKey || ''}">`; setTimeout(() => updatePropInput('prop_reqKey', 'requiredKey'), 0); }
                         else if (selectedObjectData.type === 'elevator') {
                             dom.selectedPrefabProps.innerHTML += `<label for="prop_elevWidth">Width:</label><input type="number" step="0.1" id="prop_elevWidth" value="${selectedObjectData.config?.width || 1.8}">`;
                             dom.selectedPrefabProps.innerHTML += `<label for="prop_elevHeight">Height:</label><input type="number" step="0.1" id="prop_elevHeight" value="${selectedObjectData.config?.height || 2.4}">`;
                             dom.selectedPrefabProps.innerHTML += `<label for="prop_elevDepth">Depth:</label><input type="number" step="0.1" id="prop_elevDepth" value="${selectedObjectData.config?.depth || 1.6}">`;
                             dom.selectedPrefabProps.innerHTML += `<small>(Rebuilding model on config change not yet implemented)</small>`;
                             setTimeout(() => {
                                 updatePropConfigInput('prop_elevWidth', 'width', true);
                                 updatePropConfigInput('prop_elevHeight', 'height', true);
                                 updatePropConfigInput('prop_elevDepth', 'depth', true);
                              }, 0);
                         }
                    } else if (spawnerTypes.includes(selectedObjectData.type)) {
                        show(dom.selectedSpawnerProps); dom.selectedSpawnerProps.innerHTML = '<h4>Spawner Properties</h4>';
                        if (selectedObjectData.type === 'item') { dom.selectedSpawnerProps.innerHTML += `<label for="prop_itemType">Item Type:</label><select id="prop_itemType">${itemTypes.map(t => `<option value="${t}" ${selectedObjectData.itemType === t ? 'selected' : ''}>${t}</option>`).join('')}</select>`; dom.selectedSpawnerProps.innerHTML += `<label for="prop_itemId">Unique Item ID:</label><input type="text" id="prop_itemId" value="${selectedObjectData.itemId || ''}">`; setTimeout(() => { updatePropSelect('prop_itemType', 'itemType', "Item type updated."); updatePropInput('prop_itemId', 'itemId'); }, 0); }
                        else if (selectedObjectData.type === 'enemy') { dom.selectedSpawnerProps.innerHTML += `<label for="prop_enemyType">Enemy Type:</label><select id="prop_enemyType">${enemyTypes.map(t => `<option value="${t}" ${selectedObjectData.enemyType === t ? 'selected' : ''}>${t}</option>`).join('')}</select>`; setTimeout(() => updatePropSelect('prop_enemyType', 'enemyType', "Enemy type updated."), 0); }
                        else if (selectedObjectData.type === 'level_trigger') { dom.selectedSpawnerProps.innerHTML += `<label for="prop_targetLevel">Target Level File:</label><input type="text" id="prop_targetLevel" value="${selectedObjectData.targetLevel || ''}">`; dom.selectedSpawnerProps.innerHTML += `<div><label>Trigger Area:</label><small>Defined by game logic.</small></div>`; setTimeout(() => updatePropInput('prop_targetLevel', 'targetLevel'), 0); }
                        else if (selectedObjectData.type === 'player_start') dom.selectedSpawnerProps.innerHTML += `<div><label>Facing Direction:</label><small>Set by marker Y rotation.</small></div>`;
                    }
                }
            } else { hide(dom.selectedObjectInfo); updateModeInfoUI('translate'); }
        }
        function updateSelectedDataFromUI(event) {
             if (!selectedObjectData || !selectedMesh) return; const sourceElementId = event?.target?.id;
             const isGeometry = selectedMesh.userData.isGeometry; const isSprite = selectedMesh.userData.isSprite; const isMarker = selectedMesh.userData.isMarker; const isPrefab = selectedMesh.userData.isPrefab;
             const isPlane = selectedObjectData?.type === 'plane'; const isBox = selectedObjectData?.type === 'box';
             const getFloat = (id) => parseFloat(dom[id].value) || 0; const getClamp = (id, min, max, def) => Math.max(min, Math.min(max, parseFloat(dom[id].value) || def)); const getDeg = (id) => THREE.MathUtils.degToRad(getFloat(id));

             selectedObjectData.position = [getFloat('selectedPosX'), getFloat('selectedPosY'), getFloat('selectedPosZ')]; selectedMesh.position.fromArray(selectedObjectData.position);
             if (isSprite) {
                 const isFixedRotation = dom.selectedFixedRotation.checked; selectedObjectData.autoRotate = !isFixedRotation;
                 if (sourceElementId === 'selectedFixedRotation' || (sourceElementId?.startsWith('selectedRot') && isFixedRotation)) {
                     selectedObjectData.rotation = [getDeg('selectedRotX'), getDeg('selectedRotY'), getDeg('selectedRotZ')]; _tempEuler.fromArray(selectedObjectData.rotation); selectedMesh.quaternion.setFromEuler(_tempEuler);
                 } else if (!isFixedRotation) {
                     selectedObjectData.rotation = [0, getDeg('selectedRotY'), 0];
                     selectedMesh.rotation.y = selectedObjectData.rotation[1];
                     selectedMesh.rotation.x = 0; selectedMesh.rotation.z = 0;
                 } else { selectedMesh.quaternion.identity(); }
             } else if (isGeometry) { selectedObjectData.rotation = [getDeg('selectedRotX'), getDeg('selectedRotY'), getDeg('selectedRotZ')]; selectedMesh.rotation.fromArray(selectedObjectData.rotation); selectedMesh.quaternion.setFromEuler(selectedMesh.rotation); }
              else if (isMarker || isPrefab) {
                  const newRotY = getDeg('selectedRotY'); selectedObjectData.rotationY = newRotY; selectedMesh.rotation.y = newRotY;

                  selectedMesh.rotation.x = 0; selectedMesh.rotation.z = 0;
              }
              if (isGeometry || isSprite) {
                   let scaleX = Math.max(MIN_SCALE, getFloat('selectedScaleX') || MIN_SCALE); let scaleY = Math.max(MIN_SCALE, getFloat('selectedScaleY') || MIN_SCALE); let scaleZ = isSprite ? 1.0 : (isPlane ? (selectedObjectData.scale[2] || MIN_SCALE) : Math.max(MIN_SCALE, getFloat('selectedScaleZ') || MIN_SCALE));
                   selectedObjectData.scale = [scaleX, scaleY, scaleZ]; selectedMesh.scale.set(scaleX, scaleY, scaleZ);
               } else if (isMarker || isPrefab) {

                   selectedObjectData.scale = [1, 1, 1]; selectedMesh.scale.set(1, 1, 1);
               }
              if (isGeometry) {
                  selectedObjectData.isCollider = dom.selectedIsCollider.checked; selectedMesh.userData.isCollider = selectedObjectData.isCollider;
                  const scaleU = getFloat('texScaleU') || 1; const scaleV = getFloat('texScaleV') || 1; const offsetU = getFloat('texOffsetU'); const offsetV = getFloat('texOffsetV');
                  let targetMaterial; let targetMatData;
                  if (isBox && selectedFaceIndex >= 0 && selectedFaceIndex < 6 && selectedObjectData.materials) { targetMatData = selectedObjectData.materials[selectedFaceIndex]; targetMaterial = selectedMesh.material[selectedFaceIndex]; }
                  else if (isPlane) { targetMatData = selectedObjectData.material; targetMaterial = selectedMesh.material; }
                  if (targetMatData) { targetMatData.scale = [scaleU, scaleV]; targetMatData.offset = [offsetU, offsetV]; } if (targetMaterial) updateMaterialTextureTransform(targetMaterial, [scaleU, scaleV], [offsetU, offsetV]);
                  const animType = dom.animType.value; const hasTargetPos = dom.animTargetPosX.value.trim() !== ''; const hasTargetRot = dom.animTargetRotX.value.trim() !== '';
                  if (hasTargetPos || hasTargetRot) {
                      if (!selectedObjectData.animation) selectedObjectData.animation = {}; selectedObjectData.animation.type = animType;
                      if (animType === 'translate' && hasTargetPos) { selectedObjectData.animation.targetPosition = [getFloat('animTargetPosX'), getFloat('animTargetPosY'), getFloat('animTargetPosZ')]; delete selectedObjectData.animation.targetRotation; }
                      else if (animType === 'rotate' && hasTargetRot) { selectedObjectData.animation.targetRotation = [getDeg('animTargetRotX'), getDeg('animTargetRotY'), getDeg('animTargetRotZ')]; delete selectedObjectData.animation.targetPosition; }
                      else { delete selectedObjectData.animation.targetPosition; delete selectedObjectData.animation.targetRotation; }
                      selectedObjectData.animation.duration = Math.max(0.1, getFloat('animDuration') || 1.0); selectedObjectData.animation.loop = dom.animLoop.value; selectedObjectData.animation.autoStart = dom.animAutoStart.checked; selectedObjectData.animation.triggerId = dom.animTriggerId.value.trim() || null;
                  } else selectedObjectData.animation = null; updateAnimationUIFields(animType);
              }
              if (isSprite) {
                  selectedObjectData.sizeAttenuation = dom.selectedSizeAttenuation.checked; selectedObjectData.depthWrite = dom.selectedDepthWrite.checked; selectedObjectData.alphaTest = getClamp('selectedAlphaTest', 0, 1, 0.5);
                  selectedObjectData.center = [getClamp('selectedCenterX', 0, 1, 0.5), getClamp('selectedCenterY', 0, 1, 0.0)]; selectedObjectData.tintColor = dom.selectedTintColor.value || '#ffffff';
                  selectedMesh.center.fromArray(selectedObjectData.center);
                  if (selectedMesh.material && selectedMesh.material.isSpriteMaterial) { selectedMesh.material.color.set(selectedObjectData.tintColor); selectedMesh.material.sizeAttenuation = selectedObjectData.sizeAttenuation; selectedMesh.material.depthWrite = selectedObjectData.depthWrite; selectedMesh.material.alphaTest = selectedObjectData.alphaTest; selectedMesh.material.transparent = (selectedObjectData.alphaTest < 1.0); selectedMesh.material.needsUpdate = true; }
                  else selectedMesh.material = getMaterial(selectedObjectData.materialRef, true, selectedObjectData);
                  if (sourceElementId === 'selectedFixedRotation' || sourceElementId?.startsWith('selectedRot')) { updateSelectedObjectUI(false); setGizmoMode(transformControls.getMode(), false); }
              } render();
          }
        function updateAnimationUIFields(animType) { dom.animTargetPos.style.display = animType === 'translate' ? 'block' : 'none'; dom.animTargetRot.style.display = animType === 'rotate' ? 'block' : 'none'; }
        function setAnimationTarget() {
            if (!selectedMesh || !selectedObjectData || !selectedMesh.userData.isGeometry) return; if (!selectedObjectData.animation) selectedObjectData.animation = {};
            const animType = dom.animType.value; selectedObjectData.animation.type = animType; const initialPos = selectedMesh.userData.initialPosition; const initialRot = selectedMesh.userData.initialRotation; const currentPos = selectedMesh.position; const currentRot = selectedMesh.rotation;
            if (animType === 'translate') { const targetPosOffset = currentPos.clone().sub(initialPos); selectedObjectData.animation.targetPosition = targetPosOffset.toArray(); delete selectedObjectData.animation.targetRotation; showStatus("Target position offset set."); }
            else if (animType === 'rotate') { selectedObjectData.animation.targetRotation = [currentRot.x, currentRot.y, currentRot.z]; delete selectedObjectData.animation.targetPosition; showStatus("Target absolute rotation set."); }
            selectedObjectData.animation.duration = Math.max(0.1, parseFloat(dom.animDuration.value) || 1.0); selectedObjectData.animation.loop = dom.animLoop.value; selectedObjectData.animation.autoStart = dom.animAutoStart.checked; selectedObjectData.animation.triggerId = dom.animTriggerId.value.trim() || null; updateSelectedObjectUI();
        }
        function clearAnimationData() {
            if (!selectedObjectData || !selectedMesh.userData.isGeometry) return; if (animationPreviewState.isPlaying && animationPreviewState.mesh === selectedMesh) { resetToInitialTransform(selectedMesh); animationPreviewState.isPlaying = false; transformControls.attach(selectedMesh); }
            selectedObjectData.animation = null; updateSelectedObjectUI(); showStatus("Animation data cleared.");
        }
        function resetToInitialTransform(mesh) {
            if (!mesh || !mesh.userData.initialPosition) return; mesh.position.copy(mesh.userData.initialPosition);
            if (mesh.userData.isGeometry && mesh.userData.initialRotation) { mesh.rotation.copy(mesh.userData.initialRotation); mesh.quaternion.setFromEuler(mesh.rotation); }
             else if (mesh.userData.isMarker || mesh.userData.isPrefab) { const objData = findObjectDataById(mesh.userData.dataId); mesh.rotation.y = objData?.rotationY || 0; mesh.rotation.x = 0; mesh.rotation.z = 0; }
            else if (mesh.isSprite) { const spriteData = findObjectDataById(mesh.userData.dataId); if (spriteData) { if (spriteData.autoRotate) { mesh.quaternion.identity(); } else if (spriteData.rotation) { _tempEuler.fromArray(spriteData.rotation); mesh.quaternion.setFromEuler(_tempEuler); } else { mesh.quaternion.identity(); } } } render();
        }
        function previewAnimation() {
            if (animationPreviewState.isPlaying) { if (animationPreviewState.mesh) { resetToInitialTransform(animationPreviewState.mesh); if(selectedMesh === animationPreviewState.mesh) transformControls.attach(animationPreviewState.mesh); } animationPreviewState.isPlaying = false; showStatus("Preview stopped."); return; }
            if (!selectedMesh || !selectedObjectData?.animation || !selectedMesh.userData.isGeometry) { showStatus("Select geometry with valid animation data.", 4000); return; }
            const anim = selectedObjectData.animation; const mesh = selectedMesh; resetToInitialTransform(mesh);
            animationPreviewState.mesh = mesh; animationPreviewState.isPlaying = true; animationPreviewState.startTime = performance.now(); animationPreviewState.duration = (anim.duration || 1.0) * 1000; animationPreviewState.type = anim.type; animationPreviewState.loop = anim.loop || 'once'; animationPreviewState.direction = 1;
            if (anim.type === 'translate' && anim.targetPosition) { animationPreviewState.startPos = mesh.userData.initialPosition.clone(); animationPreviewState.targetPos = mesh.userData.initialPosition.clone().add(new THREE.Vector3().fromArray(anim.targetPosition)); animationPreviewState.startRot = null; animationPreviewState.targetRot = null; }
            else if (anim.type === 'rotate' && anim.targetRotation) { animationPreviewState.startPos = null; animationPreviewState.targetPos = null; animationPreviewState.startRot = new THREE.Quaternion().setFromEuler(mesh.userData.initialRotation); animationPreviewState.targetRot = new THREE.Quaternion().setFromEuler(new THREE.Euler().fromArray(anim.targetRotation)); }
            else { showStatus("Invalid animation data for preview.", 4000); animationPreviewState.isPlaying = false; return; }
            transformControls.detach(); showStatus("Playing animation preview...");
        }
        function onKeyDown(event) {
            const activeElement = document.activeElement; const isInputFocused = activeElement && (activeElement.tagName === 'INPUT' || activeElement.tagName === 'SELECT' || activeElement.tagName === 'TEXTAREA');
            if (isInputFocused && event.key !== 'Escape') return; let targetMode = null;
            switch (event.key.toLowerCase()) {
                case 'g': targetMode = 'translate'; break; case 'r': targetMode = 'rotate'; break; case 's': targetMode = 'scale'; break;
                case ' ': event.preventDefault(); if (selectedMesh) cycleTransformMode(['rotate', 'scale']); return;
                case 'q': if (transformControls.object) { transformControls.setSpace(transformControls.space === "local" ? "world" : "local"); showStatus(`Gizmo space: ${transformControls.space}`, 1500); render(); } break;
                case 'delete': case 'backspace': if (!isInputFocused) deleteSelected(); break;
                case 'd': if (event.ctrlKey || event.metaKey) { event.preventDefault(); cloneSelected(); } break;
                case 'shift': isShiftPressed = true; if (transformControls.getMode() === 'scale' && transformControls.dragging) transformControls.setScaleSnap(null); break;
                case 'escape': deselectObject(); break; default: return;
            } if (targetMode) { event.preventDefault(); setGizmoMode(targetMode, true); }
        }
        function onKeyUp(event) {
            switch (event.key.toLowerCase()) {
                case 'shift': isShiftPressed = false; if (transformControls.getMode() === 'scale') { const snap = dom.snapToGrid.checked; transformControls.setScaleSnap(snap ? SNAP_SCALE : null); if (!transformControls.dragging) onObjectTransform(); } break;
            }
        }
        function exportLevelData() {
            const exportData = { levelName: "Custom Level", textures: {}, geometry: [], prefabs: [], spawners: [], sprites: [] }; const usedTextures = new Set();
            const processItem = (item, list) => { const copy = JSON.parse(JSON.stringify(item)); if (copy.type === 'box' && copy.materials) copy.materials.forEach(mat => { if (mat?.ref) usedTextures.add(mat.ref); }); else if (copy.material?.ref) usedTextures.add(copy.material.ref); else if (copy.materialRef) usedTextures.add(copy.materialRef); list.push(copy); };
            levelData.geometry.forEach(geo => processItem(geo, exportData.geometry)); levelData.sprites.forEach(sprite => processItem(sprite, exportData.sprites)); levelData.prefabs.forEach(prefab => exportData.prefabs.push(JSON.parse(JSON.stringify(prefab)))); levelData.spawners.forEach(spawner => exportData.spawners.push(JSON.parse(JSON.stringify(spawner))));

            if (levelData.prefabs.some(p => p.type === 'elevator')) { usedTextures.add('images/elevator_door.png'); usedTextures.add('images/elevator_wall.png'); usedTextures.add('images/elevator_floor.png'); usedTextures.add('images/elevator_ceiling.png'); }
            let textureCounter = 1; usedTextures.forEach(path => { const key = `tex${textureCounter.toString().padStart(2, '0')}`; exportData.textures[key] = path; textureCounter++; });
            const resolveRef = (refPath) => { for (const key in exportData.textures) if (exportData.textures[key] === refPath) return key; return null; };
            exportData.geometry.forEach(geo => { if (geo.type === 'box' && geo.materials) geo.materials.forEach(mat => { if(mat) mat.ref = resolveRef(mat.ref); }); else if (geo.material) geo.material.ref = resolveRef(geo.material.ref); });
            exportData.sprites.forEach(sprite => { sprite.materialRef = resolveRef(sprite.materialRef); });
            try { const jsonString = JSON.stringify(exportData, null, 2); const blob = new Blob([jsonString], { type: 'application/json' }); const link = document.createElement('a'); link.href = URL.createObjectURL(blob); const fileName = `${exportData.levelName.replace(/\s+/g, '_') || 'level'}.json`; link.download = fileName; link.click(); URL.revokeObjectURL(link.href); showStatus("Map exported successfully."); } catch (error) { console.error("Error during JSON export:", error); showStatus("Error exporting map!", 5000); }
        }
        function loadLevelDataFromFile(event) {
            const file = event.target.files[0]; if (!file) return; const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const jsonData = JSON.parse(e.target.result); clearScene(); if (!jsonData || typeof jsonData !== 'object') throw new Error("Invalid JSON structure.");
                    levelData.geometry = jsonData.geometry || []; levelData.prefabs = jsonData.prefabs || []; levelData.spawners = jsonData.spawners || []; levelData.sprites = jsonData.sprites || [];
                    const textureMap = jsonData.textures || {}; const resolveMaterialRef = (refKey) => textureMap[refKey] || null;
                    levelData.geometry.forEach(geoData => { if (geoData.type === 'box' && geoData.materials) geoData.materials.forEach(mat => { if (mat) mat.ref = resolveMaterialRef(mat.ref); }); else if (geoData.material) geoData.material.ref = resolveMaterialRef(geoData.material.ref); const mesh = createMeshFromData(geoData); if (mesh) scene.add(mesh); });
                    levelData.prefabs.forEach(prefabData => {
                        let prefabObject;
                        if (prefabData.type === 'elevator') {
                            prefabObject = createElevatorMesh(prefabData);
                        } else {
                            prefabObject = createMarkerMesh(prefabData);
                        }
                        if (prefabObject) scene.add(prefabObject);
                    });
                    levelData.spawners.forEach(spawnerData => { const marker = createMarkerMesh(spawnerData); if (marker) scene.add(marker); });
                    levelData.sprites.forEach(spriteData => { spriteData.materialRef = resolveMaterialRef(spriteData.materialRef); if (spriteData.autoRotate === undefined) spriteData.autoRotate = true; const sprite = createSpriteMesh(spriteData); if (sprite) scene.add(sprite); });
                    render(); showStatus("Map loaded successfully.");
                } catch (error) { console.error("Error loading map file:", error); alert(`Failed to load map file:\n${error.message}`); showStatus("Error loading map!", 5000); clearScene(); }
                finally { event.target.value = null; } };
            reader.onerror = (e) => { console.error("Error reading file:", e); alert("Failed to read map file."); showStatus("Error reading file!", 5000); event.target.value = null; };
            reader.readAsText(file);
        }
        function clearScene() {
            deselectObject(false); const objectsToRemove = scene.children.filter(child => child.userData.dataId && findObjectDataById(child.userData.dataId));
            objectsToRemove.forEach(obj => {
                 if (obj.isGroup) {
                     obj.traverse(child => {
                         if (child.geometry) child.geometry.dispose();
                         if (child.material) {
                            if (Array.isArray(child.material)) child.material.forEach(mat => { if (mat?.map) mat.map.dispose(); if(mat) mat.dispose(); });
                            else { if (child.material.map) child.material.map.dispose(); if (child.material.dispose) child.material.dispose(); }
                         }
                     });
                 } else {
                     if (obj.geometry) obj.geometry.dispose();
                     if (obj.material) {
                         if (Array.isArray(obj.material)) obj.material.forEach(mat => { if (mat?.map) mat.map.dispose(); if(mat) mat.dispose(); });
                         else { if (obj.material.map) obj.material.map.dispose(); if(obj.material.dispose) obj.material.dispose(); }
                     }
                 }
                 scene.remove(obj);
            });

            levelData = { geometry: [], prefabs: [], spawners: [], sprites: [] }; loadedTextures = {}; loadedMaterials = {}; loadedSpriteMaterials = {}; dom.toggleWireframe.checked = false; populateTextureUI(); render(); showStatus("Scene cleared.");
        }
        function showStatus(message, duration = STATUS_MESSAGE_DURATION) {
            if (!dom.statusBar) return; dom.statusBar.textContent = message; if (statusTimeout) clearTimeout(statusTimeout); statusTimeout = setTimeout(() => { if (dom.statusBar.textContent === message) dom.statusBar.textContent = '-'; statusTimeout = null; }, duration);
        }
        function animate() {
            requestAnimationFrame(animate); const delta = clock.getDelta(); orbitControls.update();
            if (animationPreviewState.isPlaying && animationPreviewState.mesh) {
                const now = performance.now(); let elapsed = (now - animationPreviewState.startTime); let progress = 0; let finished = false;
                if (animationPreviewState.loop === 'once') { progress = Math.min(elapsed / animationPreviewState.duration, 1.0); if (progress >= 1.0) finished = true; }
                else if (animationPreviewState.loop === 'loop') { elapsed = elapsed % animationPreviewState.duration; progress = elapsed / animationPreviewState.duration; }
                else if (animationPreviewState.loop === 'pingpong') { const cycleTime = animationPreviewState.duration * 2; elapsed = elapsed % cycleTime; if (elapsed > animationPreviewState.duration) { progress = 1.0 - ((elapsed - animationPreviewState.duration) / animationPreviewState.duration); animationPreviewState.direction = -1; } else { progress = elapsed / animationPreviewState.duration; animationPreviewState.direction = 1; } }
                const easedProgress = 0.5 - 0.5 * Math.cos(progress * Math.PI); const mesh = animationPreviewState.mesh;
                if (animationPreviewState.type === 'translate' && animationPreviewState.startPos && animationPreviewState.targetPos) mesh.position.lerpVectors(animationPreviewState.startPos, animationPreviewState.targetPos, easedProgress);
                else if (animationPreviewState.type === 'rotate' && animationPreviewState.startRot && animationPreviewState.targetRot) { THREE.Quaternion.slerp(animationPreviewState.startRot, animationPreviewState.targetRot, mesh.quaternion, easedProgress); mesh.rotation.setFromQuaternion(mesh.quaternion, mesh.rotation.order); }
                if (finished) { animationPreviewState.isPlaying = false; resetToInitialTransform(animationPreviewState.mesh); if (selectedMesh === animationPreviewState.mesh) transformControls.attach(animationPreviewState.mesh); showStatus("Preview finished."); }
            } render(delta);
        }
        function render(delta) {
             scene.traverse(obj => {
                 if (obj.isSprite && obj.userData.isSprite && camera) {
                    const spriteData = findObjectDataById(obj.userData.dataId); if (!spriteData) return;
                    const autoRotate = spriteData.autoRotate ?? true;
                    if (autoRotate) { camera.getWorldPosition(_camPos); obj.getWorldPosition(_spritePos); _targetDir.set(_camPos.x - _spritePos.x, 0, _camPos.z - _spritePos.z).normalize(); let angleY = Math.atan2(_targetDir.x, _targetDir.z); _spriteQuaternion.setFromAxisAngle(_yAxis, angleY); if (!obj.quaternion.equals(_spriteQuaternion)) obj.quaternion.copy(_spriteQuaternion); }
                    else { if (spriteData.rotation && Array.isArray(spriteData.rotation)) { _tempEuler.fromArray(spriteData.rotation); _spriteQuaternion.setFromEuler(_tempEuler); if (!obj.quaternion.equals(_spriteQuaternion)) obj.quaternion.copy(_spriteQuaternion); } else { if (!obj.quaternion.equals(_identityQuaternion)) obj.quaternion.identity(); } }
                 }
             }); if (composer) composer.render(delta); else renderer.render(scene, camera);
        }
        function onWindowResize() { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); composer.setSize(window.innerWidth, window.innerHeight); outlinePass.resolution.set(window.innerWidth, window.innerHeight); render(); }
        init();
    </script>
</body>
</html>