<!DOCTYPE html>
<html lang=en>
<head>
<meta charset=utf-8>
<title>Bunker v5 - No Skybox</title> <!-- Changed title slightly -->
<meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
<style>html,body{margin:0;padding:0;height:100%;overflow:hidden;background:#222;color:#fff;font-family:sans-serif}#mapCanvas{display:block;width:100vw;height:100vh;cursor:grab}#mapCanvas:active{cursor:grabbing}#loadingOverlay{position:absolute;top:0;left:0;right:0;bottom:0;background:#000;color:#fff;display:flex;align-items:center;justify-content:center;flex-direction:column;z-index:2000;font-family:'Courier New',Courier,monospace;text-align:center}#loadingOverlay.hide{display:none}</style>
</head>
<body>
<canvas id=mapCanvas></canvas>
<div id=loadingOverlay><h1>Load</h1><p id=loadingText>Init</p></div>
<script src=https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js></script><script src=https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js></script>
<script>
const TW=500,TH=500,TS=256,THS=25,CSZ=1,ISKC=.4,GTF=3,GWN=.6,GWX=1,GHN=1.2,GHX=1.6,GSN=.5,GSX=.8,BW=36,BD=24,BMH=14,BBH=16,BBOX=4,BBOZ=4,BCX=0,BCZ=-50,EW=BW*.4,ED=CSZ*15,ET=CSZ*10,DH=BBH*.6,DW=EW*.8,DTK=.6,DZOFB=.01;
const DOX=-DW/2,EBD=75,EHH=45;
const B_B=[{cx:BCX-15,cz:BCZ+10,r:10,h:2.8},{cx:BCX+16,cz:BCZ+8,r:12,h:3.5},{cx:BCX-18,cz:BCZ-10,r:9,h:2.2},{cx:BCX+20,cz:BCZ-12,r:11,h:3},{cx:BCX,cz:BCZ-18,r:8,h:1.8},{cx:BCX-22,cz:BCZ,r:7,h:2}];
const RHX=BCX,RHZ=BCZ-55,RHH=THS*1.3,RH_SX=4e-4,RH_SZ=7e-4,RH_EF=.9,RH_NF1=.035,RH_NA1=.15,RH_NF2=.09,RH_NA2=.08;
const {clamp:cl,lerp:lp,randFloat:rn}=THREE.MathUtils,{FrontSide:FS,DoubleSide:DS,BackSide:BS,RepeatWrapping:RW,ClampToEdgeWrapping:CE,NearestFilter:NF,sRGBEncoding:SE,EquirectangularReflectionMapping:ER}=THREE; // ER might be unused now
const {PI,max,min,sin,cos,exp,abs,sqrt,floor:flr}=Math;
const V=THREE.Vector3,MS=THREE.MeshStandardMaterial,MB=THREE.MeshBasicMaterial,CT=THREE.CanvasTexture,GP=THREE.Group,PG=THREE.PlaneGeometry,BG=THREE.BoxGeometry,SP=THREE.Sprite,SM=THREE.SpriteMaterial,BF=THREE.BufferGeometry,F32=Float32Array,M4=THREE.Matrix4,Q=THREE.Quaternion,E=THREE.Euler;
const ss=(t,n,x)=>{const v=cl( (t-n)/(x-n),0,1);return v*v*(3-2*v)},$=s=>document.getElementById(s);
// Removed 'sp':'images/sky.png' from aM
const aM={'gg':'images/GRASS_1A.png','wd':'images/dirt.png','dm':'images/bigdoor23.png','cw':'images/concretewall.png','dft':'images/trim2.png','t1':'images/tree.png','t2':'images/tree1.png','t3':'images/tree2.png','t4':'images/tree3.png','g1':'images/grass1.png','g2':'images/grass2.png','g3':'images/grass3.png','g4':'images/grass4.png','ik':'images/level1keycard.png','kr':'images/keycardreader.png','fa1':'images/foresta1.png','fa2':'images/foresta2.png','fa3':'images/foresta3.png','fa4':'images/foresta4.png','fa5':'images/foresta5.png','fa6':'images/foresta6.png'},sW={1:'wd',6:'cw'},dK='dm',gK='gg',tK=['t1','t2','t3','t4'],rK=['g1','g2','g3','g4'],faK=['fa1','fa2','fa3','fa4','fa5','fa6'];
let bD={bMY:0,bNX:0,bXX:0,bNZ:0,bXZ:0},A={},gM,dM,cM,iM,fM={t:[],r:[],fa:[]},kL=new V(10,0,-30),scn,cam,rnd,ctrl,ldM,txL,ldO,ldT,tM,tG,rG,faG,bG,eG,tV=new V(),dFrM,kRdM,kRdTexM,pthM=null;
const _q=new Q(),_m4=new M4(),_vS=new V(1,1,1),_vP=new V(),_e=new E();
const iLd=()=>{ldO=$("loadingOverlay");ldT=$("loadingText");txL=new THREE.TextureLoader(ldM=new THREE.LoadingManager(()=>{},(u,l,t)=>ldT.innerText=`Ld:${u.split('/').pop()}(${~~(l/t*100)}%)`,u=>ldT.innerText=`ERR:${u}`))}
// Removed specific check for 'sp' encoding, though it would be harmless if left
const ldA=()=>{ldT.innerText="LdA...";const nS=['norm','hgt','ao','rough','metal'];return Promise.all(Object.keys(aM).map(k=>new Promise(r=>{txL.load(aM[k],t=>{t.magFilter=t.minFilter=NF;t.generateMipmaps=!1;if(!nS.some(s=>k.includes(s))&&!aM[k].endsWith('.gif'))t.encoding=SE;A[k]=t;r()},()=>{const c=document.createElement('canvas');c.width=c.height=16;const x=c.getContext('2d');x.fillStyle='#F0F';x.fillRect(0,0,16,16);x.fillStyle='#000';x.fillRect(0,0,8,8);x.fillRect(8,8,8,8);const pt=new CT(c);pt.magFilter=pt.minFilter=NF;A[k]=pt;r()})}))) }
const cMa=()=>{const c={side:FS},cX=(k,rx=1,ry=1,w=RW)=>{const t=A[k];if(!t||t instanceof CT)return null;const tc=t.clone();tc.wrapS=tc.wrapT=w;tc.repeat.set(rx,ry);tc.needsUpdate=!0;return tc};let tx;gM=(tx=cX(gK,TW/GTF,TH/GTF))?new MS({map:tx,roughness:1,metalness:0,...c}):new MS({color:0x3a5f0b,...c});iM=(tx=cX(sW[1],EW/2,ED/2))?new MS({map:tx,roughness:.9,metalness:.1,...c}):new MS({color:0x8B4513,...c});cM=(tx=cX(sW[6]))?new MS({map:tx,roughness:.8,metalness:.1,...c}):new MS({color:0x808080,...c});dM=(tx=cX(dK,1,1,CE))?new MS({map:tx,roughness:.6,metalness:.4,...c}):new MS({color:0x555555,...c});const cF=k=>(tx=A[k])&&!(tx instanceof CT)?new MB({map:tx,color:0xFFFFFF,transparent:!0,side:DS,alphaTest:.5}):new MB({color:0xff00ff,transparent:!0,opacity:.5});const cFa=k=>(tx=A[k])&&!(tx instanceof CT)?new MB({map:tx,color:0xFFFFFF,transparent:!0,side:FS,depthWrite:!1}):new MB({color:0x00ff00,transparent:!0,opacity:.5});fM={t:tK.map(cF),r:rK.map(cF),fa:faK.map(cFa)};dFrM=(tx=cX('dft',1,1,CE))?new MS({map:tx,roughness:.7,metalness:.2,...c}):new MS({color:0xCD853F,roughness:.7,metalness:.2,...c});kRdM=new MS({color:0x444444,roughness:.3,metalness:.6,...c});kRdTexM=(tx=cX('kr',1,1,CE))?new MS({map:tx,roughness:.5,metalness:.5,...c}):null}
const gBH=(x,z)=>{const s=.009,a=THS,hcx1=BCX,hcz1=BCZ-15,dx1_b=x-hcx1,dz1_b=z-hcz1,d2_1_b=dx1_b*dx1_b*6e-4+dz1_b*dz1_b*3e-4,mH1=exp(-d2_1_b*1.2)*(a*.05);const hcx2=TW*.3,hcz2=TH*-.4,dx2_g=x-hcx2,dz2_g=z-hcz2,d2_2_g=dx2_g*dx2_g*2e-4+dz2_g*dz2_g*2e-4,mH2=exp(-d2_2_g*.8)*(a*.6);const hcx3=TW*-.35,hcz3=TH*-.6,dx3_g=x-hcx3,dz3_g=z-hcz3,d2_3_g=dx3_g*dx3_g*3e-4+dz3_g*dz3_g*2.5e-4,mH3=exp(-d2_3_g)*(a*.5);const baseNoiseAmp=a*.22,h1=sin(x*s*1.1+z*s*.4)*.3,h2=cos(x*s*.6-z*s*1.3)*.2,h3=sin(x*s*2.5+z*s*2.1)*.1;const s2=.025,h4=sin(x*s2*.8-z*s2*.5)*.15,h5=cos(x*s2*1.5+z*s2*1.1)*.1;const s3=.003,h6=cos(x*s3*1.2+z*s3*.9)*.4;const noiseH=(h1+h2+h3+h4+h5+h6)*baseNoiseAmp;const dx_rh=x-RHX,dz_rh=z-RHZ,d2_rh=dx_rh*dx_rh*RH_SX+dz_rh*dz_rh*RH_SZ,baseRearHillH=exp(-d2_rh*RH_EF)*RHH;const hillNoise1=sin(x*RH_NF1+z*RH_NF1*.6)*RH_NA1,hillNoise2=cos(x*RH_NF2*.7+z*RH_NF2)*RH_NA2;const totalHillNoiseFactor=1+hillNoise1+hillNoise2,rearHillH=max(0,baseRearHillH*totalHillNoiseFactor);const baseH=mH1+mH2+mH3+noiseH+rearHillH;let edgeHeightIncrease=0;const halfW=TW/2,halfH=TH/2,minDistToEdge=min(x+halfW,halfW-x,z+halfH,halfH-z);if(minDistToEdge<EBD){const blendFactor=1-cl(minDistToEdge/EBD,0,1),smoothBlend=ss(blendFactor,0,1),edgeHillModulation=cl(1-rearHillH/RHH*.5,.5,1);edgeHeightIncrease=smoothBlend*EHH*edgeHillModulation}return baseH+edgeHeightIncrease}
const gFH=(x,z)=>{if(!tM)return gBH(x,z);const g=tM.geometry,pa=g.attributes.position;if(!pa)return 0;const ws=g.parameters.widthSegments,hs=g.parameters.heightSegments,tw=g.parameters.width,th=g.parameters.height;const gx=(x+tw/2)/tw,gz=(z+th/2)/th,cgx=cl(gx,0,1),cgz=cl(gz,0,1);const xi=~~(cgx*ws),zi=~~(cgz*hs),v=(iz,ix)=>min(iz*(ws+1)+ix,pa.count-1);const i0=v(zi,xi),i1=v(zi,xi+1),i2=v(zi+1,xi),i3=v(zi+1,xi+1);if(i0>=pa.count||i1>=pa.count||i2>=pa.count||i3>=pa.count||i0<0||i1<0||i2<0||i3<0)try{return pa.getY(cl(v(zi,xi),0,pa.count-1))}catch{return 0}const y0=pa.getY(i0),y1=pa.getY(i1),y2=pa.getY(i2),y3=pa.getY(i3),tx=cgx*ws-xi,tz=cgz*hs-zi;return lp(lp(y0,y1,tx),lp(y2,y3,tx),tz)}
const cB=()=>{bG=new GP();const cx=BCX,cz=BCZ,baseW=BW+BBOX*2,baseD=BD+BBOZ*2,baseBottomY=0;bD={bMY:baseBottomY,bNX:cx-baseW/2,bXX:cx+baseW/2,bNZ:cz-baseD/2,bXZ:cz+baseD/2};const crMat=(rX,rY)=>{const m=cM.clone();if(m.map?.isTexture){m.map=cM.map.clone();m.map.repeat.set(~~rX,~~rY);m.map.needsUpdate=!0}return m};const baseMesh=new THREE.Mesh(new BG(baseW,BBH,baseD),crMat(baseW/1.8,BBH/1.4));baseMesh.position.set(cx,baseBottomY+BBH/2,cz);baseMesh.castShadow=baseMesh.receiveShadow=!1;bG.add(baseMesh);const mainMesh=new THREE.Mesh(new BG(BW,BMH,BD),crMat(BW/1.6,BMH/1.6));mainMesh.position.set(cx,baseBottomY+BBH+BMH/2,cz);mainMesh.castShadow=mainMesh.receiveShadow=!1;bG.add(mainMesh);const slopeGeom=new BF(),baseTopY=baseBottomY+BBH,slopeTargetY=baseTopY+BMH/4;const vertices=new F32([bD.bNX,baseTopY,bD.bXZ,bD.bXX,baseTopY,bD.bXZ,bD.bXX,baseTopY,bD.bNZ,bD.bNX,baseTopY,bD.bNZ,cx-BW/2,slopeTargetY,cz+BD/2,cx+BW/2,slopeTargetY,cz+BD/2,cx+BW/2,slopeTargetY,cz-BD/2,cx-BW/2,slopeTargetY,cz-BD/2]);const indices=[0,1,5,0,5,4,1,2,6,1,6,5,2,3,7,2,7,6,3,0,4,3,4,7],uvs=new F32(vertices.length/3*2);const uvScaleX=1/baseW,uvScaleZ=1/baseD;for(let i=0;i<vertices.length/3;i++){const vx=vertices[i*3],vz=vertices[i*3+2];uvs[i*2]=(vx-bD.bNX)*uvScaleX;uvs[i*2+1]=1-(vz-bD.bNZ)*uvScaleZ}slopeGeom.setAttribute('position',new THREE.BufferAttribute(vertices,3)).setAttribute('uv',new THREE.BufferAttribute(uvs,2)).setIndex(indices);slopeGeom.computeVertexNormals();const slopeMat=cM.clone();if(slopeMat.map?.isTexture){slopeMat.map=slopeMat.map.clone();slopeMat.map.repeat.set(~~(baseW/3.5),~~(baseD/6));slopeMat.map.needsUpdate=!0}const slopeMesh=new THREE.Mesh(slopeGeom,slopeMat);slopeMesh.castShadow=slopeMesh.receiveShadow=!1;bG.add(slopeMesh);scn.add(bG)}
// Modified cE function to remove skybox texture logic
const cE=()=>{
    // Set a solid background color instead of using the sky texture
    scn.background=new THREE.Color(0x6a8699);
    // Optionally set environment to null if you don't want reflections from the background color
    scn.environment = null;
    // Keep the fog
    scn.fog=new THREE.Fog(0x6a8699,60,400);

    // --- The rest of the cE function remains the same ---
    const tg=new PG(TW,TH,TS,TS);
    tg.rotateX(-PI/2);
    const p=tg.attributes.position;
    let tDX=BCX+DOX,pStartX=0,pEndX=0,pStartZ=0,pEndZ=0,pFloorY=0;
    if(bD?.bMY==0){pStartX=tDX-EW/2;pEndX=tDX+EW/2;pStartZ=bD.bXZ;pEndZ=pStartZ+ED;pFloorY=bD.bMY}
    const perturbationAmount=EW*.15,noiseFreq=.4;
    for(let i=0;i<p.count;i++){const vx=p.getX(i),vz=p.getZ(i);let baseCalculatedY=gBH(vx,vz),targetY=baseCalculatedY;if(bD?.bMY==0){const transStartX=bD.bNX-ET,transEndX=bD.bXX+ET,transStartZ=bD.bNZ-ET,transEndZ=bD.bXZ+ED+ET,bunkerBaseTopY=bD.bMY+BBH,blendDist=ET*3.5,moundHeightOffset=BBH*-.5,cornerBoostF=.2,cornerDist=ET*.8,sharpEdgeBD=2.5,sharpEdgeOffset=.05;let isInBunker=vx>=bD.bNX&&vx<=bD.bXX&&vz>=bD.bNZ&&vz<=bD.bXZ;let isInPath=!1;if(!isInBunker&&vz>=pStartZ&&vz<=pEndZ&&vx>=pStartX-perturbationAmount*1.5&&vx<=pEndX+perturbationAmount*1.5){const pathRelativeZ=vz-pStartZ,offset=sin(pathRelativeZ*noiseFreq)*perturbationAmount,currentHalfWidth=EW/2+abs(offset);if(abs(vx-tDX)<currentHalfWidth)isInPath=!0}if(isInPath){targetY=pFloorY}else if(isInBunker){targetY=bD.bMY-.1}else if(vx>=transStartX&&vx<=transEndX&&vz>=transStartZ&&vz<=transEndZ){let distBX=max(0,bD.bNX-vx,vx-bD.bXX),distBZ=max(0,bD.bNZ-vz,vz-bD.bXZ);let distPathX=0;if(vz>=pStartZ&&vz<=pEndZ)distPathX=max(0,pStartX-vx,vx-pEndX);let distPathZ=0;if(vz>pEndZ&&vx>=pStartX&&vx<=pEndX)distPathZ=vz-pEndZ;const distBEdge=max(distBX,distBZ,distPathX,distPathZ);if(distBEdge<blendDist){const wallBlendF=ss(1-cl(distBEdge/blendDist,0,1),0,1);let baseMoundTargetY=bunkerBaseTopY+moundHeightOffset;if(vz>bD.bNZ&&vz<bD.bXZ+cornerDist&&(vx<bD.bNX+cornerDist||vx>bD.bXX-cornerDist)){const cornerX=vx<BCX?bD.bNX:bD.bXX,cornerZ=bD.bXZ,distToCorner=sqrt((vx-cornerX)**2+(vz-cornerZ)**2);if(distToCorner<cornerDist*1.2){baseMoundTargetY+=BBH*.5*cornerBoostF*ss(1-cl(distToCorner/(cornerDist*1.2),0,1),0,1)}}let blobHeightAddition=0;for(const blob of B_B){const dxBlob=vx-blob.cx,dzBlob=vz-blob.cz,distSqBlob=dxBlob*dxBlob+dzBlob*dzBlob,radiusSq=blob.r*blob.r;if(distSqBlob<radiusSq){const distBlob=sqrt(distSqBlob);blobHeightAddition+=ss(1-distBlob/blob.r,0,1)*blob.h}}targetY=lp(baseCalculatedY,baseMoundTargetY+blobHeightAddition,wallBlendF)}if(distBEdge<sharpEdgeBD)targetY=lp(targetY,bunkerBaseTopY+sharpEdgeOffset,ss(1-distBEdge/sharpEdgeBD,0,1))}}p.setY(i,targetY)}
    p.needsUpdate=!0;tg.computeVertexNormals();tM=new THREE.Mesh(tg,gM);tM.receiveShadow=!1;scn.add(tM);
    if(pthM?.parent)pthM.parent.remove(pthM);
    if(bD?.bMY==0&&iM&&ED>0&&EW>0){const pW=EW,pD=ED,tpX=tDX,tpZ=pStartZ+pD/2;const pathWidthSegments=10,pathHeightSegments=max(4,flr(pD/1.5));const pG=new PG(pW,pD,pathWidthSegments,pathHeightSegments);pG.rotateX(-PI/2);const pathPos=pG.attributes.position,halfPW=pW/2,edgeThreshold=.1;for(let i=0;i<pathPos.count;i++){const x=pathPos.getX(i),z=pathPos.getZ(i);if(abs(x-halfPW)<edgeThreshold||abs(x+halfPW)<edgeThreshold){const offset=sin(z*noiseFreq+rn(-.5,.5))*perturbationAmount*rn(.6,1.1);let newX=x+offset;newX=x>0?max(x*.1,newX):min(x*.1,newX);pathPos.setX(i,newX)}}pathPos.needsUpdate=!0;pG.computeVertexNormals();const pathMat=iM.clone();if(pathMat.map?.isTexture){pathMat.map=pathMat.map.clone();pathMat.map.repeat.set(pW/3,pD/3);pathMat.map.needsUpdate=!0}pthM=new THREE.Mesh(pG,pathMat);pthM.position.set(tpX,pFloorY+.02,tpZ);pthM.receiveShadow=!1;scn.add(pthM)}
    const bp=new PG(1,1);tG=new GP();const tb=12,tv=4,tw=6,twv=2;const tP=[{x:-30,z:-70},{x:35,z:-80},{x:10,z:-95},{x:-25,z:-110},{x:40,z:-60},{x:-60,z:-90},{x:70,z:-120},{x:-100,z:-150},{x:120,z:-80},{x:0,z:-140},{x:-150,z:-100},{x:150,z:-180},{x:50,z:-200},{x:-80,z:-170},{x:180,z:-130},{x:-190,z:-160},{x:-120,z:-210},{x:100,z:-230},{x:20,z:-160},{x:-45,z:-145},{x:80,z:-100},{x:-90,z:-190}];tP.forEach(s=>{const isBnk=bD.bMY==0&&s.x>=bD.bNX&&s.x<=bD.bXX&&s.z>=bD.bNZ&&s.z<=bD.bXZ;const isPth=pFloorY==0&&s.x>=pStartX-perturbationAmount*1.2&&s.x<=pEndX+perturbationAmount*1.2&&s.z>=pStartZ&&s.z<=pEndZ;if(isBnk||isPth)return;const y=gFH(s.x,s.z);if(y<-1||y>max(EHH*.8,RHH*.9))return;const h=tb+rn(0,tv),w=tw+rn(0,twv);const m=fM.t[~~rn(0,fM.t.length)];if(!m)return;const mh=new THREE.Mesh(bp,m);mh.scale.set(w,h,1);mh.position.set(s.x,y+h/2-.2,s.z);mh.castShadow=mh.receiveShadow=!1;mh.onBeforeRender=()=>{tV.setFromMatrixPosition(cam.matrixWorld);mh.lookAt(tV.x,mh.position.y+1,tV.z)};tG.add(mh)});scn.add(tG);
    rG=new GP();const nG=850,gP=5,gS=4,mxInst=nG*gP*3;if(fM.r[0]){const gMat=fM.r[0];const instM=new THREE.InstancedMesh(bp,gMat,mxInst);instM.castShadow=instM.receiveShadow=!1;let instCt=0;const rotY1=1.047+rn(-.45,.45),rotY2=-1.047+rn(-.45,.45);for(let i=0;i<nG;i++){const cX=rn(-TW*.45,TW*.45),cZ=rn(TH*-.9,TH*.45);const isBnk=bD.bMY==0&&cX>=bD.bNX&&cX<=bD.bXX&&cZ>=bD.bNZ&&cZ<=bD.bXZ;const isPth=pFloorY==0&&cX>=pStartX-perturbationAmount*1.2&&cX<=pEndX+perturbationAmount*1.2&&cZ>=pStartZ&&cZ<=pEndZ;if(isBnk||isPth)continue;const cY=gFH(cX,cZ);if(cY<-.5||cY>max(EHH*.7,RHH*.8)||isNaN(cY))continue;for(let j=0;j<gP;j++){if(instCt>=mxInst)break;const w=rn(GWN,GWX),h=w*rn(GHN,GHX),s=rn(GSN,GSX);const pX=cX+rn(-gS*.25,gS*.25),pZ=cZ+rn(-gS*.25,gS*.25),pY=cY+h*s/2-.1;const scX=w*s,scY=h*s;_vS.set(scX,scY,1);_vP.set(pX,pY,pZ);_e.set(0,0,0);_q.setFromEuler(_e);_m4.compose(_vP,_q,_vS);instM.setMatrixAt(instCt++,_m4);if(instCt>=mxInst)break;_e.set(0,rotY1,0);_q.setFromEuler(_e);_m4.compose(_vP,_q,_vS);instM.setMatrixAt(instCt++,_m4);if(instCt>=mxInst)break;_e.set(0,rotY2,0);_q.setFromEuler(_e);_m4.compose(_vP,_q,_vS);instM.setMatrixAt(instCt++,_m4);}if(instCt>=mxInst)break;}instM.count=instCt;instM.instanceMatrix.needsUpdate=!0;rG.add(instM);}scn.add(rG);
    faG=new GP();const farZ=-TH/2+5,sideX=TW/2-5,placementDepth=50,billboardYOffset=-1.5,billboardYOffsetVar=1;const numForestStrips=35,treeStripW=55,treeStripWV=20,treeStripH=18,treeStripHV=6,bushStripW=22,bushStripWV=8,bushStripH=7,bushStripHV=3;for(let i=0;i<numForestStrips;i++){let x,z,rotY=0,isBush=!1;const matIndex=~~rn(0,fM.fa.length),textureKey=faK[matIndex],forestMat=fM.fa[matIndex];if(!forestMat)continue;if(textureKey==='fa3'||textureKey==='fa6')isBush=!0;const zone=rn(0,3);if(zone<1.5){x=rn(-TW*.5,TW*.5);z=farZ+rn(0,placementDepth);rotY=rn(-.1,.1)}else if(zone<2.25){x=-sideX-rn(0,placementDepth);z=rn(-TH*.5,farZ*.5);rotY=PI/2+rn(-.15,.15)}else{x=sideX+rn(0,placementDepth);z=rn(-TH*.5,farZ*.5);rotY=-PI/2+rn(-.15,.15)}const y=gFH(x,z);if(y<3||isNaN(y))continue;let w,h,yOff;if(isBush){w=bushStripW+rn(-bushStripWV,bushStripWV);h=bushStripH+rn(-bushStripHV,bushStripHV);yOff=billboardYOffset*.5+rn(-billboardYOffsetVar*.5,billboardYOffsetVar*.5)}else{w=treeStripW+rn(-treeStripWV,treeStripWV);h=treeStripH+rn(-treeStripHV,treeStripHV);yOff=billboardYOffset+rn(-billboardYOffsetVar,billboardYOffsetVar)}const faMesh=new THREE.Mesh(bp,forestMat);faMesh.scale.set(w,h,1);faMesh.position.set(x,y+h/2+yOff,z);faMesh.rotation.y=rotY;faMesh.castShadow=!1;faMesh.receiveShadow=!1;faMesh.renderOrder=-1;faG.add(faMesh)}const numDistantTrees=150,distantTreeBH=18,distantTreeHV=5,distantTreeBW=5,distantTreeWV=2,distantTreeYO=-.5;for(let i=0;i<numDistantTrees;i++){let x,z;const zone=rn(0,3);if(zone<1.8){x=rn(-TW*.5,TW*.5);z=farZ+rn(5,placementDepth+10)}else if(zone<2.4){x=-sideX-rn(5,placementDepth+10);z=rn(-TH*.5,farZ*.6)}else{x=sideX+rn(5,placementDepth+10);z=rn(-TH*.5,farZ*.6)}const y=gFH(x,z);if(y<4||isNaN(y))continue;const matIndex=~~rn(0,fM.t.length),treeMat=fM.t[matIndex];if(!treeMat)continue;const h=distantTreeBH+rn(0,distantTreeHV),w=distantTreeBW+rn(0,distantTreeWV);const treeMesh=new THREE.Mesh(bp,treeMat);treeMesh.scale.set(w,h,1);treeMesh.position.set(x,y+h/2+distantTreeYO,z);treeMesh.castShadow=!1;treeMesh.receiveShadow=!1;treeMesh.renderOrder=-1;treeMesh.onBeforeRender=()=>{tV.setFromMatrixPosition(cam.matrixWorld);treeMesh.lookAt(tV.x,treeMesh.position.y+1,tV.z)};faG.add(treeMesh)}scn.add(faG)
}

const cEn=()=>{eG=new GP();if(!bD||bD.bMY!=0)return;const tDX=BCX+DOX,dCY=bD.bMY+DH/2,dZ=bD.bXZ+DZOFB+DTK/2;const mh=new THREE.Mesh(new BG(DW,DH,DTK),dM||new MS({color:0xff00ff}));mh.position.set(tDX,dCY,dZ);mh.castShadow=mh.receiveShadow=!1;eG.add(mh);const bm=new THREE.Mesh(new BG(DW*1.2,DH*1.1,CSZ*3),new MB({color:0x0,side:BS}));bm.position.set(tDX,dCY,dZ-DTK/2-CSZ*1.5);eG.add(bm);scn.add(eG);addDrFrm(tDX,dCY,dZ,DW,DH,DTK);addKcRd(tDX,dCY,dZ,DW,DH,DTK)}
const addDrFrm=(tDX,dCY,dZ,dW,dH,dTh)=>{if(!dFrM)return;const trmW=CSZ*.25,trmD=.25,frameCenterZ=bD.bXZ+trmD/2;const addF=(w,h,x,y)=>{const m=new THREE.Mesh(new BG(w,h,trmD),dFrM);m.position.set(x,y,frameCenterZ);m.castShadow=m.receiveShadow=!1;eG.add(m)};addF(dW+2*trmW,trmW,tDX,dCY+dH/2+trmW/2);const sideH=dH+trmW;addF(trmW,sideH,tDX-dW/2-trmW/2,dCY-trmW/2);addF(trmW,sideH,tDX+dW/2+trmW/2,dCY-trmW/2)}
const addKcRd=(tDX,dCY,dZ,dW,dH,dTh)=>{const readerMat=kRdTexM||kRdM;if(!readerMat)return;const rW=.15,rH=.2,rD=.03,trmW=CSZ*.25,trmD=.25,rOff=.05;const rX=tDX+dW/2+trmW+rOff+rW/2,rY=dCY,frameFrontZ=bD.bXZ+trmD,rZ=frameFrontZ+rD/2;const rM=new THREE.Mesh(new BG(rD,rH,rW),readerMat);rM.position.set(rX,rY,rZ);rM.castShadow=rM.receiveShadow=!1;eG.add(rM)}
const sS=(d,i=!1)=>{const tx=A[d.textureKey];if(!tx||tx instanceof CT)return;const p=d.worldPos.clone(),bO=.2,fY=bD.bMY;p.y=!i&&tM?max(gFH(p.x,p.z)+bO,.1):max(fY+bO,.1);const m=new SM({map:tx.clone(),transparent:!0,depthTest:!0,depthWrite:!0,sizeAttenuation:!0,alphaTest:.1});m.map.needsUpdate=!0;const s=new SP(m);s.position.copy(p);s.scale.set(ISKC,ISKC,ISKC);s.renderOrder=1;scn.add(s)}
const init=()=>{scn=new THREE.Scene();cam=new THREE.PerspectiveCamera(60,innerWidth/innerHeight,.2,1000);rnd=new THREE.WebGLRenderer({canvas:$('mapCanvas'),antialias:!1,alpha:!1});rnd.setPixelRatio(devicePixelRatio);rnd.setSize(innerWidth,innerHeight);rnd.shadowMap.enabled=!1;rnd.outputEncoding=SE;rnd.physicallyCorrectLights=!1;scn.add(new THREE.AmbientLight(0x8090a0,.7));const dL=new THREE.DirectionalLight(0xffffff,.9);dL.position.set(-90,140,-70);dL.castShadow=!1;scn.add(dL);ctrl=new THREE.OrbitControls(cam,rnd.domElement);Object.assign(ctrl,{enableDamping:!0,dampingFactor:.07,screenSpacePanning:!1,minDistance:3,maxDistance:150,maxPolarAngle:1.64});ctrl.target.set(BCX,THS*.2,BCZ);ctrl.update();iLd();ldA().then(()=>{cMa();cB();cE();cEn();sS({worldPos:kL,textureKey:'ik'},!1);const tDX=BCX+DOX,ctrlTargetY=bD.bMY+BBH/2,camDist=20,camHAbvTgt=BBH*.7;const camZ=bD.bXZ+camDist*.5,camX=tDX+camDist*.4,groundYCam=gFH(camX,camZ),camY=max(groundYCam+camHAbvTgt,ctrlTargetY+camHAbvTgt*.5,BBH);ctrl.target.set(tDX,ctrlTargetY,bD.bXZ+3);cam.position.set(camX,camY,camZ);ldO&&ldO.classList.add("hide");anm()}).catch(e=>{console.error("Setup Error:",e);ldT.innerText="ERROR";ldO&&ldO.classList.remove("hide")});onresize=onWRes}
const onWRes=()=>{cam.aspect=innerWidth/innerHeight;cam.updateProjectionMatrix();rnd.setSize(innerWidth,innerHeight)}
const anm=()=>{requestAnimationFrame(anm);ctrl.update();rnd.render(scn,cam)}
init()
</script>
</body>
</html>